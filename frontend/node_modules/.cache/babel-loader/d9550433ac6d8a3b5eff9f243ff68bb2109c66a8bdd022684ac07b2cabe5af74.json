{"ast":null,"code":"'use strict';\n\nvar conventions = require('./conventions');\nvar dom = require('./dom');\nvar errors = require('./errors');\nvar entities = require('./entities');\nvar sax = require('./sax');\nvar DOMImplementation = dom.DOMImplementation;\nvar hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;\nvar isHTMLMimeType = conventions.isHTMLMimeType;\nvar isValidMimeType = conventions.isValidMimeType;\nvar MIME_TYPE = conventions.MIME_TYPE;\nvar NAMESPACE = conventions.NAMESPACE;\nvar ParseError = errors.ParseError;\nvar XMLReader = sax.XMLReader;\n\n/**\n * Normalizes line ending according to <https://www.w3.org/TR/xml11/#sec-line-ends>:\n *\n * > XML parsed entities are often stored in computer files which,\n * > for editing convenience, are organized into lines.\n * > These lines are typically separated by some combination\n * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).\n * >\n * > To simplify the tasks of applications, the XML processor must behave\n * > as if it normalized all line breaks in external parsed entities (including the document entity)\n * > on input, before parsing, by translating all of the following to a single #xA character:\n * >\n * > 1. the two-character sequence #xD #xA,\n * > 2. the two-character sequence #xD #x85,\n * > 3. the single character #x85,\n * > 4. the single character #x2028,\n * > 5. any #xD character that is not immediately followed by #xA or #x85.\n *\n * @param {string} input\n * @returns {string}\n * @prettierignore\n */\nfunction normalizeLineEndings(input) {\n  return input.replace(/\\r[\\n\\u0085]/g, '\\n').replace(/[\\r\\u0085\\u2028]/g, '\\n');\n}\n\n/**\n * @typedef Locator\n * @property {number} [columnNumber]\n * @property {number} [lineNumber]\n */\n\n/**\n * @typedef DOMParserOptions\n * @property {typeof assign} [assign]\n * The method to use instead of `conventions.assign`, which is used to copy values from\n * `options` before they are used for parsing.\n * @property {typeof DOMHandler} [domHandler]\n * For internal testing: The class for creating an instance for handling events from the SAX\n * parser.\n * *****Warning: By configuring a faulty implementation, the specified behavior can completely\n * be broken.*****.\n * @property {Function} [errorHandler]\n * DEPRECATED! use `onError` instead.\n * @property {function(level:ErrorLevel, message:string, context: DOMHandler):void}\n * [onError]\n * A function that is invoked for every error that occurs during parsing.\n *\n * If it is not provided, all errors are reported to `console.error`\n * and only `fatalError`s are thrown as a `ParseError`,\n * which prevents any further processing.\n * If the provided method throws, a `ParserError` is thrown,\n * which prevents any further processing.\n *\n * Be aware that many `warning`s are considered an error that prevents further processing in\n * most implementations.\n * @property {boolean} [locator=true]\n * Configures if the nodes created during parsing will have a `lineNumber` and a `columnNumber`\n * attribute describing their location in the XML string.\n * Default is true.\n * @property {(string) => string} [normalizeLineEndings]\n * used to replace line endings before parsing, defaults to `normalizeLineEndings`\n * @property {Object} [xmlns]\n * The XML namespaces that should be assumed when parsing.\n * The default namespace can be provided by the key that is the empty string.\n * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,\n * the default namespace that will be used,\n * will be overridden according to the specification.\n * @see {@link normalizeLineEndings}\n */\n\n/**\n * The DOMParser interface provides the ability to parse XML or HTML source code from a string\n * into a DOM `Document`.\n *\n * ***xmldom is different from the spec in that it allows an `options` parameter,\n * to control the behavior***.\n *\n * @class\n * @param {DOMParserOptions} [options]\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization\n */\nfunction DOMParser(options) {\n  options = options || {};\n  if (options.locator === undefined) {\n    options.locator = true;\n  }\n\n  /**\n   * The method to use instead of `conventions.assign`, which is used to copy values from\n   * `options`\n   * before they are used for parsing.\n   *\n   * @type {conventions.assign}\n   * @private\n   * @see {@link conventions.assign}\n   * @readonly\n   */\n  this.assign = options.assign || conventions.assign;\n\n  /**\n   * For internal testing: The class for creating an instance for handling events from the SAX\n   * parser.\n   * *****Warning: By configuring a faulty implementation, the specified behavior can completely\n   * be broken*****.\n   *\n   * @type {typeof DOMHandler}\n   * @private\n   * @readonly\n   */\n  this.domHandler = options.domHandler || DOMHandler;\n\n  /**\n   * A function that is invoked for every error that occurs during parsing.\n   *\n   * If it is not provided, all errors are reported to `console.error`\n   * and only `fatalError`s are thrown as a `ParseError`,\n   * which prevents any further processing.\n   * If the provided method throws, a `ParserError` is thrown,\n   * which prevents any further processing.\n   *\n   * Be aware that many `warning`s are considered an error that prevents further processing in\n   * most implementations.\n   *\n   * @type {function(level:ErrorLevel, message:string, context: DOMHandler):void}\n   * @see {@link onErrorStopParsing}\n   * @see {@link onWarningStopParsing}\n   */\n  this.onError = options.onError || options.errorHandler;\n  if (options.errorHandler && typeof options.errorHandler !== 'function') {\n    throw new TypeError('errorHandler object is no longer supported, switch to onError!');\n  } else if (options.errorHandler) {\n    options.errorHandler('warning', 'The `errorHandler` option has been deprecated, use `onError` instead!', this);\n  }\n\n  /**\n   * used to replace line endings before parsing, defaults to `normalizeLineEndings`\n   *\n   * @type {(string) => string}\n   * @readonly\n   */\n  this.normalizeLineEndings = options.normalizeLineEndings || normalizeLineEndings;\n\n  /**\n   * Configures if the nodes created during parsing will have a `lineNumber` and a\n   * `columnNumber`\n   * attribute describing their location in the XML string.\n   * Default is true.\n   *\n   * @type {boolean}\n   * @readonly\n   */\n  this.locator = !!options.locator;\n\n  /**\n   * The default namespace can be provided by the key that is the empty string.\n   * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,\n   * the default namespace that will be used,\n   * will be overridden according to the specification.\n   *\n   * @type {Readonly<Object>}\n   * @readonly\n   */\n  this.xmlns = this.assign(Object.create(null), options.xmlns);\n}\n\n/**\n * Parses `source` using the options in the way configured by the `DOMParserOptions` of `this`\n * `DOMParser`. If `mimeType` is `text/html` an HTML `Document` is created,\n * otherwise an XML `Document` is created.\n *\n * __It behaves different from the description in the living standard__:\n * - Uses the `options` passed to the `DOMParser` constructor to modify the behavior.\n * - Any unexpected input is reported to `onError` with either a `warning`,\n * `error` or `fatalError` level.\n * - Any `fatalError` throws a `ParseError` which prevents further processing.\n * - Any error thrown by `onError` is converted to a `ParseError` which prevents further\n * processing - If no `Document` was created during parsing it is reported as a `fatalError`.\n * *****Warning: By configuring a faulty DOMHandler implementation,\n * the specified behavior can completely be broken*****.\n *\n * @param {string} source\n * The XML mime type only allows string input!\n * @param {string} [mimeType='application/xml']\n * the mimeType or contentType of the document to be created determines the `type` of document\n * created (XML or HTML)\n * @returns {Document}\n * The `Document` node.\n * @throws {ParseError}\n * for any `fatalError` or anything that is thrown by `onError`\n * @throws {TypeError}\n * for any invalid `mimeType`\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString\n * @see https://html.spec.whatwg.org/#dom-domparser-parsefromstring-dev\n */\nDOMParser.prototype.parseFromString = function (source, mimeType) {\n  if (!isValidMimeType(mimeType)) {\n    throw new TypeError('DOMParser.parseFromString: the provided mimeType \"' + mimeType + '\" is not valid.');\n  }\n  var defaultNSMap = this.assign(Object.create(null), this.xmlns);\n  var entityMap = entities.XML_ENTITIES;\n  var defaultNamespace = defaultNSMap[''] || null;\n  if (hasDefaultHTMLNamespace(mimeType)) {\n    entityMap = entities.HTML_ENTITIES;\n    defaultNamespace = NAMESPACE.HTML;\n  } else if (mimeType === MIME_TYPE.XML_SVG_IMAGE) {\n    defaultNamespace = NAMESPACE.SVG;\n  }\n  defaultNSMap[''] = defaultNamespace;\n  defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\n  var domBuilder = new this.domHandler({\n    mimeType: mimeType,\n    defaultNamespace: defaultNamespace,\n    onError: this.onError\n  });\n  var locator = this.locator ? {} : undefined;\n  if (this.locator) {\n    domBuilder.setDocumentLocator(locator);\n  }\n  var sax = new XMLReader();\n  sax.errorHandler = domBuilder;\n  sax.domBuilder = domBuilder;\n  var isXml = !conventions.isHTMLMimeType(mimeType);\n  if (isXml && typeof source !== 'string') {\n    sax.errorHandler.fatalError('source is not a string');\n  }\n  sax.parse(this.normalizeLineEndings(String(source)), defaultNSMap, entityMap);\n  if (!domBuilder.doc.documentElement) {\n    sax.errorHandler.fatalError('missing root element');\n  }\n  return domBuilder.doc;\n};\n\n/**\n * @typedef DOMHandlerOptions\n * @property {string} [mimeType=MIME_TYPE.XML_APPLICATION]\n * @property {string | null} [defaultNamespace=null]\n */\n/**\n * The class that is used to handle events from the SAX parser to create the related DOM\n * elements.\n *\n * Some methods are only implemented as an empty function,\n * since they are (at least currently) not relevant for xmldom.\n *\n * @class\n * @param {DOMHandlerOptions} [options]\n * @see http://www.saxproject.org/apidoc/org/xml/sax/ext/DefaultHandler2.html\n */\nfunction DOMHandler(options) {\n  var opt = options || {};\n  /**\n   * The mime type is used to determine if the DOM handler will create an XML or HTML document.\n   * Only if it is set to `text/html` it will create an HTML document.\n   * It defaults to MIME_TYPE.XML_APPLICATION.\n   *\n   * @type {string}\n   * @see {@link MIME_TYPE}\n   * @readonly\n   */\n  this.mimeType = opt.mimeType || MIME_TYPE.XML_APPLICATION;\n\n  /**\n   * The namespace to use to create an XML document.\n   * For the following reasons this is required:\n   * - The SAX API for `startDocument` doesn't offer any way to pass a namespace,\n   * since at that point there is no way for the parser to know what the default namespace from\n   * the document will be.\n   * - When creating using `DOMImplementation.createDocument` it is required to pass a\n   * namespace,\n   * to determine the correct `Document.contentType`, which should match `this.mimeType`.\n   * - When parsing an XML document with the `application/xhtml+xml` mimeType,\n   * the HTML namespace needs to be the default namespace.\n   *\n   * @type {string | null}\n   * @private\n   * @readonly\n   */\n  this.defaultNamespace = opt.defaultNamespace || null;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.cdata = false;\n\n  /**\n   * The last `Element` that was created by `startElement`.\n   * `endElement` sets it to the `currentElement.parentNode`.\n   *\n   * Note: The sax parser currently sets it to white space text nodes between tags.\n   *\n   * @type {Element | Node | undefined}\n   * @private\n   */\n  this.currentElement = undefined;\n\n  /**\n   * The Document that is created as part of `startDocument`,\n   * and returned by `DOMParser.parseFromString`.\n   *\n   * @type {Document | undefined}\n   * @readonly\n   */\n  this.doc = undefined;\n\n  /**\n   * The locator is stored as part of setDocumentLocator.\n   * It is controlled and mutated by the SAX parser to store the current parsing position.\n   * It is used by DOMHandler to set `columnNumber` and `lineNumber`\n   * on the DOM nodes.\n   *\n   * @type {Readonly<Locator> | undefined}\n   * @private\n   * @readonly (the\n   * sax parser currently sometimes set's it)\n   */\n  this.locator = undefined;\n  /**\n   * @type {function (level:ErrorLevel ,message:string, context:DOMHandler):void}\n   * @readonly\n   */\n  this.onError = opt.onError;\n}\nfunction position(locator, node) {\n  node.lineNumber = locator.lineNumber;\n  node.columnNumber = locator.columnNumber;\n}\nDOMHandler.prototype = {\n  /**\n   * Either creates an XML or an HTML document and stores it under `this.doc`.\n   * If it is an XML document, `this.defaultNamespace` is used to create it,\n   * and it will not contain any `childNodes`.\n   * If it is an HTML document, it will be created without any `childNodes`.\n   *\n   * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\n   */\n  startDocument: function () {\n    var impl = new DOMImplementation();\n    this.doc = isHTMLMimeType(this.mimeType) ? impl.createHTMLDocument(false) : impl.createDocument(this.defaultNamespace, '');\n  },\n  startElement: function (namespaceURI, localName, qName, attrs) {\n    var doc = this.doc;\n    var el = doc.createElementNS(namespaceURI, qName || localName);\n    var len = attrs.length;\n    appendElement(this, el);\n    this.currentElement = el;\n    this.locator && position(this.locator, el);\n    for (var i = 0; i < len; i++) {\n      var namespaceURI = attrs.getURI(i);\n      var value = attrs.getValue(i);\n      var qName = attrs.getQName(i);\n      var attr = doc.createAttributeNS(namespaceURI, qName);\n      this.locator && position(attrs.getLocator(i), attr);\n      attr.value = attr.nodeValue = value;\n      el.setAttributeNode(attr);\n    }\n  },\n  endElement: function (namespaceURI, localName, qName) {\n    this.currentElement = this.currentElement.parentNode;\n  },\n  startPrefixMapping: function (prefix, uri) {},\n  endPrefixMapping: function (prefix) {},\n  processingInstruction: function (target, data) {\n    var ins = this.doc.createProcessingInstruction(target, data);\n    this.locator && position(this.locator, ins);\n    appendElement(this, ins);\n  },\n  ignorableWhitespace: function (ch, start, length) {},\n  characters: function (chars, start, length) {\n    chars = _toString.apply(this, arguments);\n    //console.log(chars)\n    if (chars) {\n      if (this.cdata) {\n        var charNode = this.doc.createCDATASection(chars);\n      } else {\n        var charNode = this.doc.createTextNode(chars);\n      }\n      if (this.currentElement) {\n        this.currentElement.appendChild(charNode);\n      } else if (/^\\s*$/.test(chars)) {\n        this.doc.appendChild(charNode);\n        //process xml\n      }\n      this.locator && position(this.locator, charNode);\n    }\n  },\n  skippedEntity: function (name) {},\n  endDocument: function () {\n    this.doc.normalize();\n  },\n  /**\n   * Stores the locator to be able to set the `columnNumber` and `lineNumber`\n   * on the created DOM nodes.\n   *\n   * @param {Locator} locator\n   */\n  setDocumentLocator: function (locator) {\n    if (locator) {\n      locator.lineNumber = 0;\n    }\n    this.locator = locator;\n  },\n  //LexicalHandler\n  comment: function (chars, start, length) {\n    chars = _toString.apply(this, arguments);\n    var comm = this.doc.createComment(chars);\n    this.locator && position(this.locator, comm);\n    appendElement(this, comm);\n  },\n  startCDATA: function () {\n    //used in characters() methods\n    this.cdata = true;\n  },\n  endCDATA: function () {\n    this.cdata = false;\n  },\n  startDTD: function (name, publicId, systemId, internalSubset) {\n    var impl = this.doc.implementation;\n    if (impl && impl.createDocumentType) {\n      var dt = impl.createDocumentType(name, publicId, systemId, internalSubset);\n      this.locator && position(this.locator, dt);\n      appendElement(this, dt);\n      this.doc.doctype = dt;\n    }\n  },\n  reportError: function (level, message) {\n    if (typeof this.onError === 'function') {\n      try {\n        this.onError(level, message, this);\n      } catch (e) {\n        throw new ParseError('Reporting ' + level + ' \"' + message + '\" caused ' + e, this.locator);\n      }\n    } else {\n      console.error('[xmldom ' + level + ']\\t' + message, _locator(this.locator));\n    }\n  },\n  /**\n   * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n   */\n  warning: function (message) {\n    this.reportError('warning', message);\n  },\n  error: function (message) {\n    this.reportError('error', message);\n  },\n  /**\n   * This function reports a fatal error and throws a ParseError.\n   *\n   * @param {string} message\n   * - The message to be used for reporting and throwing the error.\n   * @returns {never}\n   * This function always throws an error and never returns a value.\n   * @throws {ParseError}\n   * Always throws a ParseError with the provided message.\n   */\n  fatalError: function (message) {\n    this.reportError('fatalError', message);\n    throw new ParseError(message, this.locator);\n  }\n};\nfunction _locator(l) {\n  if (l) {\n    return '\\n@#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n  }\n}\nfunction _toString(chars, start, length) {\n  if (typeof chars == 'string') {\n    return chars.substr(start, length);\n  } else {\n    //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n    if (chars.length >= start + length || start) {\n      return new java.lang.String(chars, start, length) + '';\n    }\n    return chars;\n  }\n}\n\n/*\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\n * used method of org.xml.sax.ext.LexicalHandler:\n *  #comment(chars, start, length)\n *  #startCDATA()\n *  #endCDATA()\n *  #startDTD(name, publicId, systemId)\n *\n *\n * IGNORED method of org.xml.sax.ext.LexicalHandler:\n *  #endDTD()\n *  #startEntity(name)\n *  #endEntity(name)\n *\n *\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\n * IGNORED method of org.xml.sax.ext.DeclHandler\n * \t#attributeDecl(eName, aName, type, mode, value)\n *  #elementDecl(name, model)\n *  #externalEntityDecl(name, publicId, systemId)\n *  #internalEntityDecl(name, value)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\n * IGNORED method of org.xml.sax.EntityResolver2\n *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\n *  #resolveEntity(publicId, systemId)\n *  #getExternalSubset(name, baseURI)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\n * IGNORED method of org.xml.sax.DTDHandler\n *  #notationDecl(name, publicId, systemId) {};\n *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\n */\n'endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl'.replace(/\\w+/g, function (key) {\n  DOMHandler.prototype[key] = function () {\n    return null;\n  };\n});\n\n/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\nfunction appendElement(handler, node) {\n  if (!handler.currentElement) {\n    handler.doc.appendChild(node);\n  } else {\n    handler.currentElement.appendChild(node);\n  }\n}\n\n/**\n * A method that prevents any further parsing when an `error`\n * with level `error` is reported during parsing.\n *\n * @see {@link DOMParserOptions.onError}\n * @see {@link onWarningStopParsing}\n */\nfunction onErrorStopParsing(level) {\n  if (level === 'error') throw 'onErrorStopParsing';\n}\n\n/**\n * A method that prevents any further parsing when any `error` is reported during parsing.\n *\n * @see {@link DOMParserOptions.onError}\n * @see {@link onErrorStopParsing}\n */\nfunction onWarningStopParsing() {\n  throw 'onWarningStopParsing';\n}\nexports.__DOMHandler = DOMHandler;\nexports.DOMParser = DOMParser;\nexports.normalizeLineEndings = normalizeLineEndings;\nexports.onErrorStopParsing = onErrorStopParsing;\nexports.onWarningStopParsing = onWarningStopParsing;","map":{"version":3,"names":["conventions","require","dom","errors","entities","sax","DOMImplementation","hasDefaultHTMLNamespace","isHTMLMimeType","isValidMimeType","MIME_TYPE","NAMESPACE","ParseError","XMLReader","normalizeLineEndings","input","replace","DOMParser","options","locator","undefined","assign","domHandler","DOMHandler","onError","errorHandler","TypeError","xmlns","Object","create","prototype","parseFromString","source","mimeType","defaultNSMap","entityMap","XML_ENTITIES","defaultNamespace","HTML_ENTITIES","HTML","XML_SVG_IMAGE","SVG","xml","XML","domBuilder","setDocumentLocator","isXml","fatalError","parse","String","doc","documentElement","opt","XML_APPLICATION","cdata","currentElement","position","node","lineNumber","columnNumber","startDocument","impl","createHTMLDocument","createDocument","startElement","namespaceURI","localName","qName","attrs","el","createElementNS","len","length","appendElement","i","getURI","value","getValue","getQName","attr","createAttributeNS","getLocator","nodeValue","setAttributeNode","endElement","parentNode","startPrefixMapping","prefix","uri","endPrefixMapping","processingInstruction","target","data","ins","createProcessingInstruction","ignorableWhitespace","ch","start","characters","chars","_toString","apply","arguments","charNode","createCDATASection","createTextNode","appendChild","test","skippedEntity","name","endDocument","normalize","comment","comm","createComment","startCDATA","endCDATA","startDTD","publicId","systemId","internalSubset","implementation","createDocumentType","dt","doctype","reportError","level","message","e","console","error","_locator","warning","l","substr","java","lang","key","handler","onErrorStopParsing","onWarningStopParsing","exports","__DOMHandler"],"sources":["C:/Users/rc_sh/Desktop/Unidad oftalmologica/Clinica_rosmarian_castillo/frontend/node_modules/@xmldom/xmldom/lib/dom-parser.js"],"sourcesContent":["'use strict';\n\nvar conventions = require('./conventions');\nvar dom = require('./dom');\nvar errors = require('./errors');\nvar entities = require('./entities');\nvar sax = require('./sax');\n\nvar DOMImplementation = dom.DOMImplementation;\n\nvar hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;\nvar isHTMLMimeType = conventions.isHTMLMimeType;\nvar isValidMimeType = conventions.isValidMimeType;\nvar MIME_TYPE = conventions.MIME_TYPE;\nvar NAMESPACE = conventions.NAMESPACE;\nvar ParseError = errors.ParseError;\n\nvar XMLReader = sax.XMLReader;\n\n/**\n * Normalizes line ending according to <https://www.w3.org/TR/xml11/#sec-line-ends>:\n *\n * > XML parsed entities are often stored in computer files which,\n * > for editing convenience, are organized into lines.\n * > These lines are typically separated by some combination\n * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).\n * >\n * > To simplify the tasks of applications, the XML processor must behave\n * > as if it normalized all line breaks in external parsed entities (including the document entity)\n * > on input, before parsing, by translating all of the following to a single #xA character:\n * >\n * > 1. the two-character sequence #xD #xA,\n * > 2. the two-character sequence #xD #x85,\n * > 3. the single character #x85,\n * > 4. the single character #x2028,\n * > 5. any #xD character that is not immediately followed by #xA or #x85.\n *\n * @param {string} input\n * @returns {string}\n * @prettierignore\n */\nfunction normalizeLineEndings(input) {\n\treturn input.replace(/\\r[\\n\\u0085]/g, '\\n').replace(/[\\r\\u0085\\u2028]/g, '\\n');\n}\n\n/**\n * @typedef Locator\n * @property {number} [columnNumber]\n * @property {number} [lineNumber]\n */\n\n/**\n * @typedef DOMParserOptions\n * @property {typeof assign} [assign]\n * The method to use instead of `conventions.assign`, which is used to copy values from\n * `options` before they are used for parsing.\n * @property {typeof DOMHandler} [domHandler]\n * For internal testing: The class for creating an instance for handling events from the SAX\n * parser.\n * *****Warning: By configuring a faulty implementation, the specified behavior can completely\n * be broken.*****.\n * @property {Function} [errorHandler]\n * DEPRECATED! use `onError` instead.\n * @property {function(level:ErrorLevel, message:string, context: DOMHandler):void}\n * [onError]\n * A function that is invoked for every error that occurs during parsing.\n *\n * If it is not provided, all errors are reported to `console.error`\n * and only `fatalError`s are thrown as a `ParseError`,\n * which prevents any further processing.\n * If the provided method throws, a `ParserError` is thrown,\n * which prevents any further processing.\n *\n * Be aware that many `warning`s are considered an error that prevents further processing in\n * most implementations.\n * @property {boolean} [locator=true]\n * Configures if the nodes created during parsing will have a `lineNumber` and a `columnNumber`\n * attribute describing their location in the XML string.\n * Default is true.\n * @property {(string) => string} [normalizeLineEndings]\n * used to replace line endings before parsing, defaults to `normalizeLineEndings`\n * @property {Object} [xmlns]\n * The XML namespaces that should be assumed when parsing.\n * The default namespace can be provided by the key that is the empty string.\n * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,\n * the default namespace that will be used,\n * will be overridden according to the specification.\n * @see {@link normalizeLineEndings}\n */\n\n/**\n * The DOMParser interface provides the ability to parse XML or HTML source code from a string\n * into a DOM `Document`.\n *\n * ***xmldom is different from the spec in that it allows an `options` parameter,\n * to control the behavior***.\n *\n * @class\n * @param {DOMParserOptions} [options]\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization\n */\nfunction DOMParser(options) {\n\toptions = options || {};\n\tif (options.locator === undefined) {\n\t\toptions.locator = true;\n\t}\n\n\t/**\n\t * The method to use instead of `conventions.assign`, which is used to copy values from\n\t * `options`\n\t * before they are used for parsing.\n\t *\n\t * @type {conventions.assign}\n\t * @private\n\t * @see {@link conventions.assign}\n\t * @readonly\n\t */\n\tthis.assign = options.assign || conventions.assign;\n\n\t/**\n\t * For internal testing: The class for creating an instance for handling events from the SAX\n\t * parser.\n\t * *****Warning: By configuring a faulty implementation, the specified behavior can completely\n\t * be broken*****.\n\t *\n\t * @type {typeof DOMHandler}\n\t * @private\n\t * @readonly\n\t */\n\tthis.domHandler = options.domHandler || DOMHandler;\n\n\t/**\n\t * A function that is invoked for every error that occurs during parsing.\n\t *\n\t * If it is not provided, all errors are reported to `console.error`\n\t * and only `fatalError`s are thrown as a `ParseError`,\n\t * which prevents any further processing.\n\t * If the provided method throws, a `ParserError` is thrown,\n\t * which prevents any further processing.\n\t *\n\t * Be aware that many `warning`s are considered an error that prevents further processing in\n\t * most implementations.\n\t *\n\t * @type {function(level:ErrorLevel, message:string, context: DOMHandler):void}\n\t * @see {@link onErrorStopParsing}\n\t * @see {@link onWarningStopParsing}\n\t */\n\tthis.onError = options.onError || options.errorHandler;\n\tif (options.errorHandler && typeof options.errorHandler !== 'function') {\n\t\tthrow new TypeError('errorHandler object is no longer supported, switch to onError!');\n\t} else if (options.errorHandler) {\n\t\toptions.errorHandler('warning', 'The `errorHandler` option has been deprecated, use `onError` instead!', this);\n\t}\n\n\t/**\n\t * used to replace line endings before parsing, defaults to `normalizeLineEndings`\n\t *\n\t * @type {(string) => string}\n\t * @readonly\n\t */\n\tthis.normalizeLineEndings = options.normalizeLineEndings || normalizeLineEndings;\n\n\t/**\n\t * Configures if the nodes created during parsing will have a `lineNumber` and a\n\t * `columnNumber`\n\t * attribute describing their location in the XML string.\n\t * Default is true.\n\t *\n\t * @type {boolean}\n\t * @readonly\n\t */\n\tthis.locator = !!options.locator;\n\n\t/**\n\t * The default namespace can be provided by the key that is the empty string.\n\t * When the `mimeType` for HTML, XHTML or SVG are passed to `parseFromString`,\n\t * the default namespace that will be used,\n\t * will be overridden according to the specification.\n\t *\n\t * @type {Readonly<Object>}\n\t * @readonly\n\t */\n\tthis.xmlns = this.assign(Object.create(null), options.xmlns);\n}\n\n/**\n * Parses `source` using the options in the way configured by the `DOMParserOptions` of `this`\n * `DOMParser`. If `mimeType` is `text/html` an HTML `Document` is created,\n * otherwise an XML `Document` is created.\n *\n * __It behaves different from the description in the living standard__:\n * - Uses the `options` passed to the `DOMParser` constructor to modify the behavior.\n * - Any unexpected input is reported to `onError` with either a `warning`,\n * `error` or `fatalError` level.\n * - Any `fatalError` throws a `ParseError` which prevents further processing.\n * - Any error thrown by `onError` is converted to a `ParseError` which prevents further\n * processing - If no `Document` was created during parsing it is reported as a `fatalError`.\n * *****Warning: By configuring a faulty DOMHandler implementation,\n * the specified behavior can completely be broken*****.\n *\n * @param {string} source\n * The XML mime type only allows string input!\n * @param {string} [mimeType='application/xml']\n * the mimeType or contentType of the document to be created determines the `type` of document\n * created (XML or HTML)\n * @returns {Document}\n * The `Document` node.\n * @throws {ParseError}\n * for any `fatalError` or anything that is thrown by `onError`\n * @throws {TypeError}\n * for any invalid `mimeType`\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString\n * @see https://html.spec.whatwg.org/#dom-domparser-parsefromstring-dev\n */\nDOMParser.prototype.parseFromString = function (source, mimeType) {\n\tif (!isValidMimeType(mimeType)) {\n\t\tthrow new TypeError('DOMParser.parseFromString: the provided mimeType \"' + mimeType + '\" is not valid.');\n\t}\n\tvar defaultNSMap = this.assign(Object.create(null), this.xmlns);\n\tvar entityMap = entities.XML_ENTITIES;\n\tvar defaultNamespace = defaultNSMap[''] || null;\n\tif (hasDefaultHTMLNamespace(mimeType)) {\n\t\tentityMap = entities.HTML_ENTITIES;\n\t\tdefaultNamespace = NAMESPACE.HTML;\n\t} else if (mimeType === MIME_TYPE.XML_SVG_IMAGE) {\n\t\tdefaultNamespace = NAMESPACE.SVG;\n\t}\n\tdefaultNSMap[''] = defaultNamespace;\n\tdefaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\n\n\tvar domBuilder = new this.domHandler({\n\t\tmimeType: mimeType,\n\t\tdefaultNamespace: defaultNamespace,\n\t\tonError: this.onError,\n\t});\n\tvar locator = this.locator ? {} : undefined;\n\tif (this.locator) {\n\t\tdomBuilder.setDocumentLocator(locator);\n\t}\n\n\tvar sax = new XMLReader();\n\tsax.errorHandler = domBuilder;\n\tsax.domBuilder = domBuilder;\n\tvar isXml = !conventions.isHTMLMimeType(mimeType);\n\tif (isXml && typeof source !== 'string') {\n\t\tsax.errorHandler.fatalError('source is not a string');\n\t}\n\tsax.parse(this.normalizeLineEndings(String(source)), defaultNSMap, entityMap);\n\tif (!domBuilder.doc.documentElement) {\n\t\tsax.errorHandler.fatalError('missing root element');\n\t}\n\treturn domBuilder.doc;\n};\n\n/**\n * @typedef DOMHandlerOptions\n * @property {string} [mimeType=MIME_TYPE.XML_APPLICATION]\n * @property {string | null} [defaultNamespace=null]\n */\n/**\n * The class that is used to handle events from the SAX parser to create the related DOM\n * elements.\n *\n * Some methods are only implemented as an empty function,\n * since they are (at least currently) not relevant for xmldom.\n *\n * @class\n * @param {DOMHandlerOptions} [options]\n * @see http://www.saxproject.org/apidoc/org/xml/sax/ext/DefaultHandler2.html\n */\nfunction DOMHandler(options) {\n\tvar opt = options || {};\n\t/**\n\t * The mime type is used to determine if the DOM handler will create an XML or HTML document.\n\t * Only if it is set to `text/html` it will create an HTML document.\n\t * It defaults to MIME_TYPE.XML_APPLICATION.\n\t *\n\t * @type {string}\n\t * @see {@link MIME_TYPE}\n\t * @readonly\n\t */\n\tthis.mimeType = opt.mimeType || MIME_TYPE.XML_APPLICATION;\n\n\t/**\n\t * The namespace to use to create an XML document.\n\t * For the following reasons this is required:\n\t * - The SAX API for `startDocument` doesn't offer any way to pass a namespace,\n\t * since at that point there is no way for the parser to know what the default namespace from\n\t * the document will be.\n\t * - When creating using `DOMImplementation.createDocument` it is required to pass a\n\t * namespace,\n\t * to determine the correct `Document.contentType`, which should match `this.mimeType`.\n\t * - When parsing an XML document with the `application/xhtml+xml` mimeType,\n\t * the HTML namespace needs to be the default namespace.\n\t *\n\t * @type {string | null}\n\t * @private\n\t * @readonly\n\t */\n\tthis.defaultNamespace = opt.defaultNamespace || null;\n\n\t/**\n\t * @type {boolean}\n\t * @private\n\t */\n\tthis.cdata = false;\n\n\t/**\n\t * The last `Element` that was created by `startElement`.\n\t * `endElement` sets it to the `currentElement.parentNode`.\n\t *\n\t * Note: The sax parser currently sets it to white space text nodes between tags.\n\t *\n\t * @type {Element | Node | undefined}\n\t * @private\n\t */\n\tthis.currentElement = undefined;\n\n\t/**\n\t * The Document that is created as part of `startDocument`,\n\t * and returned by `DOMParser.parseFromString`.\n\t *\n\t * @type {Document | undefined}\n\t * @readonly\n\t */\n\tthis.doc = undefined;\n\n\t/**\n\t * The locator is stored as part of setDocumentLocator.\n\t * It is controlled and mutated by the SAX parser to store the current parsing position.\n\t * It is used by DOMHandler to set `columnNumber` and `lineNumber`\n\t * on the DOM nodes.\n\t *\n\t * @type {Readonly<Locator> | undefined}\n\t * @private\n\t * @readonly (the\n\t * sax parser currently sometimes set's it)\n\t */\n\tthis.locator = undefined;\n\t/**\n\t * @type {function (level:ErrorLevel ,message:string, context:DOMHandler):void}\n\t * @readonly\n\t */\n\tthis.onError = opt.onError;\n}\n\nfunction position(locator, node) {\n\tnode.lineNumber = locator.lineNumber;\n\tnode.columnNumber = locator.columnNumber;\n}\n\nDOMHandler.prototype = {\n\t/**\n\t * Either creates an XML or an HTML document and stores it under `this.doc`.\n\t * If it is an XML document, `this.defaultNamespace` is used to create it,\n\t * and it will not contain any `childNodes`.\n\t * If it is an HTML document, it will be created without any `childNodes`.\n\t *\n\t * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\n\t */\n\tstartDocument: function () {\n\t\tvar impl = new DOMImplementation();\n\t\tthis.doc = isHTMLMimeType(this.mimeType) ? impl.createHTMLDocument(false) : impl.createDocument(this.defaultNamespace, '');\n\t},\n\tstartElement: function (namespaceURI, localName, qName, attrs) {\n\t\tvar doc = this.doc;\n\t\tvar el = doc.createElementNS(namespaceURI, qName || localName);\n\t\tvar len = attrs.length;\n\t\tappendElement(this, el);\n\t\tthis.currentElement = el;\n\n\t\tthis.locator && position(this.locator, el);\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar namespaceURI = attrs.getURI(i);\n\t\t\tvar value = attrs.getValue(i);\n\t\t\tvar qName = attrs.getQName(i);\n\t\t\tvar attr = doc.createAttributeNS(namespaceURI, qName);\n\t\t\tthis.locator && position(attrs.getLocator(i), attr);\n\t\t\tattr.value = attr.nodeValue = value;\n\t\t\tel.setAttributeNode(attr);\n\t\t}\n\t},\n\tendElement: function (namespaceURI, localName, qName) {\n\t\tthis.currentElement = this.currentElement.parentNode;\n\t},\n\tstartPrefixMapping: function (prefix, uri) {},\n\tendPrefixMapping: function (prefix) {},\n\tprocessingInstruction: function (target, data) {\n\t\tvar ins = this.doc.createProcessingInstruction(target, data);\n\t\tthis.locator && position(this.locator, ins);\n\t\tappendElement(this, ins);\n\t},\n\tignorableWhitespace: function (ch, start, length) {},\n\tcharacters: function (chars, start, length) {\n\t\tchars = _toString.apply(this, arguments);\n\t\t//console.log(chars)\n\t\tif (chars) {\n\t\t\tif (this.cdata) {\n\t\t\t\tvar charNode = this.doc.createCDATASection(chars);\n\t\t\t} else {\n\t\t\t\tvar charNode = this.doc.createTextNode(chars);\n\t\t\t}\n\t\t\tif (this.currentElement) {\n\t\t\t\tthis.currentElement.appendChild(charNode);\n\t\t\t} else if (/^\\s*$/.test(chars)) {\n\t\t\t\tthis.doc.appendChild(charNode);\n\t\t\t\t//process xml\n\t\t\t}\n\t\t\tthis.locator && position(this.locator, charNode);\n\t\t}\n\t},\n\tskippedEntity: function (name) {},\n\tendDocument: function () {\n\t\tthis.doc.normalize();\n\t},\n\t/**\n\t * Stores the locator to be able to set the `columnNumber` and `lineNumber`\n\t * on the created DOM nodes.\n\t *\n\t * @param {Locator} locator\n\t */\n\tsetDocumentLocator: function (locator) {\n\t\tif (locator) {\n\t\t\tlocator.lineNumber = 0;\n\t\t}\n\t\tthis.locator = locator;\n\t},\n\t//LexicalHandler\n\tcomment: function (chars, start, length) {\n\t\tchars = _toString.apply(this, arguments);\n\t\tvar comm = this.doc.createComment(chars);\n\t\tthis.locator && position(this.locator, comm);\n\t\tappendElement(this, comm);\n\t},\n\n\tstartCDATA: function () {\n\t\t//used in characters() methods\n\t\tthis.cdata = true;\n\t},\n\tendCDATA: function () {\n\t\tthis.cdata = false;\n\t},\n\n\tstartDTD: function (name, publicId, systemId, internalSubset) {\n\t\tvar impl = this.doc.implementation;\n\t\tif (impl && impl.createDocumentType) {\n\t\t\tvar dt = impl.createDocumentType(name, publicId, systemId, internalSubset);\n\t\t\tthis.locator && position(this.locator, dt);\n\t\t\tappendElement(this, dt);\n\t\t\tthis.doc.doctype = dt;\n\t\t}\n\t},\n\treportError: function (level, message) {\n\t\tif (typeof this.onError === 'function') {\n\t\t\ttry {\n\t\t\t\tthis.onError(level, message, this);\n\t\t\t} catch (e) {\n\t\t\t\tthrow new ParseError('Reporting ' + level + ' \"' + message + '\" caused ' + e, this.locator);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.error('[xmldom ' + level + ']\\t' + message, _locator(this.locator));\n\t\t}\n\t},\n\t/**\n\t * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n\t */\n\twarning: function (message) {\n\t\tthis.reportError('warning', message);\n\t},\n\terror: function (message) {\n\t\tthis.reportError('error', message);\n\t},\n\t/**\n\t * This function reports a fatal error and throws a ParseError.\n\t *\n\t * @param {string} message\n\t * - The message to be used for reporting and throwing the error.\n\t * @returns {never}\n\t * This function always throws an error and never returns a value.\n\t * @throws {ParseError}\n\t * Always throws a ParseError with the provided message.\n\t */\n\tfatalError: function (message) {\n\t\tthis.reportError('fatalError', message);\n\t\tthrow new ParseError(message, this.locator);\n\t},\n};\n\nfunction _locator(l) {\n\tif (l) {\n\t\treturn '\\n@#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n\t}\n}\n\nfunction _toString(chars, start, length) {\n\tif (typeof chars == 'string') {\n\t\treturn chars.substr(start, length);\n\t} else {\n\t\t//java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n\t\tif (chars.length >= start + length || start) {\n\t\t\treturn new java.lang.String(chars, start, length) + '';\n\t\t}\n\t\treturn chars;\n\t}\n}\n\n/*\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\n * used method of org.xml.sax.ext.LexicalHandler:\n *  #comment(chars, start, length)\n *  #startCDATA()\n *  #endCDATA()\n *  #startDTD(name, publicId, systemId)\n *\n *\n * IGNORED method of org.xml.sax.ext.LexicalHandler:\n *  #endDTD()\n *  #startEntity(name)\n *  #endEntity(name)\n *\n *\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\n * IGNORED method of org.xml.sax.ext.DeclHandler\n * \t#attributeDecl(eName, aName, type, mode, value)\n *  #elementDecl(name, model)\n *  #externalEntityDecl(name, publicId, systemId)\n *  #internalEntityDecl(name, value)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\n * IGNORED method of org.xml.sax.EntityResolver2\n *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\n *  #resolveEntity(publicId, systemId)\n *  #getExternalSubset(name, baseURI)\n * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\n * IGNORED method of org.xml.sax.DTDHandler\n *  #notationDecl(name, publicId, systemId) {};\n *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\n */\n'endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl'.replace(\n\t/\\w+/g,\n\tfunction (key) {\n\t\tDOMHandler.prototype[key] = function () {\n\t\t\treturn null;\n\t\t};\n\t}\n);\n\n/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\nfunction appendElement(handler, node) {\n\tif (!handler.currentElement) {\n\t\thandler.doc.appendChild(node);\n\t} else {\n\t\thandler.currentElement.appendChild(node);\n\t}\n}\n\n/**\n * A method that prevents any further parsing when an `error`\n * with level `error` is reported during parsing.\n *\n * @see {@link DOMParserOptions.onError}\n * @see {@link onWarningStopParsing}\n */\nfunction onErrorStopParsing(level) {\n\tif (level === 'error') throw 'onErrorStopParsing';\n}\n\n/**\n * A method that prevents any further parsing when any `error` is reported during parsing.\n *\n * @see {@link DOMParserOptions.onError}\n * @see {@link onErrorStopParsing}\n */\nfunction onWarningStopParsing() {\n\tthrow 'onWarningStopParsing';\n}\n\nexports.__DOMHandler = DOMHandler;\nexports.DOMParser = DOMParser;\nexports.normalizeLineEndings = normalizeLineEndings;\nexports.onErrorStopParsing = onErrorStopParsing;\nexports.onWarningStopParsing = onWarningStopParsing;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,WAAW,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC1C,IAAIC,GAAG,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC1B,IAAIE,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIG,QAAQ,GAAGH,OAAO,CAAC,YAAY,CAAC;AACpC,IAAII,GAAG,GAAGJ,OAAO,CAAC,OAAO,CAAC;AAE1B,IAAIK,iBAAiB,GAAGJ,GAAG,CAACI,iBAAiB;AAE7C,IAAIC,uBAAuB,GAAGP,WAAW,CAACO,uBAAuB;AACjE,IAAIC,cAAc,GAAGR,WAAW,CAACQ,cAAc;AAC/C,IAAIC,eAAe,GAAGT,WAAW,CAACS,eAAe;AACjD,IAAIC,SAAS,GAAGV,WAAW,CAACU,SAAS;AACrC,IAAIC,SAAS,GAAGX,WAAW,CAACW,SAAS;AACrC,IAAIC,UAAU,GAAGT,MAAM,CAACS,UAAU;AAElC,IAAIC,SAAS,GAAGR,GAAG,CAACQ,SAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,oBAAoBA,CAACC,KAAK,EAAE;EACpC,OAAOA,KAAK,CAACC,OAAO,CAAC,eAAe,EAAE,IAAI,CAAC,CAACA,OAAO,CAAC,mBAAmB,EAAE,IAAI,CAAC;AAC/E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACC,OAAO,EAAE;EAC3BA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB,IAAIA,OAAO,CAACC,OAAO,KAAKC,SAAS,EAAE;IAClCF,OAAO,CAACC,OAAO,GAAG,IAAI;EACvB;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACE,MAAM,GAAGH,OAAO,CAACG,MAAM,IAAIrB,WAAW,CAACqB,MAAM;;EAElD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACC,UAAU,GAAGJ,OAAO,CAACI,UAAU,IAAIC,UAAU;;EAElD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACC,OAAO,GAAGN,OAAO,CAACM,OAAO,IAAIN,OAAO,CAACO,YAAY;EACtD,IAAIP,OAAO,CAACO,YAAY,IAAI,OAAOP,OAAO,CAACO,YAAY,KAAK,UAAU,EAAE;IACvE,MAAM,IAAIC,SAAS,CAAC,gEAAgE,CAAC;EACtF,CAAC,MAAM,IAAIR,OAAO,CAACO,YAAY,EAAE;IAChCP,OAAO,CAACO,YAAY,CAAC,SAAS,EAAE,uEAAuE,EAAE,IAAI,CAAC;EAC/G;;EAEA;AACD;AACA;AACA;AACA;AACA;EACC,IAAI,CAACX,oBAAoB,GAAGI,OAAO,CAACJ,oBAAoB,IAAIA,oBAAoB;;EAEhF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACK,OAAO,GAAG,CAAC,CAACD,OAAO,CAACC,OAAO;;EAEhC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACQ,KAAK,GAAG,IAAI,CAACN,MAAM,CAACO,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC,EAAEX,OAAO,CAACS,KAAK,CAAC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,SAAS,CAACa,SAAS,CAACC,eAAe,GAAG,UAAUC,MAAM,EAAEC,QAAQ,EAAE;EACjE,IAAI,CAACxB,eAAe,CAACwB,QAAQ,CAAC,EAAE;IAC/B,MAAM,IAAIP,SAAS,CAAC,oDAAoD,GAAGO,QAAQ,GAAG,iBAAiB,CAAC;EACzG;EACA,IAAIC,YAAY,GAAG,IAAI,CAACb,MAAM,CAACO,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAACF,KAAK,CAAC;EAC/D,IAAIQ,SAAS,GAAG/B,QAAQ,CAACgC,YAAY;EACrC,IAAIC,gBAAgB,GAAGH,YAAY,CAAC,EAAE,CAAC,IAAI,IAAI;EAC/C,IAAI3B,uBAAuB,CAAC0B,QAAQ,CAAC,EAAE;IACtCE,SAAS,GAAG/B,QAAQ,CAACkC,aAAa;IAClCD,gBAAgB,GAAG1B,SAAS,CAAC4B,IAAI;EAClC,CAAC,MAAM,IAAIN,QAAQ,KAAKvB,SAAS,CAAC8B,aAAa,EAAE;IAChDH,gBAAgB,GAAG1B,SAAS,CAAC8B,GAAG;EACjC;EACAP,YAAY,CAAC,EAAE,CAAC,GAAGG,gBAAgB;EACnCH,YAAY,CAACQ,GAAG,GAAGR,YAAY,CAACQ,GAAG,IAAI/B,SAAS,CAACgC,GAAG;EAEpD,IAAIC,UAAU,GAAG,IAAI,IAAI,CAACtB,UAAU,CAAC;IACpCW,QAAQ,EAAEA,QAAQ;IAClBI,gBAAgB,EAAEA,gBAAgB;IAClCb,OAAO,EAAE,IAAI,CAACA;EACf,CAAC,CAAC;EACF,IAAIL,OAAO,GAAG,IAAI,CAACA,OAAO,GAAG,CAAC,CAAC,GAAGC,SAAS;EAC3C,IAAI,IAAI,CAACD,OAAO,EAAE;IACjByB,UAAU,CAACC,kBAAkB,CAAC1B,OAAO,CAAC;EACvC;EAEA,IAAId,GAAG,GAAG,IAAIQ,SAAS,CAAC,CAAC;EACzBR,GAAG,CAACoB,YAAY,GAAGmB,UAAU;EAC7BvC,GAAG,CAACuC,UAAU,GAAGA,UAAU;EAC3B,IAAIE,KAAK,GAAG,CAAC9C,WAAW,CAACQ,cAAc,CAACyB,QAAQ,CAAC;EACjD,IAAIa,KAAK,IAAI,OAAOd,MAAM,KAAK,QAAQ,EAAE;IACxC3B,GAAG,CAACoB,YAAY,CAACsB,UAAU,CAAC,wBAAwB,CAAC;EACtD;EACA1C,GAAG,CAAC2C,KAAK,CAAC,IAAI,CAAClC,oBAAoB,CAACmC,MAAM,CAACjB,MAAM,CAAC,CAAC,EAAEE,YAAY,EAAEC,SAAS,CAAC;EAC7E,IAAI,CAACS,UAAU,CAACM,GAAG,CAACC,eAAe,EAAE;IACpC9C,GAAG,CAACoB,YAAY,CAACsB,UAAU,CAAC,sBAAsB,CAAC;EACpD;EACA,OAAOH,UAAU,CAACM,GAAG;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS3B,UAAUA,CAACL,OAAO,EAAE;EAC5B,IAAIkC,GAAG,GAAGlC,OAAO,IAAI,CAAC,CAAC;EACvB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACe,QAAQ,GAAGmB,GAAG,CAACnB,QAAQ,IAAIvB,SAAS,CAAC2C,eAAe;;EAEzD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAAChB,gBAAgB,GAAGe,GAAG,CAACf,gBAAgB,IAAI,IAAI;;EAEpD;AACD;AACA;AACA;EACC,IAAI,CAACiB,KAAK,GAAG,KAAK;;EAElB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACC,cAAc,GAAGnC,SAAS;;EAE/B;AACD;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAAC8B,GAAG,GAAG9B,SAAS;;EAEpB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACD,OAAO,GAAGC,SAAS;EACxB;AACD;AACA;AACA;EACC,IAAI,CAACI,OAAO,GAAG4B,GAAG,CAAC5B,OAAO;AAC3B;AAEA,SAASgC,QAAQA,CAACrC,OAAO,EAAEsC,IAAI,EAAE;EAChCA,IAAI,CAACC,UAAU,GAAGvC,OAAO,CAACuC,UAAU;EACpCD,IAAI,CAACE,YAAY,GAAGxC,OAAO,CAACwC,YAAY;AACzC;AAEApC,UAAU,CAACO,SAAS,GAAG;EACtB;AACD;AAC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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}