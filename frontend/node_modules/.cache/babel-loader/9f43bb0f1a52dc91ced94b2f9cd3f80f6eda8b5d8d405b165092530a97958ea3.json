{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nvar _require = require(\"./errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = require(\"./doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var _i2 = 0; _i2 < textMatchArray.length; _i2++) {\n    var m = textMatchArray[_i2];\n    allMatches[m] = true;\n  }\n  for (var _i4 = 0; _i4 < othersMatchArray.length; _i4++) {\n    var _m = othersMatchArray[_i4];\n    allMatches[_m] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        if (!syntaxOptions.allowUnclosedTag) {\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterOffset\n          }));\n          lastDelimiterMatch = currDelimiterMatch;\n          delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n            error: true\n          }));\n          return delimiterAcc;\n        }\n      }\n      if (!syntaxOptions.allowUnclosedTag) {\n        errors.push(getUnclosedTagException({\n          xtag: wordToUtf8(xtag),\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      delimiterAcc.pop();\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = position === \"start\";\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    if (!syntaxOptions.allowUnclosedTag) {\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n    } else {\n      delimiterWithErrors.pop();\n    }\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters, syntaxOptions) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  if (start == null && end == null) {\n    // Special case of delimiter set to null/null, no templating is done\n    return [];\n  }\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    /*\n     * If tag starts with =, such as {=[ ]=}\n     * then the delimiters will change right after that tag.\n     *\n     * For example, with the following template :\n     *\n     * Hello {foo}, {=[ ]=}what's up with [name] ?\n     *\n     * The \"foo\" tag is a normal tag, the \"=[ ]=\" is a tag to change the\n     * delimiters to \"[\" and \"]\", and the last \"name\" is a tag with the new\n     * delimiters\n     */\n    if (syntaxOptions.changeDelimiterPrefix && compareResult === DELIMITER_START && fullText[offset + start.length] === syntaxOptions.changeDelimiterPrefix) {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(syntaxOptions.changeDelimiterPrefix, offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters, syntaxOptions);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    for (var _i6 = 0; _i6 < delimitersInOffset.length; _i6++) {\n      var delimiterInOffset = delimitersInOffset[_i6];\n      var _value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (_value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: _value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        continue;\n      }\n      if (_value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: _value\n        });\n        cursor += _value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    }\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  for (var _i8 = 0; _i8 < xmlparsed.length; _i8++) {\n    var part = xmlparsed[_i8];\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  }\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    for (var _i10 = 0; _i10 < xmllexed.length; _i10++) {\n      var part = xmllexed[_i10];\n      if (isInsideContent(part)) {\n        for (var _i12 = 0, _delimiterParsed$inde2 = delimiterParsed[index]; _i12 < _delimiterParsed$inde2.length; _i12++) {\n          var p = _delimiterParsed$inde2[_i12];\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n        }\n        Array.prototype.push.apply(lexed, delimiterParsed[index]);\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    }\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      if (content.length > cursor && match.offset - cursor > 0) {\n        parsed.push({\n          type: \"content\",\n          value: content.substr(cursor, match.offset - cursor)\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    if (content.length > cursor) {\n      parsed.push({\n        type: \"content\",\n        value: content.substr(cursor)\n      });\n    }\n    return parsed;\n  }\n};","map":{"version":3,"names":["_typeof","o","Symbol","iterator","constructor","prototype","_slicedToArray","r","e","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","a","_arrayLikeToArray","t","toString","call","slice","name","Array","from","test","length","n","l","i","u","f","next","Object","done","push","value","isArray","ownKeys","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","enumerable","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","configurable","writable","_toPrimitive","toPrimitive","String","Number","_require","require","getUnclosedTagException","getUnopenedTagException","getDuplicateOpenTagException","getDuplicateCloseTagException","throwMalformedXml","throwXmlInvalid","XTTemplateError","_require2","isTextStart","isTextEnd","wordToUtf8","DELIMITER_NONE","DELIMITER_EQUAL","DELIMITER_START","DELIMITER_END","inRange","range","match","offset","updateInTextTag","part","inTextTag","getTag","tag","position","start","end","indexOf","tagMatcher","content","textMatchArray","othersMatchArray","cursor","contentLength","allMatches","_i2","m","_i4","_m","totalMatches","nextOpening","tagText","_getTag","text","type","getDelimiterErrors","delimiterMatches","fullText","syntaxOptions","errors","inDelimiter","lastDelimiterMatch","xtag","delimiterWithErrors","reduce","delimiterAcc","currDelimiterMatch","delimiterOffset","lastDelimiterOffset","lastDelimiterLength","substr","allowUnclosedTag","error","pop","allowUnopenedTag","compareOffsets","startOffset","endOffset","splitDelimiters","inside","newDelimiters","split","err","properties","id","explanation","_newDelimiters","_err","getAllDelimiterIndexes","delimiters","indexes","insideTag","len","compareResult","changeDelimiterPrefix","changedelimiter","nextEqual","nextEndOffset","_insideTag","_splitDelimiters","_splitDelimiters2","parseDelimiters","innerContentParts","full","map","p","join","ranges","lIndex","_getDelimiterErrors","cutNext","delimiterIndex","parsed","partContent","delimitersInOffset","parts","_i6","delimiterInOffset","_value","delimiterPart","isInsideContent","getContentParts","xmlparsed","decodeContentParts","fileType","_i8","replace","module","exports","parse","xmllexed","syntax","_parseDelimiters","delimiterParsed","lexed","index","_i10","_i12","_delimiterParsed$inde2","xmlparse","xmltags","matches","other"],"sources":["C:/Users/rc_sh/Desktop/Unidad oftalmologica/Clinica_rosmarian_castillo/frontend/node_modules/docxtemplater/js/lexer.js"],"sourcesContent":["\"use strict\";\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = require(\"./errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = require(\"./doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var _i2 = 0; _i2 < textMatchArray.length; _i2++) {\n    var m = textMatchArray[_i2];\n    allMatches[m] = true;\n  }\n  for (var _i4 = 0; _i4 < othersMatchArray.length; _i4++) {\n    var _m = othersMatchArray[_i4];\n    allMatches[_m] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        if (!syntaxOptions.allowUnclosedTag) {\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterOffset\n          }));\n          lastDelimiterMatch = currDelimiterMatch;\n          delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n            error: true\n          }));\n          return delimiterAcc;\n        }\n      }\n      if (!syntaxOptions.allowUnclosedTag) {\n        errors.push(getUnclosedTagException({\n          xtag: wordToUtf8(xtag),\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      delimiterAcc.pop();\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = position === \"start\";\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    if (!syntaxOptions.allowUnclosedTag) {\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n    } else {\n      delimiterWithErrors.pop();\n    }\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters, syntaxOptions) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  if (start == null && end == null) {\n    // Special case of delimiter set to null/null, no templating is done\n    return [];\n  }\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    /*\n     * If tag starts with =, such as {=[ ]=}\n     * then the delimiters will change right after that tag.\n     *\n     * For example, with the following template :\n     *\n     * Hello {foo}, {=[ ]=}what's up with [name] ?\n     *\n     * The \"foo\" tag is a normal tag, the \"=[ ]=\" is a tag to change the\n     * delimiters to \"[\" and \"]\", and the last \"name\" is a tag with the new\n     * delimiters\n     */\n    if (syntaxOptions.changeDelimiterPrefix && compareResult === DELIMITER_START && fullText[offset + start.length] === syntaxOptions.changeDelimiterPrefix) {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(syntaxOptions.changeDelimiterPrefix, offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters, syntaxOptions);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    for (var _i6 = 0; _i6 < delimitersInOffset.length; _i6++) {\n      var delimiterInOffset = delimitersInOffset[_i6];\n      var _value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (_value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: _value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        continue;\n      }\n      if (_value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: _value\n        });\n        cursor += _value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    }\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  for (var _i8 = 0; _i8 < xmlparsed.length; _i8++) {\n    var part = xmlparsed[_i8];\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  }\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    for (var _i10 = 0; _i10 < xmllexed.length; _i10++) {\n      var part = xmllexed[_i10];\n      if (isInsideContent(part)) {\n        for (var _i12 = 0, _delimiterParsed$inde2 = delimiterParsed[index]; _i12 < _delimiterParsed$inde2.length; _i12++) {\n          var p = _delimiterParsed$inde2[_i12];\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n        }\n        Array.prototype.push.apply(lexed, delimiterParsed[index]);\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    }\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      if (content.length > cursor && match.offset - cursor > 0) {\n        parsed.push({\n          type: \"content\",\n          value: content.substr(cursor, match.offset - cursor)\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    if (content.length > cursor) {\n      parsed.push({\n        type: \"content\",\n        value: content.substr(cursor)\n      });\n    }\n    return parsed;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}