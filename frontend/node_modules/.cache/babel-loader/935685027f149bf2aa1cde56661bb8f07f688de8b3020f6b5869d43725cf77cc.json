{"ast":null,"code":"'use strict';\n\nvar conventions = require('./conventions');\nvar find = conventions.find;\nvar hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;\nvar hasOwn = conventions.hasOwn;\nvar isHTMLMimeType = conventions.isHTMLMimeType;\nvar isHTMLRawTextElement = conventions.isHTMLRawTextElement;\nvar isHTMLVoidElement = conventions.isHTMLVoidElement;\nvar MIME_TYPE = conventions.MIME_TYPE;\nvar NAMESPACE = conventions.NAMESPACE;\n\n/**\n * Private DOM Constructor symbol\n *\n * Internal symbol used for construction of all classes whose constructors should be private.\n * Currently used for checks in `Node`, `Document`, `Element`, `Attr`, `CharacterData`, `Text`, `Comment`,\n * `CDATASection`, `DocumentType`, `Notation`, `Entity`, `EntityReference`, `DocumentFragment`, `ProcessingInstruction`\n * so the constructor can't be used from outside the module.\n */\nvar PDC = Symbol();\nvar errors = require('./errors');\nvar DOMException = errors.DOMException;\nvar DOMExceptionName = errors.DOMExceptionName;\nvar g = require('./grammar');\n\n/**\n * Checks if the given symbol equals the Private DOM Constructor symbol (PDC)\n * and throws an Illegal constructor exception when the symbols don't match.\n * This ensures that the constructor remains private and can't be used outside this module.\n */\nfunction checkSymbol(symbol) {\n  if (symbol !== PDC) {\n    throw new TypeError('Illegal constructor');\n  }\n}\n\n/**\n * A prerequisite for `[].filter`, to drop elements that are empty.\n *\n * @param {string} input\n * The string to be checked.\n * @returns {boolean}\n * Returns `true` if the input string is not empty, `false` otherwise.\n */\nfunction notEmptyString(input) {\n  return input !== '';\n}\n/**\n * Splits a string on ASCII whitespace characters (U+0009 TAB, U+000A LF, U+000C FF, U+000D CR,\n * U+0020 SPACE).\n * It follows the definition from the infra specification from WHATWG.\n *\n * @param {string} input\n * The string to be split.\n * @returns {string[]}\n * An array of the split strings. The array can be empty if the input string is empty or only\n * contains whitespace characters.\n * @see {@link https://infra.spec.whatwg.org/#split-on-ascii-whitespace}\n * @see {@link https://infra.spec.whatwg.org/#ascii-whitespace}\n */\nfunction splitOnASCIIWhitespace(input) {\n  // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE\n  return input ? input.split(/[\\t\\n\\f\\r ]+/).filter(notEmptyString) : [];\n}\n\n/**\n * Adds element as a key to current if it is not already present.\n *\n * @param {Record<string, boolean | undefined>} current\n * The current record object to which the element will be added as a key.\n * The object's keys are string types and values are either boolean or undefined.\n * @param {string} element\n * The string to be added as a key to the current record.\n * @returns {Record<string, boolean | undefined>}\n * The updated record object after the addition of the new element.\n */\nfunction orderedSetReducer(current, element) {\n  if (!hasOwn(current, element)) {\n    current[element] = true;\n  }\n  return current;\n}\n\n/**\n * Converts a string into an ordered set by splitting the input on ASCII whitespace and\n * ensuring uniqueness of elements.\n * This follows the definition of an ordered set from the infra specification by WHATWG.\n *\n * @param {string} input\n * The input string to be transformed into an ordered set.\n * @returns {string[]}\n * An array of unique strings obtained from the input, preserving the original order.\n * The array can be empty if the input string is empty or only contains whitespace characters.\n * @see {@link https://infra.spec.whatwg.org/#ordered-set}\n */\nfunction toOrderedSet(input) {\n  if (!input) return [];\n  var list = splitOnASCIIWhitespace(input);\n  return Object.keys(list.reduce(orderedSetReducer, {}));\n}\n\n/**\n * Uses `list.indexOf` to implement a function that behaves like `Array.prototype.includes`.\n * This function is used in environments where `Array.prototype.includes` may not be available.\n *\n * @param {any[]} list\n * The array in which to search for the element.\n * @returns {function(any): boolean}\n * A function that accepts an element and returns a boolean indicating whether the element is\n * included in the provided list.\n */\nfunction arrayIncludes(list) {\n  return function (element) {\n    return list && list.indexOf(element) !== -1;\n  };\n}\n\n/**\n * Validates a qualified name based on the criteria provided in the DOM specification by\n * WHATWG.\n *\n * @param {string} qualifiedName\n * The qualified name to be validated.\n * @throws {DOMException}\n * With code {@link DOMException.INVALID_CHARACTER_ERR} if the qualified name contains an\n * invalid character.\n * @see {@link https://dom.spec.whatwg.org/#validate}\n */\nfunction validateQualifiedName(qualifiedName) {\n  if (!g.QName_exact.test(qualifiedName)) {\n    throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in qualified name \"' + qualifiedName + '\"');\n  }\n}\n\n/**\n * Validates a qualified name and the namespace associated with it,\n * based on the criteria provided in the DOM specification by WHATWG.\n *\n * @param {string | null} namespace\n * The namespace to be validated. It can be a string or null.\n * @param {string} qualifiedName\n * The qualified name to be validated.\n * @returns {[namespace: string | null, prefix: string | null, localName: string]}\n * Returns a tuple with the namespace,\n * prefix and local name of the qualified name.\n * @throws {DOMException}\n * Throws a DOMException if the qualified name or the namespace is not valid.\n * @see {@link https://dom.spec.whatwg.org/#validate-and-extract}\n */\nfunction validateAndExtract(namespace, qualifiedName) {\n  validateQualifiedName(qualifiedName);\n  namespace = namespace || null;\n  /**\n   * @type {string | null}\n   */\n  var prefix = null;\n  var localName = qualifiedName;\n  if (qualifiedName.indexOf(':') >= 0) {\n    var splitResult = qualifiedName.split(':');\n    prefix = splitResult[0];\n    localName = splitResult[1];\n  }\n  if (prefix !== null && namespace === null) {\n    throw new DOMException(DOMException.NAMESPACE_ERR, 'prefix is non-null and namespace is null');\n  }\n  if (prefix === 'xml' && namespace !== conventions.NAMESPACE.XML) {\n    throw new DOMException(DOMException.NAMESPACE_ERR, 'prefix is \"xml\" and namespace is not the XML namespace');\n  }\n  if ((prefix === 'xmlns' || qualifiedName === 'xmlns') && namespace !== conventions.NAMESPACE.XMLNS) {\n    throw new DOMException(DOMException.NAMESPACE_ERR, 'either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace');\n  }\n  if (namespace === conventions.NAMESPACE.XMLNS && prefix !== 'xmlns' && qualifiedName !== 'xmlns') {\n    throw new DOMException(DOMException.NAMESPACE_ERR, 'namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\"');\n  }\n  return [namespace, prefix, localName];\n}\n\n/**\n * Copies properties from one object to another.\n * It only copies the object's own (not inherited) properties.\n *\n * @param {Object} src\n * The source object from which properties are copied.\n * @param {Object} dest\n * The destination object to which properties are copied.\n */\nfunction copy(src, dest) {\n  for (var p in src) {\n    if (hasOwn(src, p)) {\n      dest[p] = src[p];\n    }\n  }\n}\n\n/**\n * Extends a class with the properties and methods of a super class.\n * It uses a form of prototypal inheritance, and establishes the `constructor` property\n * correctly(?).\n *\n * It is not clear to the current maintainers if this implementation is making sense,\n * since it creates an intermediate prototype function,\n * which all properties of `Super` are copied onto using `_copy`.\n *\n * @param {Object} Class\n * The class that is to be extended.\n * @param {Object} Super\n * The super class from which properties and methods are inherited.\n * @private\n */\nfunction _extends(Class, Super) {\n  var pt = Class.prototype;\n  if (!(pt instanceof Super)) {\n    function t() {}\n    t.prototype = Super.prototype;\n    t = new t();\n    copy(pt, t);\n    Class.prototype = pt = t;\n  }\n  if (pt.constructor != Class) {\n    if (typeof Class != 'function') {\n      console.error('unknown Class:' + Class);\n    }\n    pt.constructor = Class;\n  }\n}\nvar NodeType = {};\nvar ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;\nvar ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;\nvar TEXT_NODE = NodeType.TEXT_NODE = 3;\nvar CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;\nvar ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;\nvar ENTITY_NODE = NodeType.ENTITY_NODE = 6;\nvar PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\nvar COMMENT_NODE = NodeType.COMMENT_NODE = 8;\nvar DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;\nvar DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;\nvar DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;\nvar NOTATION_NODE = NodeType.NOTATION_NODE = 12;\nvar DocumentPosition = conventions.freeze({\n  DOCUMENT_POSITION_DISCONNECTED: 1,\n  DOCUMENT_POSITION_PRECEDING: 2,\n  DOCUMENT_POSITION_FOLLOWING: 4,\n  DOCUMENT_POSITION_CONTAINS: 8,\n  DOCUMENT_POSITION_CONTAINED_BY: 16,\n  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32\n});\n\n//helper functions for compareDocumentPosition\n/**\n * Finds the common ancestor in two parent chains.\n *\n * @param {Node[]} a\n * The first parent chain.\n * @param {Node[]} b\n * The second parent chain.\n * @returns {Node}\n * The common ancestor node if it exists. If there is no common ancestor, the function will\n * return `null`.\n */\nfunction commonAncestor(a, b) {\n  if (b.length < a.length) return commonAncestor(b, a);\n  var c = null;\n  for (var n in a) {\n    if (a[n] !== b[n]) return c;\n    c = a[n];\n  }\n  return c;\n}\n\n/**\n * Assigns a unique identifier to a document to ensure consistency while comparing unrelated\n * nodes.\n *\n * @param {Document} doc\n * The document to which a unique identifier is to be assigned.\n * @returns {string}\n * The unique identifier of the document. If the document already had a unique identifier, the\n * function will return the existing one.\n */\nfunction docGUID(doc) {\n  if (!doc.guid) doc.guid = Math.random();\n  return doc.guid;\n}\n//-- end of helper functions\n\n/**\n * The NodeList interface provides the abstraction of an ordered collection of nodes,\n * without defining or constraining how this collection is implemented.\n * NodeList objects in the DOM are live.\n * The items in the NodeList are accessible via an integral index, starting from 0.\n * You can also access the items of the NodeList with a `for...of` loop.\n *\n * @class NodeList\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n * @constructs NodeList\n */\nfunction NodeList() {}\nNodeList.prototype = {\n  /**\n   * The number of nodes in the list. The range of valid child node indices is 0 to length-1\n   * inclusive.\n   *\n   * @type {number}\n   */\n  length: 0,\n  /**\n   * Returns the item at `index`. If index is greater than or equal to the number of nodes in\n   * the list, this returns null.\n   *\n   * @param index\n   * Unsigned long Index into the collection.\n   * @returns {Node | null}\n   * The node at position `index` in the NodeList,\n   * or null if that is not a valid index.\n   */\n  item: function (index) {\n    return index >= 0 && index < this.length ? this[index] : null;\n  },\n  /**\n   * Returns a string representation of the NodeList.\n   *\n   * @param {unknown} nodeFilter\n   * __A filter function? Not implemented according to the spec?__.\n   * @returns {string}\n   * A string representation of the NodeList.\n   */\n  toString: function (nodeFilter) {\n    for (var buf = [], i = 0; i < this.length; i++) {\n      serializeToString(this[i], buf, nodeFilter);\n    }\n    return buf.join('');\n  },\n  /**\n   * Filters the NodeList based on a predicate.\n   *\n   * @param {function(Node): boolean} predicate\n   * - A predicate function to filter the NodeList.\n   * @returns {Node[]}\n   * An array of nodes that satisfy the predicate.\n   * @private\n   */\n  filter: function (predicate) {\n    return Array.prototype.filter.call(this, predicate);\n  },\n  /**\n   * Returns the first index at which a given node can be found in the NodeList, or -1 if it is\n   * not present.\n   *\n   * @param {Node} item\n   * - The Node item to locate in the NodeList.\n   * @returns {number}\n   * The first index of the node in the NodeList; -1 if not found.\n   * @private\n   */\n  indexOf: function (item) {\n    return Array.prototype.indexOf.call(this, item);\n  }\n};\nNodeList.prototype[Symbol.iterator] = function () {\n  var me = this;\n  var index = 0;\n  return {\n    next: function () {\n      if (index < me.length) {\n        return {\n          value: me[index++],\n          done: false\n        };\n      } else {\n        return {\n          done: true\n        };\n      }\n    },\n    return: function () {\n      return {\n        done: true\n      };\n    }\n  };\n};\n\n/**\n * Represents a live collection of nodes that is automatically updated when its associated\n * document changes.\n *\n * @class LiveNodeList\n * @param {Node} node\n * The associated node.\n * @param {function} refresh\n * The function to refresh the live node list.\n * @augments NodeList\n * @constructs LiveNodeList\n */\nfunction LiveNodeList(node, refresh) {\n  this._node = node;\n  this._refresh = refresh;\n  _updateLiveList(this);\n}\n/**\n * Updates the live node list.\n *\n * @param {LiveNodeList} list\n * The live node list to update.\n * @private\n */\nfunction _updateLiveList(list) {\n  var inc = list._node._inc || list._node.ownerDocument._inc;\n  if (list._inc !== inc) {\n    var ls = list._refresh(list._node);\n    __set__(list, 'length', ls.length);\n    if (!list.$$length || ls.length < list.$$length) {\n      for (var i = ls.length; i in list; i++) {\n        if (hasOwn(list, i)) {\n          delete list[i];\n        }\n      }\n    }\n    copy(ls, list);\n    list._inc = inc;\n  }\n}\n/**\n * Returns the node at position `index` in the LiveNodeList, or null if that is not a valid\n * index.\n *\n * @param {number} i\n * Index into the collection.\n * @returns {Node | null}\n * The node at position `index` in the LiveNodeList, or null if that is not a valid index.\n */\nLiveNodeList.prototype.item = function (i) {\n  _updateLiveList(this);\n  return this[i] || null;\n};\n_extends(LiveNodeList, NodeList);\n\n/**\n * Objects implementing the NamedNodeMap interface are used to represent collections of nodes\n * that can be accessed by name.\n * Note that NamedNodeMap does not inherit from NodeList;\n * NamedNodeMaps are not maintained in any particular order.\n * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal\n * index,\n * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,\n * and does not imply that the DOM specifies an order to these Nodes.\n * NamedNodeMap objects in the DOM are live.\n * used for attributes or DocumentType entities\n *\n * This implementation only supports property indices, but does not support named properties,\n * as specified in the living standard.\n *\n * @class NamedNodeMap\n * @see https://dom.spec.whatwg.org/#interface-namednodemap\n * @see https://webidl.spec.whatwg.org/#dfn-supported-property-names\n * @constructs NamedNodeMap\n */\nfunction NamedNodeMap() {}\n/**\n * Returns the index of a node within the list.\n *\n * @param {Array} list\n * The list of nodes.\n * @param {Node} node\n * The node to find.\n * @returns {number}\n * The index of the node within the list, or -1 if not found.\n * @private\n */\nfunction _findNodeIndex(list, node) {\n  var i = 0;\n  while (i < list.length) {\n    if (list[i] === node) {\n      return i;\n    }\n    i++;\n  }\n}\n/**\n * Adds a new attribute to the list and updates the owner element of the attribute.\n *\n * @param {Element} el\n * The element which will become the owner of the new attribute.\n * @param {NamedNodeMap} list\n * The list to which the new attribute will be added.\n * @param {Attr} newAttr\n * The new attribute to be added.\n * @param {Attr} oldAttr\n * The old attribute to be replaced, or null if no attribute is to be replaced.\n * @returns {void}\n * @private\n */\nfunction _addNamedNode(el, list, newAttr, oldAttr) {\n  if (oldAttr) {\n    list[_findNodeIndex(list, oldAttr)] = newAttr;\n  } else {\n    list[list.length] = newAttr;\n    list.length++;\n  }\n  if (el) {\n    newAttr.ownerElement = el;\n    var doc = el.ownerDocument;\n    if (doc) {\n      oldAttr && _onRemoveAttribute(doc, el, oldAttr);\n      _onAddAttribute(doc, el, newAttr);\n    }\n  }\n}\n/**\n * Removes an attribute from the list and updates the owner element of the attribute.\n *\n * @param {Element} el\n * The element which is the current owner of the attribute.\n * @param {NamedNodeMap} list\n * The list from which the attribute will be removed.\n * @param {Attr} attr\n * The attribute to be removed.\n * @returns {void}\n * @private\n */\nfunction _removeNamedNode(el, list, attr) {\n  //console.log('remove attr:'+attr)\n  var i = _findNodeIndex(list, attr);\n  if (i >= 0) {\n    var lastIndex = list.length - 1;\n    while (i <= lastIndex) {\n      list[i] = list[++i];\n    }\n    list.length = lastIndex;\n    if (el) {\n      var doc = el.ownerDocument;\n      if (doc) {\n        _onRemoveAttribute(doc, el, attr);\n      }\n      attr.ownerElement = null;\n    }\n  }\n}\nNamedNodeMap.prototype = {\n  length: 0,\n  item: NodeList.prototype.item,\n  /**\n   * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and\n   * document.\n   *\n   * @param {string} localName\n   * The local name of the attribute.\n   * @returns {Attr | null}\n   * The attribute with the given local name, or null if no such attribute exists.\n   * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name\n   */\n  getNamedItem: function (localName) {\n    if (this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace()) {\n      localName = localName.toLowerCase();\n    }\n    var i = 0;\n    while (i < this.length) {\n      var attr = this[i];\n      if (attr.nodeName === localName) {\n        return attr;\n      }\n      i++;\n    }\n    return null;\n  },\n  /**\n   * Set an attribute.\n   *\n   * @param {Attr} attr\n   * The attribute to set.\n   * @returns {Attr | null}\n   * The old attribute with the same local name and namespace URI as the new one, or null if no\n   * such attribute exists.\n   * @throws {DOMException}\n   * With code:\n   * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another\n   * element.\n   * @see https://dom.spec.whatwg.org/#concept-element-attributes-set\n   */\n  setNamedItem: function (attr) {\n    var el = attr.ownerElement;\n    if (el && el !== this._ownerElement) {\n      throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n    }\n    var oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\n    if (oldAttr === attr) {\n      return attr;\n    }\n    _addNamedNode(this._ownerElement, this, attr, oldAttr);\n    return oldAttr;\n  },\n  /**\n   * Set an attribute, replacing an existing attribute with the same local name and namespace\n   * URI if one exists.\n   *\n   * @param {Attr} attr\n   * The attribute to set.\n   * @returns {Attr | null}\n   * The old attribute with the same local name and namespace URI as the new one, or null if no\n   * such attribute exists.\n   * @throws {DOMException}\n   * Throws a DOMException with the name \"InUseAttributeError\" if the attribute is already an\n   * attribute of another element.\n   * @see https://dom.spec.whatwg.org/#concept-element-attributes-set\n   */\n  setNamedItemNS: function (attr) {\n    return this.setNamedItem(attr);\n  },\n  /**\n   * Removes an attribute specified by the local name.\n   *\n   * @param {string} localName\n   * The local name of the attribute to be removed.\n   * @returns {Attr}\n   * The attribute node that was removed.\n   * @throws {DOMException}\n   * With code:\n   * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.\n   * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem\n   * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name\n   */\n  removeNamedItem: function (localName) {\n    var attr = this.getNamedItem(localName);\n    if (!attr) {\n      throw new DOMException(DOMException.NOT_FOUND_ERR, localName);\n    }\n    _removeNamedNode(this._ownerElement, this, attr);\n    return attr;\n  },\n  /**\n   * Removes an attribute specified by the namespace and local name.\n   *\n   * @param {string | null} namespaceURI\n   * The namespace URI of the attribute to be removed.\n   * @param {string} localName\n   * The local name of the attribute to be removed.\n   * @returns {Attr}\n   * The attribute node that was removed.\n   * @throws {DOMException}\n   * With code:\n   * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local\n   * name is found.\n   * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns\n   * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace\n   */\n  removeNamedItemNS: function (namespaceURI, localName) {\n    var attr = this.getNamedItemNS(namespaceURI, localName);\n    if (!attr) {\n      throw new DOMException(DOMException.NOT_FOUND_ERR, namespaceURI ? namespaceURI + ' : ' + localName : localName);\n    }\n    _removeNamedNode(this._ownerElement, this, attr);\n    return attr;\n  },\n  /**\n   * Get an attribute by namespace and local name.\n   *\n   * @param {string | null} namespaceURI\n   * The namespace URI of the attribute.\n   * @param {string} localName\n   * The local name of the attribute.\n   * @returns {Attr | null}\n   * The attribute with the given namespace URI and local name, or null if no such attribute\n   * exists.\n   * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace\n   */\n  getNamedItemNS: function (namespaceURI, localName) {\n    if (!namespaceURI) {\n      namespaceURI = null;\n    }\n    var i = 0;\n    while (i < this.length) {\n      var node = this[i];\n      if (node.localName === localName && node.namespaceURI === namespaceURI) {\n        return node;\n      }\n      i++;\n    }\n    return null;\n  }\n};\nNamedNodeMap.prototype[Symbol.iterator] = function () {\n  var me = this;\n  var index = 0;\n  return {\n    next: function () {\n      if (index < me.length) {\n        return {\n          value: me[index++],\n          done: false\n        };\n      } else {\n        return {\n          done: true\n        };\n      }\n    },\n    return: function () {\n      return {\n        done: true\n      };\n    }\n  };\n};\n\n/**\n * The DOMImplementation interface provides a number of methods for performing operations that\n * are independent of any particular instance of the document object model.\n *\n * The DOMImplementation interface represents an object providing methods which are not\n * dependent on any particular document.\n * Such an object is returned by the `Document.implementation` property.\n *\n * **The individual methods describe the differences compared to the specs**.\n *\n * @class DOMImplementation\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN\n * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core\n *      (Initial)\n * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core\n * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core\n * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard\n * @constructs DOMImplementation\n */\nfunction DOMImplementation() {}\nDOMImplementation.prototype = {\n  /**\n   * Test if the DOM implementation implements a specific feature and version, as specified in\n   * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.\n   *\n   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given\n   * feature is supported. The different implementations fairly diverged in what kind of\n   * features were reported. The latest version of the spec settled to force this method to\n   * always return true, where the functionality was accurate and in use.\n   *\n   * @deprecated\n   * It is deprecated and modern browsers return true in all cases.\n   * @function DOMImplementation#hasFeature\n   * @param {string} feature\n   * The name of the feature to test.\n   * @param {string} [version]\n   * This is the version number of the feature to test.\n   * @returns {boolean}\n   * Always returns true.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN\n   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core\n   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core\n   */\n  hasFeature: function (feature, version) {\n    return true;\n  },\n  /**\n   * Creates a DOM Document object of the specified type with its document element. Note that\n   * based on the {@link DocumentType}\n   * given to create the document, the implementation may instantiate specialized\n   * {@link Document} objects that support additional features than the \"Core\", such as \"HTML\"\n   * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.\n   * On the other hand, setting the {@link DocumentType} after the document was created makes\n   * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,\n   * such as createHTMLDocument\n   * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},\n   * can be used to obtain specific types of {@link Document} objects.\n   *\n   * __It behaves slightly different from the description in the living standard__:\n   * - There is no interface/class `XMLDocument`, it returns a `Document`\n   * instance (with it's `type` set to `'xml'`).\n   * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n   *\n   * @function DOMImplementation.createDocument\n   * @param {string | null} namespaceURI\n   * The\n   * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}\n   * of the document element to create or null.\n   * @param {string | null} qualifiedName\n   * The\n   * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}\n   * of the document element to be created or null.\n   * @param {DocumentType | null} [doctype=null]\n   * The type of document to be created or null. When doctype is not null, its\n   * {@link Node#ownerDocument} attribute is set to the document being created. Default is\n   * `null`\n   * @returns {Document}\n   * A new {@link Document} object with its document element. If the NamespaceURI,\n   * qualifiedName, and doctype are null, the returned {@link Document} is empty with no\n   * document element.\n   * @throws {DOMException}\n   * With code:\n   *\n   * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name\n   * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.\n   * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a\n   * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI\n   * is different from null, or if the qualifiedName has a prefix that is \"xml\" and the\n   * namespaceURI is different from \"{@link http://www.w3.org/XML/1998/namespace}\"\n   * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},\n   * or if the DOM implementation does not support the \"XML\" feature but a non-null namespace\n   * URI was provided, since namespaces were defined by XML.\n   * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document\n   * or was created from a different implementation.\n   * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature\n   * \"XML\" and the language exposed through the Document does not support XML Namespaces (such\n   * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).\n   * @since DOM Level 2.\n   * @see {@link #createHTMLDocument}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN\n   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM\n   *      Level 3 Core\n   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM\n   *      Level 2 Core (initial)\n   */\n  createDocument: function (namespaceURI, qualifiedName, doctype) {\n    var contentType = MIME_TYPE.XML_APPLICATION;\n    if (namespaceURI === NAMESPACE.HTML) {\n      contentType = MIME_TYPE.XML_XHTML_APPLICATION;\n    } else if (namespaceURI === NAMESPACE.SVG) {\n      contentType = MIME_TYPE.XML_SVG_IMAGE;\n    }\n    var doc = new Document(PDC, {\n      contentType: contentType\n    });\n    doc.implementation = this;\n    doc.childNodes = new NodeList();\n    doc.doctype = doctype || null;\n    if (doctype) {\n      doc.appendChild(doctype);\n    }\n    if (qualifiedName) {\n      var root = doc.createElementNS(namespaceURI, qualifiedName);\n      doc.appendChild(root);\n    }\n    return doc;\n  },\n  /**\n   * Creates an empty DocumentType node. Entity declarations and notations are not made\n   * available. Entity reference expansions and default attribute additions do not occur.\n   *\n   * **This behavior is slightly different from the one in the specs**:\n   * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n   * - `publicId` and `systemId` contain the raw data including any possible quotes,\n   *   so they can always be serialized back to the original value\n   * - `internalSubset` contains the raw string between `[` and `]` if present,\n   *   but is not parsed or validated in any form.\n   *\n   * @function DOMImplementation#createDocumentType\n   * @param {string} qualifiedName\n   * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified\n   * name} of the document type to be created.\n   * @param {string} [publicId]\n   * The external subset public identifier.\n   * @param {string} [systemId]\n   * The external subset system identifier.\n   * @param {string} [internalSubset]\n   * the internal subset or an empty string if it is not present\n   * @returns {DocumentType}\n   * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.\n   * @throws {DOMException}\n   * With code:\n   *\n   * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name\n   * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.\n   * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.\n   * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature\n   * \"XML\" and the language exposed through the Document does not support XML Namespaces (such\n   * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).\n   * @since DOM Level 2.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType\n   *      MDN\n   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living\n   *      Standard\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM\n   *      Level 3 Core\n   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM\n   *      Level 2 Core\n   * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050\n   * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset\n   * @prettierignore\n   */\n  createDocumentType: function (qualifiedName, publicId, systemId, internalSubset) {\n    validateQualifiedName(qualifiedName);\n    var node = new DocumentType(PDC);\n    node.name = qualifiedName;\n    node.nodeName = qualifiedName;\n    node.publicId = publicId || '';\n    node.systemId = systemId || '';\n    node.internalSubset = internalSubset || '';\n    node.childNodes = new NodeList();\n    return node;\n  },\n  /**\n   * Returns an HTML document, that might already have a basic DOM structure.\n   *\n   * __It behaves slightly different from the description in the living standard__:\n   * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are\n   * omitted)\n   * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n   *\n   * @param {string | false} [title]\n   * A string containing the title to give the new HTML document.\n   * @returns {Document}\n   * The HTML document.\n   * @since WHATWG Living Standard.\n   * @see {@link #createDocument}\n   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument\n   * @see https://dom.spec.whatwg.org/#html-document\n   */\n  createHTMLDocument: function (title) {\n    var doc = new Document(PDC, {\n      contentType: MIME_TYPE.HTML\n    });\n    doc.implementation = this;\n    doc.childNodes = new NodeList();\n    if (title !== false) {\n      doc.doctype = this.createDocumentType('html');\n      doc.doctype.ownerDocument = doc;\n      doc.appendChild(doc.doctype);\n      var htmlNode = doc.createElement('html');\n      doc.appendChild(htmlNode);\n      var headNode = doc.createElement('head');\n      htmlNode.appendChild(headNode);\n      if (typeof title === 'string') {\n        var titleNode = doc.createElement('title');\n        titleNode.appendChild(doc.createTextNode(title));\n        headNode.appendChild(titleNode);\n      }\n      htmlNode.appendChild(doc.createElement('body'));\n    }\n    return doc;\n  }\n};\n\n/**\n * The DOM Node interface is an abstract base class upon which many other DOM API objects are\n * based, thus letting those object types to be used similarly and often interchangeably. As an\n * abstract class, there is no such thing as a plain Node object. All objects that implement\n * Node functionality are based on one of its subclasses. Most notable are Document, Element,\n * and DocumentFragment.\n *\n * In addition, every kind of DOM node is represented by an interface based on Node. These\n * include Attr, CharacterData (which Text, Comment, CDATASection and ProcessingInstruction are\n * all based on), and DocumentType.\n *\n * In some cases, a particular feature of the base Node interface may not apply to one of its\n * child interfaces; in that case, the inheriting node may return null or throw an exception,\n * depending on circumstances. For example, attempting to add children to a node type that\n * cannot have children will throw an exception.\n *\n * **This behavior is slightly different from the in the specs**:\n * - unimplemented interfaces: `EventTarget`\n *\n * @class\n * @abstract\n * @param {Symbol} symbol\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n * @see https://dom.spec.whatwg.org/#node\n * @prettierignore\n */\nfunction Node(symbol) {\n  checkSymbol(symbol);\n}\nNode.prototype = {\n  /**\n   * The first child of this node.\n   *\n   * @type {Node | null}\n   */\n  firstChild: null,\n  /**\n   * The last child of this node.\n   *\n   * @type {Node | null}\n   */\n  lastChild: null,\n  /**\n   * The previous sibling of this node.\n   *\n   * @type {Node | null}\n   */\n  previousSibling: null,\n  /**\n   * The next sibling of this node.\n   *\n   * @type {Node | null}\n   */\n  nextSibling: null,\n  /**\n   * The parent node of this node.\n   *\n   * @type {Node | null}\n   */\n  parentNode: null,\n  /**\n   * The parent element of this node.\n   *\n   * @type {Element | null}\n   */\n  get parentElement() {\n    return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;\n  },\n  /**\n   * The child nodes of this node.\n   *\n   * @type {NodeList}\n   */\n  childNodes: null,\n  /**\n   * The document object associated with this node.\n   *\n   * @type {Document | null}\n   */\n  ownerDocument: null,\n  /**\n   * The value of this node.\n   *\n   * @type {string | null}\n   */\n  nodeValue: null,\n  /**\n   * The namespace URI of this node.\n   *\n   * @type {string | null}\n   */\n  namespaceURI: null,\n  /**\n   * The prefix of the namespace for this node.\n   *\n   * @type {string | null}\n   */\n  prefix: null,\n  /**\n   * The local part of the qualified name of this node.\n   *\n   * @type {string | null}\n   */\n  localName: null,\n  /**\n   * The baseURI is currently always `about:blank`,\n   * since that's what happens when you create a document from scratch.\n   *\n   * @type {'about:blank'}\n   */\n  baseURI: 'about:blank',\n  /**\n   * Is true if this node is part of a document.\n   *\n   * @type {boolean}\n   */\n  get isConnected() {\n    var rootNode = this.getRootNode();\n    return rootNode && rootNode.nodeType === rootNode.DOCUMENT_NODE;\n  },\n  /**\n   * Checks whether `other` is an inclusive descendant of this node.\n   *\n   * @param {Node | null | undefined} other\n   * The node to check.\n   * @returns {boolean}\n   * True if `other` is an inclusive descendant of this node; false otherwise.\n   * @see https://dom.spec.whatwg.org/#dom-node-contains\n   */\n  contains: function (other) {\n    if (!other) return false;\n    var parent = other;\n    do {\n      if (this === parent) return true;\n      parent = other.parentNode;\n    } while (parent);\n    return false;\n  },\n  /**\n   * @typedef GetRootNodeOptions\n   * @property {boolean} [composed=false]\n   */\n  /**\n   * Searches for the root node of this node.\n   *\n   * **This behavior is slightly different from the in the specs**:\n   * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.\n   *\n   * @param {GetRootNodeOptions} [options]\n   * @returns {Node}\n   * Root node.\n   * @see https://dom.spec.whatwg.org/#dom-node-getrootnode\n   * @see https://dom.spec.whatwg.org/#concept-shadow-including-root\n   */\n  getRootNode: function (options) {\n    var parent = this;\n    do {\n      if (!parent.parentNode) {\n        return parent;\n      }\n      parent = parent.parentNode;\n    } while (parent);\n  },\n  /**\n   * Checks whether the given node is equal to this node.\n   *\n   * @param {Node} [otherNode]\n   * @see https://dom.spec.whatwg.org/#concept-node-equals\n   */\n  isEqualNode: function (otherNode) {\n    if (!otherNode) return false;\n    if (this.nodeType !== otherNode.nodeType) return false;\n    switch (this.nodeType) {\n      case this.DOCUMENT_TYPE_NODE:\n        if (this.name !== otherNode.name) return false;\n        if (this.publicId !== otherNode.publicId) return false;\n        if (this.systemId !== otherNode.systemId) return false;\n        break;\n      case this.ELEMENT_NODE:\n        if (this.namespaceURI !== otherNode.namespaceURI) return false;\n        if (this.prefix !== otherNode.prefix) return false;\n        if (this.localName !== otherNode.localName) return false;\n        if (this.attributes.length !== otherNode.attributes.length) return false;\n        for (var i = 0; i < this.attributes.length; i++) {\n          var attr = this.attributes.item(i);\n          if (!attr.isEqualNode(otherNode.getAttributeNodeNS(attr.namespaceURI, attr.localName))) {\n            return false;\n          }\n        }\n        break;\n      case this.ATTRIBUTE_NODE:\n        if (this.namespaceURI !== otherNode.namespaceURI) return false;\n        if (this.localName !== otherNode.localName) return false;\n        if (this.value !== otherNode.value) return false;\n        break;\n      case this.PROCESSING_INSTRUCTION_NODE:\n        if (this.target !== otherNode.target || this.data !== otherNode.data) {\n          return false;\n        }\n        break;\n      case this.TEXT_NODE:\n      case this.COMMENT_NODE:\n        if (this.data !== otherNode.data) return false;\n        break;\n    }\n    if (this.childNodes.length !== otherNode.childNodes.length) {\n      return false;\n    }\n    for (var i = 0; i < this.childNodes.length; i++) {\n      if (!this.childNodes[i].isEqualNode(otherNode.childNodes[i])) {\n        return false;\n      }\n    }\n    return true;\n  },\n  /**\n   * Checks whether or not the given node is this node.\n   *\n   * @param {Node} [otherNode]\n   */\n  isSameNode: function (otherNode) {\n    return this === otherNode;\n  },\n  /**\n   * Inserts a node before a reference node as a child of this node.\n   *\n   * @param {Node} newChild\n   * The new child node to be inserted.\n   * @param {Node | null} refChild\n   * The reference node before which newChild will be inserted.\n   * @returns {Node}\n   * The new child node successfully inserted.\n   * @throws {DOMException}\n   * Throws a DOMException if inserting the node would result in a DOM tree that is not\n   * well-formed, or if `child` is provided but is not a child of `parent`.\n   * See {@link _insertBefore} for more details.\n   * @since Modified in DOM L2\n   */\n  insertBefore: function (newChild, refChild) {\n    return _insertBefore(this, newChild, refChild);\n  },\n  /**\n   * Replaces an old child node with a new child node within this node.\n   *\n   * @param {Node} newChild\n   * The new node that is to replace the old node.\n   * If it already exists in the DOM, it is removed from its original position.\n   * @param {Node} oldChild\n   * The existing child node to be replaced.\n   * @returns {Node}\n   * Returns the replaced child node.\n   * @throws {DOMException}\n   * Throws a DOMException if replacing the node would result in a DOM tree that is not\n   * well-formed, or if `oldChild` is not a child of `this`.\n   * This can also occur if the pre-replacement validity assertion fails.\n   * See {@link _insertBefore}, {@link Node.removeChild}, and\n   * {@link assertPreReplacementValidityInDocument} for more details.\n   * @see https://dom.spec.whatwg.org/#concept-node-replace\n   */\n  replaceChild: function (newChild, oldChild) {\n    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n    if (oldChild) {\n      this.removeChild(oldChild);\n    }\n  },\n  /**\n   * Removes an existing child node from this node.\n   *\n   * @param {Node} oldChild\n   * The child node to be removed.\n   * @returns {Node}\n   * Returns the removed child node.\n   * @throws {DOMException}\n   * Throws a DOMException if `oldChild` is not a child of `this`.\n   * See {@link _removeChild} for more details.\n   */\n  removeChild: function (oldChild) {\n    return _removeChild(this, oldChild);\n  },\n  /**\n   * Appends a child node to this node.\n   *\n   * @param {Node} newChild\n   * The child node to be appended to this node.\n   * If it already exists in the DOM, it is removed from its original position.\n   * @returns {Node}\n   * Returns the appended child node.\n   * @throws {DOMException}\n   * Throws a DOMException if appending the node would result in a DOM tree that is not\n   * well-formed, or if `newChild` is not a valid Node.\n   * See {@link insertBefore} for more details.\n   */\n  appendChild: function (newChild) {\n    return this.insertBefore(newChild, null);\n  },\n  /**\n   * Determines whether this node has any child nodes.\n   *\n   * @returns {boolean}\n   * Returns true if this node has any child nodes, and false otherwise.\n   */\n  hasChildNodes: function () {\n    return this.firstChild != null;\n  },\n  /**\n   * Creates a copy of the calling node.\n   *\n   * @param {boolean} deep\n   * If true, the contents of the node are recursively copied.\n   * If false, only the node itself (and its attributes, if it is an element) are copied.\n   * @returns {Node}\n   * Returns the newly created copy of the node.\n   * @throws {DOMException}\n   * May throw a DOMException if operations within {@link Element#setAttributeNode} or\n   * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their\n   * specific constraints.\n   * @see {@link cloneNode}\n   */\n  cloneNode: function (deep) {\n    return cloneNode(this.ownerDocument || this, this, deep);\n  },\n  /**\n   * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\n   * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\n   *\n   * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`\n   * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text\n   * nodes.\n   *\n   * This method operates recursively, so it also normalizes any and all descendent nodes within\n   * the subtree.\n   *\n   * @throws {DOMException}\n   * May throw a DOMException if operations within removeChild or appendData (which are\n   * potentially invoked in this method) do not meet their specific constraints.\n   * @since Modified in DOM Level 2\n   * @see {@link Node.removeChild}\n   * @see {@link CharacterData.appendData}\n   */\n  normalize: function () {\n    var child = this.firstChild;\n    while (child) {\n      var next = child.nextSibling;\n      if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\n        this.removeChild(next);\n        child.appendData(next.data);\n      } else {\n        child.normalize();\n        child = next;\n      }\n    }\n  },\n  /**\n   * Checks whether the DOM implementation implements a specific feature and its version.\n   *\n   * @deprecated\n   * Since `DOMImplementation.hasFeature` is deprecated and always returns true.\n   * @param {string} feature\n   * The package name of the feature to test. This is the same name that can be passed to the\n   * method `hasFeature` on `DOMImplementation`.\n   * @param {string} version\n   * This is the version number of the package name to test.\n   * @returns {boolean}\n   * Returns true in all cases in the current implementation.\n   * @since Introduced in DOM Level 2\n   * @see {@link DOMImplementation.hasFeature}\n   */\n  isSupported: function (feature, version) {\n    return this.ownerDocument.implementation.hasFeature(feature, version);\n  },\n  /**\n   * Look up the prefix associated to the given namespace URI, starting from this node.\n   * **The default namespace declarations are ignored by this method.**\n   * See Namespace Prefix Lookup for details on the algorithm used by this method.\n   *\n   * **This behavior is different from the in the specs**:\n   * - no node type specific handling\n   * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes\n   *\n   * @param {string | null} namespaceURI\n   * The namespace URI for which to find the associated prefix.\n   * @returns {string | null}\n   * The associated prefix, if found; otherwise, null.\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo\n   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix\n   * @see https://github.com/xmldom/xmldom/issues/322\n   * @prettierignore\n   */\n  lookupPrefix: function (namespaceURI) {\n    var el = this;\n    while (el) {\n      var map = el._nsMap;\n      //console.dir(map)\n      if (map) {\n        for (var n in map) {\n          if (hasOwn(map, n) && map[n] === namespaceURI) {\n            return n;\n          }\n        }\n      }\n      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n    }\n    return null;\n  },\n  /**\n   * This function is used to look up the namespace URI associated with the given prefix,\n   * starting from this node.\n   *\n   * **This behavior is different from the in the specs**:\n   * - no node type specific handling\n   * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes\n   *\n   * @param {string | null} prefix\n   * The prefix for which to find the associated namespace URI.\n   * @returns {string | null}\n   * The associated namespace URI, if found; otherwise, null.\n   * @since DOM Level 3\n   * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI\n   * @prettierignore\n   */\n  lookupNamespaceURI: function (prefix) {\n    var el = this;\n    while (el) {\n      var map = el._nsMap;\n      //console.dir(map)\n      if (map) {\n        if (hasOwn(map, prefix)) {\n          return map[prefix];\n        }\n      }\n      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n    }\n    return null;\n  },\n  /**\n   * Determines whether the given namespace URI is the default namespace.\n   *\n   * The function works by looking up the prefix associated with the given namespace URI. If no\n   * prefix is found (i.e., the namespace URI is not registered in the namespace map of this\n   * node or any of its ancestors), it returns `true`, implying the namespace URI is considered\n   * the default.\n   *\n   * **This behavior is different from the in the specs**:\n   * - no node type specific handling\n   * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes\n   *\n   * @param {string | null} namespaceURI\n   * The namespace URI to be checked.\n   * @returns {boolean}\n   * Returns true if the given namespace URI is the default namespace, false otherwise.\n   * @since DOM Level 3\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace\n   * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace\n   * @prettierignore\n   */\n  isDefaultNamespace: function (namespaceURI) {\n    var prefix = this.lookupPrefix(namespaceURI);\n    return prefix == null;\n  },\n  /**\n   * Compares the reference node with a node with regard to their position in the document and\n   * according to the document order.\n   *\n   * @param {Node} other\n   * The node to compare the reference node to.\n   * @returns {number}\n   * Returns how the node is positioned relatively to the reference node according to the\n   * bitmask. 0 if reference node and given node are the same.\n   * @since DOM Level 3\n   * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare\n   * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n   */\n  compareDocumentPosition: function (other) {\n    if (this === other) return 0;\n    var node1 = other;\n    var node2 = this;\n    var attr1 = null;\n    var attr2 = null;\n    if (node1 instanceof Attr) {\n      attr1 = node1;\n      node1 = attr1.ownerElement;\n    }\n    if (node2 instanceof Attr) {\n      attr2 = node2;\n      node2 = attr2.ownerElement;\n      if (attr1 && node1 && node2 === node1) {\n        for (var i = 0, attr; attr = node2.attributes[i]; i++) {\n          if (attr === attr1) return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n          if (attr === attr2) return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n        }\n      }\n    }\n    if (!node1 || !node2 || node2.ownerDocument !== node1.ownerDocument) {\n      return DocumentPosition.DOCUMENT_POSITION_DISCONNECTED + DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (docGUID(node2.ownerDocument) > docGUID(node1.ownerDocument) ? DocumentPosition.DOCUMENT_POSITION_FOLLOWING : DocumentPosition.DOCUMENT_POSITION_PRECEDING);\n    }\n    if (attr2 && node1 === node2) {\n      return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n    }\n    if (attr1 && node1 === node2) {\n      return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n    }\n    var chain1 = [];\n    var ancestor1 = node1.parentNode;\n    while (ancestor1) {\n      if (!attr2 && ancestor1 === node2) {\n        return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n      }\n      chain1.push(ancestor1);\n      ancestor1 = ancestor1.parentNode;\n    }\n    chain1.reverse();\n    var chain2 = [];\n    var ancestor2 = node2.parentNode;\n    while (ancestor2) {\n      if (!attr1 && ancestor2 === node1) {\n        return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n      }\n      chain2.push(ancestor2);\n      ancestor2 = ancestor2.parentNode;\n    }\n    chain2.reverse();\n    var ca = commonAncestor(chain1, chain2);\n    for (var n in ca.childNodes) {\n      var child = ca.childNodes[n];\n      if (child === node2) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n      if (child === node1) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n      if (chain2.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n      if (chain1.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n    }\n    return 0;\n  }\n};\n\n/**\n * Encodes special XML characters to their corresponding entities.\n *\n * @param {string} c\n * The character to be encoded.\n * @returns {string}\n * The encoded character.\n * @private\n */\nfunction _xmlEncoder(c) {\n  return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '\"' && '&quot;' || '&#' + c.charCodeAt() + ';';\n}\ncopy(NodeType, Node);\ncopy(NodeType, Node.prototype);\ncopy(DocumentPosition, Node);\ncopy(DocumentPosition, Node.prototype);\n\n/**\n * @param callback\n * Return true for continue,false for break.\n * @returns\n * boolean true: break visit;\n */\nfunction _visitNode(node, callback) {\n  if (callback(node)) {\n    return true;\n  }\n  if (node = node.firstChild) {\n    do {\n      if (_visitNode(node, callback)) {\n        return true;\n      }\n    } while (node = node.nextSibling);\n  }\n}\n\n/**\n * @typedef DocumentOptions\n * @property {string} [contentType=MIME_TYPE.XML_APPLICATION]\n */\n/**\n * The Document interface describes the common properties and methods for any kind of document.\n *\n * It should usually be created using `new DOMImplementation().createDocument(...)`\n * or `new DOMImplementation().createHTMLDocument(...)`.\n *\n * The constructor is considered a private API and offers to initially set the `contentType`\n * property via it's options parameter.\n *\n * @class\n * @param {Symbol} symbol\n * @param {DocumentOptions} [options]\n * @augments Node\n * @private\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document\n * @see https://dom.spec.whatwg.org/#interface-document\n */\nfunction Document(symbol, options) {\n  checkSymbol(symbol);\n  var opt = options || {};\n  this.ownerDocument = this;\n  /**\n   * The mime type of the document is determined at creation time and can not be modified.\n   *\n   * @type {string}\n   * @see https://dom.spec.whatwg.org/#concept-document-content-type\n   * @see {@link DOMImplementation}\n   * @see {@link MIME_TYPE}\n   * @readonly\n   */\n  this.contentType = opt.contentType || MIME_TYPE.XML_APPLICATION;\n  /**\n   * @type {'html' | 'xml'}\n   * @see https://dom.spec.whatwg.org/#concept-document-type\n   * @see {@link DOMImplementation}\n   * @readonly\n   */\n  this.type = isHTMLMimeType(this.contentType) ? 'html' : 'xml';\n}\n\n/**\n * Updates the namespace mapping of an element when a new attribute is added.\n *\n * @param {Document} doc\n * The document that the element belongs to.\n * @param {Element} el\n * The element to which the attribute is being added.\n * @param {Attr} newAttr\n * The new attribute being added.\n * @private\n */\nfunction _onAddAttribute(doc, el, newAttr) {\n  doc && doc._inc++;\n  var ns = newAttr.namespaceURI;\n  if (ns === NAMESPACE.XMLNS) {\n    //update namespace\n    el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\n  }\n}\n\n/**\n * Updates the namespace mapping of an element when an attribute is removed.\n *\n * @param {Document} doc\n * The document that the element belongs to.\n * @param {Element} el\n * The element from which the attribute is being removed.\n * @param {Attr} newAttr\n * The attribute being removed.\n * @param {boolean} remove\n * Indicates whether the attribute is to be removed.\n * @private\n */\nfunction _onRemoveAttribute(doc, el, newAttr, remove) {\n  doc && doc._inc++;\n  var ns = newAttr.namespaceURI;\n  if (ns === NAMESPACE.XMLNS) {\n    //update namespace\n    delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\n  }\n}\n\n/**\n * Updates `parent.childNodes`, adjusting the indexed items and its `length`.\n * If `newChild` is provided and has no nextSibling, it will be appended.\n * Otherwise, it's assumed that an item has been removed or inserted,\n * and `parent.firstNode` and its `.nextSibling` to re-indexing all child nodes of `parent`.\n *\n * @param {Document} doc\n * The parent document of `el`.\n * @param {Node} parent\n * The parent node whose childNodes list needs to be updated.\n * @param {Node} [newChild]\n * The new child node to be appended. If not provided, the function assumes a node has been\n * removed.\n * @private\n */\nfunction _onUpdateChild(doc, parent, newChild) {\n  if (doc && doc._inc) {\n    doc._inc++;\n    var childNodes = parent.childNodes;\n    // assumes nextSibling and previousSibling were already configured upfront\n    if (newChild && !newChild.nextSibling) {\n      // if an item has been appended, we only need to update the last index and the length\n      childNodes[childNodes.length++] = newChild;\n    } else {\n      // otherwise we need to reindex all items,\n      // which can take a while when processing nodes with a lot of children\n      var child = parent.firstChild;\n      var i = 0;\n      while (child) {\n        childNodes[i++] = child;\n        child = child.nextSibling;\n      }\n      childNodes.length = i;\n      delete childNodes[childNodes.length];\n    }\n  }\n}\n\n/**\n * Removes the connections between `parentNode` and `child`\n * and any existing `child.previousSibling` or `child.nextSibling`.\n *\n * @param {Node} parentNode\n * The parent node from which the child node is to be removed.\n * @param {Node} child\n * The child node to be removed from the parentNode.\n * @returns {Node}\n * Returns the child node that was removed.\n * @throws {DOMException}\n * With code:\n * - {@link DOMException.NOT_FOUND_ERR} If the parentNode is not the parent of the child node.\n * @private\n * @see https://github.com/xmldom/xmldom/issues/135\n * @see https://github.com/xmldom/xmldom/issues/145\n */\nfunction _removeChild(parentNode, child) {\n  if (parentNode !== child.parentNode) {\n    throw new DOMException(DOMException.NOT_FOUND_ERR, \"child's parent is not parent\");\n  }\n  var oldPreviousSibling = child.previousSibling;\n  var oldNextSibling = child.nextSibling;\n  if (oldPreviousSibling) {\n    oldPreviousSibling.nextSibling = oldNextSibling;\n  } else {\n    parentNode.firstChild = oldNextSibling;\n  }\n  if (oldNextSibling) {\n    oldNextSibling.previousSibling = oldPreviousSibling;\n  } else {\n    parentNode.lastChild = oldPreviousSibling;\n  }\n  _onUpdateChild(parentNode.ownerDocument, parentNode);\n  child.parentNode = null;\n  child.previousSibling = null;\n  child.nextSibling = null;\n  return child;\n}\n\n/**\n * Returns `true` if `node` can be a parent for insertion.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction hasValidParentNodeType(node) {\n  return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);\n}\n\n/**\n * Returns `true` if `node` can be inserted according to it's `nodeType`.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction hasInsertableNodeType(node) {\n  return node && (node.nodeType === Node.CDATA_SECTION_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_TYPE_NODE || node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE || node.nodeType === Node.TEXT_NODE);\n}\n\n/**\n * Returns true if `node` is a DOCTYPE node.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isDocTypeNode(node) {\n  return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;\n}\n\n/**\n * Returns true if the node is an element.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isElementNode(node) {\n  return node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Returns true if `node` is a text node.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isTextNode(node) {\n  return node && node.nodeType === Node.TEXT_NODE;\n}\n\n/**\n * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n * according to the presence and position of a doctype node on the same level.\n *\n * @param {Document} doc\n * The document node.\n * @param {Node} child\n * The node that would become the nextSibling if the element would be inserted.\n * @returns {boolean}\n * `true` if an element can be inserted before child.\n * @private\n */\nfunction isElementInsertionPossible(doc, child) {\n  var parentChildNodes = doc.childNodes || [];\n  if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {\n    return false;\n  }\n  var docTypeNode = find(parentChildNodes, isDocTypeNode);\n  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n}\n\n/**\n * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n * according to the presence and position of a doctype node on the same level.\n *\n * @param {Node} doc\n * The document node.\n * @param {Node} child\n * The node that would become the nextSibling if the element would be inserted.\n * @returns {boolean}\n * `true` if an element can be inserted before child.\n * @private\n */\nfunction isElementReplacementPossible(doc, child) {\n  var parentChildNodes = doc.childNodes || [];\n  function hasElementChildThatIsNotChild(node) {\n    return isElementNode(node) && node !== child;\n  }\n  if (find(parentChildNodes, hasElementChildThatIsNotChild)) {\n    return false;\n  }\n  var docTypeNode = find(parentChildNodes, isDocTypeNode);\n  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n}\n\n/**\n * Asserts pre-insertion validity of a node into a parent before a child.\n * Throws errors for invalid node combinations that would result in an ill-formed DOM.\n *\n * @param {Node} parent\n * The parent node to insert `node` into.\n * @param {Node} node\n * The node to insert.\n * @param {Node | null} child\n * The node that should become the `nextSibling` of `node`. If null, no sibling is considered.\n * @throws {DOMException}\n * With code:\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `parent` is not a Document,\n * DocumentFragment, or Element node.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a host-including inclusive\n * ancestor of `parent`. (Currently not implemented)\n * - {@link DOMException.NOT_FOUND_ERR} If `child` is non-null and its `parent` is not\n * `parent`.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is not a DocumentFragment,\n * DocumentType, Element, or CharacterData node.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If either `node` is a Text node and `parent` is\n * a document, or if `node` is a doctype and `parent` is not a document.\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreInsertionValidity1to5(parent, node, child) {\n  // 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a \"HierarchyRequestError\" DOMException.\n  if (!hasValidParentNodeType(parent)) {\n    throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);\n  }\n  // 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a \"HierarchyRequestError\" DOMException.\n  // not implemented!\n  // 3. If `child` is non-null and its parent is not `parent`, then throw a \"NotFoundError\" DOMException.\n  if (child && child.parentNode !== parent) {\n    throw new DOMException(DOMException.NOT_FOUND_ERR, 'child not in parent');\n  }\n  if (\n  // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a \"HierarchyRequestError\" DOMException.\n  !hasInsertableNodeType(node) ||\n  // 5. If either `node` is a Text node and `parent` is a document,\n  // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0\n  // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)\n  // or `node` is a doctype and `parent` is not a document, then throw a \"HierarchyRequestError\" DOMException.\n  isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {\n    throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType);\n  }\n}\n\n/**\n * Asserts pre-insertion validity of a node into a document before a child.\n * Throws errors for invalid node combinations that would result in an ill-formed DOM.\n *\n * @param {Document} parent\n * The parent node to insert `node` into.\n * @param {Node} node\n * The node to insert.\n * @param {Node | undefined} child\n * The node that should become the `nextSibling` of `node`. If undefined, no sibling is\n * considered.\n * @returns {Node}\n * @throws {DOMException}\n * With code:\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with more than\n * one element child or has a Text node child.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with one\n * element child and either `parent` has an element child, `child` is a doctype, or `child` is\n * non-null and a doctype is following `child`.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is an Element and `parent` has an\n * element child, `child` is a doctype, or `child` is non-null and a doctype is following\n * `child`.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentType and `parent` has a\n * doctype child, `child` is non-null and an element is preceding `child`, or `child` is null\n * and `parent` has an element child.\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreInsertionValidityInDocument(parent, node, child) {\n  var parentChildNodes = parent.childNodes || [];\n  var nodeChildNodes = node.childNodes || [];\n\n  // DocumentFragment\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    var nodeChildElements = nodeChildNodes.filter(isElementNode);\n    // If node has more than one element child or has a Text node child.\n    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n    }\n    // Otherwise, if `node` has one element child and either `parent` has an element child,\n    // `child` is a doctype, or `child` is non-null and a doctype is following `child`.\n    if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n    }\n  }\n  // Element\n  if (isElementNode(node)) {\n    // `parent` has an element child, `child` is a doctype,\n    // or `child` is non-null and a doctype is following `child`.\n    if (!isElementInsertionPossible(parent, child)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n    }\n  }\n  // DocumentType\n  if (isDocTypeNode(node)) {\n    // `parent` has a doctype child,\n    if (find(parentChildNodes, isDocTypeNode)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n    }\n    var parentElementChild = find(parentChildNodes, isElementNode);\n    // `child` is non-null and an element is preceding `child`,\n    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n    }\n    // or `child` is null and `parent` has an element child.\n    if (!child && parentElementChild) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');\n    }\n  }\n}\n\n/**\n * @param {Document} parent\n * The parent node to insert `node` into.\n * @param {Node} node\n * The node to insert.\n * @param {Node | undefined} child\n * the node that should become the `nextSibling` of `node`\n * @returns {Node}\n * @throws {DOMException}\n * For several node combinations that would create a DOM that is not well-formed.\n * @throws {DOMException}\n * If `child` is provided but is not a child of `parent`.\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreReplacementValidityInDocument(parent, node, child) {\n  var parentChildNodes = parent.childNodes || [];\n  var nodeChildNodes = node.childNodes || [];\n\n  // DocumentFragment\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    var nodeChildElements = nodeChildNodes.filter(isElementNode);\n    // If `node` has more than one element child or has a Text node child.\n    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n    }\n    // Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.\n    if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n    }\n  }\n  // Element\n  if (isElementNode(node)) {\n    // `parent` has an element child that is not `child` or a doctype is following `child`.\n    if (!isElementReplacementPossible(parent, child)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n    }\n  }\n  // DocumentType\n  if (isDocTypeNode(node)) {\n    function hasDoctypeChildThatIsNotChild(node) {\n      return isDocTypeNode(node) && node !== child;\n    }\n\n    // `parent` has a doctype child that is not `child`,\n    if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n    }\n    var parentElementChild = find(parentChildNodes, isElementNode);\n    // or an element is preceding `child`.\n    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n      throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n    }\n  }\n}\n\n/**\n * Inserts a node into a parent node before a child node.\n *\n * @param {Node} parent\n * The parent node to insert the node into.\n * @param {Node} node\n * The node to insert into the parent.\n * @param {Node | null} child\n * The node that should become the next sibling of the node.\n * If null, the function inserts the node at the end of the children of the parent node.\n * @param {Function} [_inDocumentAssertion]\n * An optional function to check pre-insertion validity if parent is a document node.\n * Defaults to {@link assertPreInsertionValidityInDocument}\n * @returns {Node}\n * Returns the inserted node.\n * @throws {DOMException}\n * Throws a DOMException if inserting the node would result in a DOM tree that is not\n * well-formed. See {@link assertPreInsertionValidity1to5},\n * {@link assertPreInsertionValidityInDocument}.\n * @throws {DOMException}\n * Throws a DOMException if child is provided but is not a child of the parent. See\n * {@link Node.removeChild}\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n */\nfunction _insertBefore(parent, node, child, _inDocumentAssertion) {\n  // To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n  assertPreInsertionValidity1to5(parent, node, child);\n\n  // If parent is a document, and any of the statements below, switched on the interface node implements,\n  // are true, then throw a \"HierarchyRequestError\" DOMException.\n  if (parent.nodeType === Node.DOCUMENT_NODE) {\n    (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);\n  }\n  var cp = node.parentNode;\n  if (cp) {\n    cp.removeChild(node); //remove and update\n  }\n  if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n    var newFirst = node.firstChild;\n    if (newFirst == null) {\n      return node;\n    }\n    var newLast = node.lastChild;\n  } else {\n    newFirst = newLast = node;\n  }\n  var pre = child ? child.previousSibling : parent.lastChild;\n  newFirst.previousSibling = pre;\n  newLast.nextSibling = child;\n  if (pre) {\n    pre.nextSibling = newFirst;\n  } else {\n    parent.firstChild = newFirst;\n  }\n  if (child == null) {\n    parent.lastChild = newLast;\n  } else {\n    child.previousSibling = newLast;\n  }\n  do {\n    newFirst.parentNode = parent;\n  } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\n  _onUpdateChild(parent.ownerDocument || parent, parent, node);\n  if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {\n    node.firstChild = node.lastChild = null;\n  }\n  return node;\n}\nDocument.prototype = {\n  /**\n   * The implementation that created this document.\n   *\n   * @type DOMImplementation\n   * @readonly\n   */\n  implementation: null,\n  nodeName: '#document',\n  nodeType: DOCUMENT_NODE,\n  /**\n   * The DocumentType node of the document.\n   *\n   * @type DocumentType\n   * @readonly\n   */\n  doctype: null,\n  documentElement: null,\n  _inc: 1,\n  insertBefore: function (newChild, refChild) {\n    //raises\n    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      var child = newChild.firstChild;\n      while (child) {\n        var next = child.nextSibling;\n        this.insertBefore(child, refChild);\n        child = next;\n      }\n      return newChild;\n    }\n    _insertBefore(this, newChild, refChild);\n    newChild.ownerDocument = this;\n    if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {\n      this.documentElement = newChild;\n    }\n    return newChild;\n  },\n  removeChild: function (oldChild) {\n    var removed = _removeChild(this, oldChild);\n    if (removed === this.documentElement) {\n      this.documentElement = null;\n    }\n    return removed;\n  },\n  replaceChild: function (newChild, oldChild) {\n    //raises\n    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n    newChild.ownerDocument = this;\n    if (oldChild) {\n      this.removeChild(oldChild);\n    }\n    if (isElementNode(newChild)) {\n      this.documentElement = newChild;\n    }\n  },\n  // Introduced in DOM Level 2:\n  importNode: function (importedNode, deep) {\n    return importNode(this, importedNode, deep);\n  },\n  // Introduced in DOM Level 2:\n  getElementById: function (id) {\n    var rtv = null;\n    _visitNode(this.documentElement, function (node) {\n      if (node.nodeType == ELEMENT_NODE) {\n        if (node.getAttribute('id') == id) {\n          rtv = node;\n          return true;\n        }\n      }\n    });\n    return rtv;\n  },\n  /**\n   * Creates a new `Element` that is owned by this `Document`.\n   * In HTML Documents `localName` is the lower cased `tagName`,\n   * otherwise no transformation is being applied.\n   * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.\n   *\n   * __This implementation differs from the specification:__ - The provided name is not checked\n   * against the `Name` production,\n   * so no related error will be thrown.\n   * - There is no interface `HTMLElement`, it is always an `Element`.\n   * - There is no support for a second argument to indicate using custom elements.\n   *\n   * @param {string} tagName\n   * @returns {Element}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\n   * @see https://dom.spec.whatwg.org/#dom-document-createelement\n   * @see https://dom.spec.whatwg.org/#concept-create-element\n   */\n  createElement: function (tagName) {\n    var node = new Element(PDC);\n    node.ownerDocument = this;\n    if (this.type === 'html') {\n      tagName = tagName.toLowerCase();\n    }\n    if (hasDefaultHTMLNamespace(this.contentType)) {\n      node.namespaceURI = NAMESPACE.HTML;\n    }\n    node.nodeName = tagName;\n    node.tagName = tagName;\n    node.localName = tagName;\n    node.childNodes = new NodeList();\n    var attrs = node.attributes = new NamedNodeMap();\n    attrs._ownerElement = node;\n    return node;\n  },\n  /**\n   * @returns {DocumentFragment}\n   */\n  createDocumentFragment: function () {\n    var node = new DocumentFragment(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    return node;\n  },\n  /**\n   * @param {string} data\n   * @returns {Text}\n   */\n  createTextNode: function (data) {\n    var node = new Text(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    node.appendData(data);\n    return node;\n  },\n  /**\n   * @param {string} data\n   * @returns {Comment}\n   */\n  createComment: function (data) {\n    var node = new Comment(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    node.appendData(data);\n    return node;\n  },\n  /**\n   * @param {string} data\n   * @returns {CDATASection}\n   */\n  createCDATASection: function (data) {\n    var node = new CDATASection(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    node.appendData(data);\n    return node;\n  },\n  /**\n   * @param {string} target\n   * @param {string} data\n   * @returns {ProcessingInstruction}\n   */\n  createProcessingInstruction: function (target, data) {\n    var node = new ProcessingInstruction(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    node.nodeName = node.target = target;\n    node.nodeValue = node.data = data;\n    return node;\n  },\n  /**\n   * Creates an `Attr` node that is owned by this document.\n   * In HTML Documents `localName` is the lower cased `name`,\n   * otherwise no transformation is being applied.\n   *\n   * __This implementation differs from the specification:__ - The provided name is not checked\n   * against the `Name` production,\n   * so no related error will be thrown.\n   *\n   * @param {string} name\n   * @returns {Attr}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute\n   * @see https://dom.spec.whatwg.org/#dom-document-createattribute\n   */\n  createAttribute: function (name) {\n    if (!g.QName_exact.test(name)) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in name \"' + name + '\"');\n    }\n    if (this.type === 'html') {\n      name = name.toLowerCase();\n    }\n    return this._createAttribute(name);\n  },\n  _createAttribute: function (name) {\n    var node = new Attr(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    node.name = name;\n    node.nodeName = name;\n    node.localName = name;\n    node.specified = true;\n    return node;\n  },\n  /**\n   * Creates an EntityReference object.\n   * The current implementation does not fill the `childNodes` with those of the corresponding\n   * `Entity`\n   *\n   * @deprecated\n   * In DOM Level 4.\n   * @param {string} name\n   * The name of the entity to reference. No namespace well-formedness checks are performed.\n   * @returns {EntityReference}\n   * @throws {DOMException}\n   * With code `INVALID_CHARACTER_ERR` when `name` is not valid.\n   * @throws {DOMException}\n   * with code `NOT_SUPPORTED_ERR` when the document is of type `html`\n   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE\n   */\n  createEntityReference: function (name) {\n    if (!g.Name.test(name)) {\n      throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'not a valid xml name \"' + name + '\"');\n    }\n    if (this.type === 'html') {\n      throw new DOMException('document is an html document', DOMExceptionName.NotSupportedError);\n    }\n    var node = new EntityReference(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    node.nodeName = name;\n    return node;\n  },\n  // Introduced in DOM Level 2:\n  /**\n   * @param {string} namespaceURI\n   * @param {string} qualifiedName\n   * @returns {Element}\n   */\n  createElementNS: function (namespaceURI, qualifiedName) {\n    var validated = validateAndExtract(namespaceURI, qualifiedName);\n    var node = new Element(PDC);\n    var attrs = node.attributes = new NamedNodeMap();\n    node.childNodes = new NodeList();\n    node.ownerDocument = this;\n    node.nodeName = qualifiedName;\n    node.tagName = qualifiedName;\n    node.namespaceURI = validated[0];\n    node.prefix = validated[1];\n    node.localName = validated[2];\n    attrs._ownerElement = node;\n    return node;\n  },\n  // Introduced in DOM Level 2:\n  /**\n   * @param {string} namespaceURI\n   * @param {string} qualifiedName\n   * @returns {Attr}\n   */\n  createAttributeNS: function (namespaceURI, qualifiedName) {\n    var validated = validateAndExtract(namespaceURI, qualifiedName);\n    var node = new Attr(PDC);\n    node.ownerDocument = this;\n    node.childNodes = new NodeList();\n    node.nodeName = qualifiedName;\n    node.name = qualifiedName;\n    node.specified = true;\n    node.namespaceURI = validated[0];\n    node.prefix = validated[1];\n    node.localName = validated[2];\n    return node;\n  }\n};\n_extends(Document, Node);\nfunction Element(symbol) {\n  checkSymbol(symbol);\n  this._nsMap = Object.create(null);\n}\nElement.prototype = {\n  nodeType: ELEMENT_NODE,\n  /**\n   * The attributes of this element.\n   *\n   * @type {NamedNodeMap | null}\n   */\n  attributes: null,\n  getQualifiedName: function () {\n    return this.prefix ? this.prefix + ':' + this.localName : this.localName;\n  },\n  _isInHTMLDocumentAndNamespace: function () {\n    return this.ownerDocument.type === 'html' && this.namespaceURI === NAMESPACE.HTML;\n  },\n  /**\n   * Implementaton of Level2 Core function hasAttributes.\n   *\n   * @returns {boolean}\n   * True if attribute list is not empty.\n   * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs\n   */\n  hasAttributes: function () {\n    return !!(this.attributes && this.attributes.length);\n  },\n  hasAttribute: function (name) {\n    return !!this.getAttributeNode(name);\n  },\n  /**\n   * Returns elements first attribute whose qualified name is `name`, and `null`\n   * if there is no such attribute.\n   *\n   * @param {string} name\n   * @returns {string | null}\n   */\n  getAttribute: function (name) {\n    var attr = this.getAttributeNode(name);\n    return attr ? attr.value : null;\n  },\n  getAttributeNode: function (name) {\n    if (this._isInHTMLDocumentAndNamespace()) {\n      name = name.toLowerCase();\n    }\n    return this.attributes.getNamedItem(name);\n  },\n  /**\n   * Sets the value of elements first attribute whose qualified name is qualifiedName to value.\n   *\n   * @param {string} name\n   * @param {string} value\n   */\n  setAttribute: function (name, value) {\n    if (this._isInHTMLDocumentAndNamespace()) {\n      name = name.toLowerCase();\n    }\n    var attr = this.getAttributeNode(name);\n    if (attr) {\n      attr.value = attr.nodeValue = '' + value;\n    } else {\n      attr = this.ownerDocument._createAttribute(name);\n      attr.value = attr.nodeValue = '' + value;\n      this.setAttributeNode(attr);\n    }\n  },\n  removeAttribute: function (name) {\n    var attr = this.getAttributeNode(name);\n    attr && this.removeAttributeNode(attr);\n  },\n  setAttributeNode: function (newAttr) {\n    return this.attributes.setNamedItem(newAttr);\n  },\n  setAttributeNodeNS: function (newAttr) {\n    return this.attributes.setNamedItemNS(newAttr);\n  },\n  removeAttributeNode: function (oldAttr) {\n    //console.log(this == oldAttr.ownerElement)\n    return this.attributes.removeNamedItem(oldAttr.nodeName);\n  },\n  //get real attribute name,and remove it by removeAttributeNode\n  removeAttributeNS: function (namespaceURI, localName) {\n    var old = this.getAttributeNodeNS(namespaceURI, localName);\n    old && this.removeAttributeNode(old);\n  },\n  hasAttributeNS: function (namespaceURI, localName) {\n    return this.getAttributeNodeNS(namespaceURI, localName) != null;\n  },\n  /**\n   * Returns elements attribute whose namespace is `namespaceURI` and local name is\n   * `localName`,\n   * or `null` if there is no such attribute.\n   *\n   * @param {string} namespaceURI\n   * @param {string} localName\n   * @returns {string | null}\n   */\n  getAttributeNS: function (namespaceURI, localName) {\n    var attr = this.getAttributeNodeNS(namespaceURI, localName);\n    return attr ? attr.value : null;\n  },\n  /**\n   * Sets the value of elements attribute whose namespace is `namespaceURI` and local name is\n   * `localName` to value.\n   *\n   * @param {string} namespaceURI\n   * @param {string} qualifiedName\n   * @param {string} value\n   * @see https://dom.spec.whatwg.org/#dom-element-setattributens\n   */\n  setAttributeNS: function (namespaceURI, qualifiedName, value) {\n    var validated = validateAndExtract(namespaceURI, qualifiedName);\n    var localName = validated[2];\n    var attr = this.getAttributeNodeNS(namespaceURI, localName);\n    if (attr) {\n      attr.value = attr.nodeValue = '' + value;\n    } else {\n      attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n      attr.value = attr.nodeValue = '' + value;\n      this.setAttributeNode(attr);\n    }\n  },\n  getAttributeNodeNS: function (namespaceURI, localName) {\n    return this.attributes.getNamedItemNS(namespaceURI, localName);\n  },\n  /**\n   * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).\n   *\n   * Returns an empty list if `classNames` is an empty string or only contains HTML white space\n   * characters.\n   *\n   * Warning: This returns a live LiveNodeList.\n   * Changes in the DOM will reflect in the array as the changes occur.\n   * If an element selected by this array no longer qualifies for the selector,\n   * it will automatically be removed. Be aware of this for iteration purposes.\n   *\n   * @param {string} classNames\n   * Is a string representing the class name(s) to match; multiple class names are separated by\n   * (ASCII-)whitespace.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\n   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname\n   */\n  getElementsByClassName: function (classNames) {\n    var classNamesSet = toOrderedSet(classNames);\n    return new LiveNodeList(this, function (base) {\n      var ls = [];\n      if (classNamesSet.length > 0) {\n        _visitNode(base, function (node) {\n          if (node !== base && node.nodeType === ELEMENT_NODE) {\n            var nodeClassNames = node.getAttribute('class');\n            // can be null if the attribute does not exist\n            if (nodeClassNames) {\n              // before splitting and iterating just compare them for the most common case\n              var matches = classNames === nodeClassNames;\n              if (!matches) {\n                var nodeClassNamesSet = toOrderedSet(nodeClassNames);\n                matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));\n              }\n              if (matches) {\n                ls.push(node);\n              }\n            }\n          }\n        });\n      }\n      return ls;\n    });\n  },\n  /**\n   * Returns a LiveNodeList of elements with the given qualifiedName.\n   * Searching for all descendants can be done by passing `*` as `qualifiedName`.\n   *\n   * All descendants of the specified element are searched, but not the element itself.\n   * The returned list is live, which means it updates itself with the DOM tree automatically.\n   * Therefore, there is no need to call `Element.getElementsByTagName()`\n   * with the same element and arguments repeatedly if the DOM changes in between calls.\n   *\n   * When called on an HTML element in an HTML document,\n   * `getElementsByTagName` lower-cases the argument before searching for it.\n   * This is undesirable when trying to match camel-cased SVG elements (such as\n   * `<linearGradient>`) in an HTML document.\n   * Instead, use `Element.getElementsByTagNameNS()`,\n   * which preserves the capitalization of the tag name.\n   *\n   * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,\n   * except that it only searches for elements that are descendants of the specified element.\n   *\n   * @param {string} qualifiedName\n   * @returns {LiveNodeList}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\n   * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname\n   */\n  getElementsByTagName: function (qualifiedName) {\n    var isHTMLDocument = (this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument).type === 'html';\n    var lowerQualifiedName = qualifiedName.toLowerCase();\n    return new LiveNodeList(this, function (base) {\n      var ls = [];\n      _visitNode(base, function (node) {\n        if (node === base || node.nodeType !== ELEMENT_NODE) {\n          return;\n        }\n        if (qualifiedName === '*') {\n          ls.push(node);\n        } else {\n          var nodeQualifiedName = node.getQualifiedName();\n          var matchingQName = isHTMLDocument && node.namespaceURI === NAMESPACE.HTML ? lowerQualifiedName : qualifiedName;\n          if (nodeQualifiedName === matchingQName) {\n            ls.push(node);\n          }\n        }\n      });\n      return ls;\n    });\n  },\n  getElementsByTagNameNS: function (namespaceURI, localName) {\n    return new LiveNodeList(this, function (base) {\n      var ls = [];\n      _visitNode(base, function (node) {\n        if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {\n          ls.push(node);\n        }\n      });\n      return ls;\n    });\n  }\n};\nDocument.prototype.getElementsByClassName = Element.prototype.getElementsByClassName;\nDocument.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\nDocument.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n_extends(Element, Node);\nfunction Attr(symbol) {\n  checkSymbol(symbol);\n  this.namespaceURI = null;\n  this.prefix = null;\n  this.ownerElement = null;\n}\nAttr.prototype.nodeType = ATTRIBUTE_NODE;\n_extends(Attr, Node);\nfunction CharacterData(symbol) {\n  checkSymbol(symbol);\n}\nCharacterData.prototype = {\n  data: '',\n  substringData: function (offset, count) {\n    return this.data.substring(offset, offset + count);\n  },\n  appendData: function (text) {\n    text = this.data + text;\n    this.nodeValue = this.data = text;\n    this.length = text.length;\n  },\n  insertData: function (offset, text) {\n    this.replaceData(offset, 0, text);\n  },\n  deleteData: function (offset, count) {\n    this.replaceData(offset, count, '');\n  },\n  replaceData: function (offset, count, text) {\n    var start = this.data.substring(0, offset);\n    var end = this.data.substring(offset + count);\n    text = start + text + end;\n    this.nodeValue = this.data = text;\n    this.length = text.length;\n  }\n};\n_extends(CharacterData, Node);\nfunction Text(symbol) {\n  checkSymbol(symbol);\n}\nText.prototype = {\n  nodeName: '#text',\n  nodeType: TEXT_NODE,\n  splitText: function (offset) {\n    var text = this.data;\n    var newText = text.substring(offset);\n    text = text.substring(0, offset);\n    this.data = this.nodeValue = text;\n    this.length = text.length;\n    var newNode = this.ownerDocument.createTextNode(newText);\n    if (this.parentNode) {\n      this.parentNode.insertBefore(newNode, this.nextSibling);\n    }\n    return newNode;\n  }\n};\n_extends(Text, CharacterData);\nfunction Comment(symbol) {\n  checkSymbol(symbol);\n}\nComment.prototype = {\n  nodeName: '#comment',\n  nodeType: COMMENT_NODE\n};\n_extends(Comment, CharacterData);\nfunction CDATASection(symbol) {\n  checkSymbol(symbol);\n}\nCDATASection.prototype = {\n  nodeName: '#cdata-section',\n  nodeType: CDATA_SECTION_NODE\n};\n_extends(CDATASection, Text);\nfunction DocumentType(symbol) {\n  checkSymbol(symbol);\n}\nDocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n_extends(DocumentType, Node);\nfunction Notation(symbol) {\n  checkSymbol(symbol);\n}\nNotation.prototype.nodeType = NOTATION_NODE;\n_extends(Notation, Node);\nfunction Entity(symbol) {\n  checkSymbol(symbol);\n}\nEntity.prototype.nodeType = ENTITY_NODE;\n_extends(Entity, Node);\nfunction EntityReference(symbol) {\n  checkSymbol(symbol);\n}\nEntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n_extends(EntityReference, Node);\nfunction DocumentFragment(symbol) {\n  checkSymbol(symbol);\n}\nDocumentFragment.prototype.nodeName = '#document-fragment';\nDocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\n_extends(DocumentFragment, Node);\nfunction ProcessingInstruction(symbol) {\n  checkSymbol(symbol);\n}\nProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n_extends(ProcessingInstruction, CharacterData);\nfunction XMLSerializer() {}\nXMLSerializer.prototype.serializeToString = function (node, nodeFilter) {\n  return nodeSerializeToString.call(node, nodeFilter);\n};\nNode.prototype.toString = nodeSerializeToString;\nfunction nodeSerializeToString(nodeFilter) {\n  var buf = [];\n  var refNode = this.nodeType === DOCUMENT_NODE && this.documentElement || this;\n  var prefix = refNode.prefix;\n  var uri = refNode.namespaceURI;\n  if (uri && prefix == null) {\n    var prefix = refNode.lookupPrefix(uri);\n    if (prefix == null) {\n      var visibleNamespaces = [{\n        namespace: uri,\n        prefix: null\n      }\n      //{namespace:uri,prefix:''}\n      ];\n    }\n  }\n  serializeToString(this, buf, nodeFilter, visibleNamespaces);\n  return buf.join('');\n}\nfunction needNamespaceDefine(node, isHTML, visibleNamespaces) {\n  var prefix = node.prefix || '';\n  var uri = node.namespaceURI;\n  // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\n  // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\n  // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\n  // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\n  // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\n  // > [...] Furthermore, the attribute value [...] must not be an empty string.\n  // so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\n  if (!uri) {\n    return false;\n  }\n  if (prefix === 'xml' && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {\n    return false;\n  }\n  var i = visibleNamespaces.length;\n  while (i--) {\n    var ns = visibleNamespaces[i];\n    // get namespace prefix\n    if (ns.prefix === prefix) {\n      return ns.namespace !== uri;\n    }\n  }\n  return true;\n}\n/**\n * Literal whitespace other than space that appear in attribute values are serialized as\n * their entity references, so they will be preserved.\n * (In contrast to whitespace literals in the input which are normalized to spaces).\n *\n * Well-formed constraint: No < in Attribute Values:\n * > The replacement text of any entity referred to directly or indirectly\n * > in an attribute value must not contain a <.\n *\n * @see https://www.w3.org/TR/xml11/#CleanAttrVals\n * @see https://www.w3.org/TR/xml11/#NT-AttValue\n * @see https://www.w3.org/TR/xml11/#AVNormalize\n * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes\n * @prettierignore\n */\nfunction addSerializedAttribute(buf, qualifiedName, value) {\n  buf.push(' ', qualifiedName, '=\"', value.replace(/[<>&\"\\t\\n\\r]/g, _xmlEncoder), '\"');\n}\nfunction serializeToString(node, buf, nodeFilter, visibleNamespaces) {\n  if (!visibleNamespaces) {\n    visibleNamespaces = [];\n  }\n  var doc = node.nodeType === DOCUMENT_NODE ? node : node.ownerDocument;\n  var isHTML = doc.type === 'html';\n  if (nodeFilter) {\n    node = nodeFilter(node);\n    if (node) {\n      if (typeof node == 'string') {\n        buf.push(node);\n        return;\n      }\n    } else {\n      return;\n    }\n    //buf.sort.apply(attrs, attributeSorter);\n  }\n  switch (node.nodeType) {\n    case ELEMENT_NODE:\n      var attrs = node.attributes;\n      var len = attrs.length;\n      var child = node.firstChild;\n      var nodeName = node.tagName;\n      var prefixedNodeName = nodeName;\n      if (!isHTML && !node.prefix && node.namespaceURI) {\n        var defaultNS;\n        // lookup current default ns from `xmlns` attribute\n        for (var ai = 0; ai < attrs.length; ai++) {\n          if (attrs.item(ai).name === 'xmlns') {\n            defaultNS = attrs.item(ai).value;\n            break;\n          }\n        }\n        if (!defaultNS) {\n          // lookup current default ns in visibleNamespaces\n          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n            var namespace = visibleNamespaces[nsi];\n            if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\n              defaultNS = namespace.namespace;\n              break;\n            }\n          }\n        }\n        if (defaultNS !== node.namespaceURI) {\n          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n            var namespace = visibleNamespaces[nsi];\n            if (namespace.namespace === node.namespaceURI) {\n              if (namespace.prefix) {\n                prefixedNodeName = namespace.prefix + ':' + nodeName;\n              }\n              break;\n            }\n          }\n        }\n      }\n      buf.push('<', prefixedNodeName);\n      for (var i = 0; i < len; i++) {\n        // add namespaces for attributes\n        var attr = attrs.item(i);\n        if (attr.prefix == 'xmlns') {\n          visibleNamespaces.push({\n            prefix: attr.localName,\n            namespace: attr.value\n          });\n        } else if (attr.nodeName == 'xmlns') {\n          visibleNamespaces.push({\n            prefix: '',\n            namespace: attr.value\n          });\n        }\n      }\n      for (var i = 0; i < len; i++) {\n        var attr = attrs.item(i);\n        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {\n          var prefix = attr.prefix || '';\n          var uri = attr.namespaceURI;\n          addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);\n          visibleNamespaces.push({\n            prefix: prefix,\n            namespace: uri\n          });\n        }\n        serializeToString(attr, buf, nodeFilter, visibleNamespaces);\n      }\n\n      // add namespace for current node\n      if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {\n        var prefix = node.prefix || '';\n        var uri = node.namespaceURI;\n        addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);\n        visibleNamespaces.push({\n          prefix: prefix,\n          namespace: uri\n        });\n      }\n      // in XML elements can be closed when they have no children\n      var canCloseTag = !child;\n      if (canCloseTag && (isHTML || node.namespaceURI === NAMESPACE.HTML)) {\n        // in HTML (doc or ns) only void elements can be closed right away\n        canCloseTag = isHTMLVoidElement(nodeName);\n      }\n      if (canCloseTag) {\n        buf.push('/>');\n      } else {\n        buf.push('>');\n        //if is cdata child node\n        if (isHTML && isHTMLRawTextElement(nodeName)) {\n          while (child) {\n            if (child.data) {\n              buf.push(child.data);\n            } else {\n              serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());\n            }\n            child = child.nextSibling;\n          }\n        } else {\n          while (child) {\n            serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());\n            child = child.nextSibling;\n          }\n        }\n        buf.push('</', prefixedNodeName, '>');\n      }\n      // remove added visible namespaces\n      //visibleNamespaces.length = startVisibleNamespaces;\n      return;\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      var child = node.firstChild;\n      while (child) {\n        serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());\n        child = child.nextSibling;\n      }\n      return;\n    case ATTRIBUTE_NODE:\n      return addSerializedAttribute(buf, node.name, node.value);\n    case TEXT_NODE:\n      /*\n       * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\n       * except when used as markup delimiters, or within a comment, a processing instruction,\n       * or a CDATA section.\n       * If they are needed elsewhere, they must be escaped using either numeric character\n       * references or the strings `&amp;` and `&lt;` respectively.\n       * The right angle bracket (>) may be represented using the string \" &gt; \",\n       * and must, for compatibility, be escaped using either `&gt;`,\n       * or a character reference when it appears in the string `]]>` in content,\n       * when that string is not marking the end of a CDATA section.\n       *\n       * In the content of elements, character data is any string of characters which does not\n       * contain the start-delimiter of any markup and does not include the CDATA-section-close\n       * delimiter, `]]>`.\n       *\n       * @see https://www.w3.org/TR/xml/#NT-CharData\n       * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node\n       */\n      return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));\n    case CDATA_SECTION_NODE:\n      return buf.push(g.CDATA_START, node.data, g.CDATA_END);\n    case COMMENT_NODE:\n      return buf.push(g.COMMENT_START, node.data, g.COMMENT_END);\n    case DOCUMENT_TYPE_NODE:\n      var pubid = node.publicId;\n      var sysid = node.systemId;\n      buf.push(g.DOCTYPE_DECL_START, ' ', node.name);\n      if (pubid) {\n        buf.push(' ', g.PUBLIC, ' ', pubid);\n        if (sysid && sysid !== '.') {\n          buf.push(' ', sysid);\n        }\n      } else if (sysid && sysid !== '.') {\n        buf.push(' ', g.SYSTEM, ' ', sysid);\n      }\n      if (node.internalSubset) {\n        buf.push(' [', node.internalSubset, ']');\n      }\n      buf.push('>');\n      return;\n    case PROCESSING_INSTRUCTION_NODE:\n      return buf.push('<?', node.target, ' ', node.data, '?>');\n    case ENTITY_REFERENCE_NODE:\n      return buf.push('&', node.nodeName, ';');\n    //case ENTITY_NODE:\n    //case NOTATION_NODE:\n    default:\n      buf.push('??', node.nodeName);\n  }\n}\nfunction importNode(doc, node, deep) {\n  var node2;\n  switch (node.nodeType) {\n    case ELEMENT_NODE:\n      node2 = node.cloneNode(false);\n      node2.ownerDocument = doc;\n    //var attrs = node2.attributes;\n    //var len = attrs.length;\n    //for(var i=0;i<len;i++){\n    //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n    //}\n    case DOCUMENT_FRAGMENT_NODE:\n      break;\n    case ATTRIBUTE_NODE:\n      deep = true;\n      break;\n    //case ENTITY_REFERENCE_NODE:\n    //case PROCESSING_INSTRUCTION_NODE:\n    ////case TEXT_NODE:\n    //case CDATA_SECTION_NODE:\n    //case COMMENT_NODE:\n    //\tdeep = false;\n    //\tbreak;\n    //case DOCUMENT_NODE:\n    //case DOCUMENT_TYPE_NODE:\n    //cannot be imported.\n    //case ENTITY_NODE:\n    //case NOTATION_NODE\n    //can not hit in level3\n    //default:throw e;\n  }\n  if (!node2) {\n    node2 = node.cloneNode(false); //false\n  }\n  node2.ownerDocument = doc;\n  node2.parentNode = null;\n  if (deep) {\n    var child = node.firstChild;\n    while (child) {\n      node2.appendChild(importNode(doc, child, deep));\n      child = child.nextSibling;\n    }\n  }\n  return node2;\n}\n\n/**\n * Creates a copy of a node from an existing one.\n *\n * @param {Document} doc\n * The Document object representing the document that the new node will belong to.\n * @param {Node} node\n * The node to clone.\n * @param {boolean} deep\n * If true, the contents of the node are recursively copied.\n * If false, only the node itself (and its attributes, if it is an element) are copied.\n * @returns {Node}\n * Returns the newly created copy of the node.\n * @throws {DOMException}\n * May throw a DOMException if operations within setAttributeNode or appendChild (which are\n * potentially invoked in this function) do not meet their specific constraints.\n */\nfunction cloneNode(doc, node, deep) {\n  var node2 = new node.constructor(PDC);\n  for (var n in node) {\n    if (hasOwn(node, n)) {\n      var v = node[n];\n      if (typeof v != 'object') {\n        if (v != node2[n]) {\n          node2[n] = v;\n        }\n      }\n    }\n  }\n  if (node.childNodes) {\n    node2.childNodes = new NodeList();\n  }\n  node2.ownerDocument = doc;\n  switch (node2.nodeType) {\n    case ELEMENT_NODE:\n      var attrs = node.attributes;\n      var attrs2 = node2.attributes = new NamedNodeMap();\n      var len = attrs.length;\n      attrs2._ownerElement = node2;\n      for (var i = 0; i < len; i++) {\n        node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));\n      }\n      break;\n    case ATTRIBUTE_NODE:\n      deep = true;\n  }\n  if (deep) {\n    var child = node.firstChild;\n    while (child) {\n      node2.appendChild(cloneNode(doc, child, deep));\n      child = child.nextSibling;\n    }\n  }\n  return node2;\n}\nfunction __set__(object, key, value) {\n  object[key] = value;\n}\n//do dynamic\ntry {\n  if (Object.defineProperty) {\n    Object.defineProperty(LiveNodeList.prototype, 'length', {\n      get: function () {\n        _updateLiveList(this);\n        return this.$$length;\n      }\n    });\n    Object.defineProperty(Node.prototype, 'textContent', {\n      get: function () {\n        return getTextContent(this);\n      },\n      set: function (data) {\n        switch (this.nodeType) {\n          case ELEMENT_NODE:\n          case DOCUMENT_FRAGMENT_NODE:\n            while (this.firstChild) {\n              this.removeChild(this.firstChild);\n            }\n            if (data || String(data)) {\n              this.appendChild(this.ownerDocument.createTextNode(data));\n            }\n            break;\n          default:\n            this.data = data;\n            this.value = data;\n            this.nodeValue = data;\n        }\n      }\n    });\n    function getTextContent(node) {\n      switch (node.nodeType) {\n        case ELEMENT_NODE:\n        case DOCUMENT_FRAGMENT_NODE:\n          var buf = [];\n          node = node.firstChild;\n          while (node) {\n            if (node.nodeType !== 7 && node.nodeType !== 8) {\n              buf.push(getTextContent(node));\n            }\n            node = node.nextSibling;\n          }\n          return buf.join('');\n        default:\n          return node.nodeValue;\n      }\n    }\n    __set__ = function (object, key, value) {\n      //console.log(value)\n      object['$$' + key] = value;\n    };\n  }\n} catch (e) {\n  //ie8\n}\nexports._updateLiveList = _updateLiveList;\nexports.Attr = Attr;\nexports.CDATASection = CDATASection;\nexports.CharacterData = CharacterData;\nexports.Comment = Comment;\nexports.Document = Document;\nexports.DocumentFragment = DocumentFragment;\nexports.DocumentType = DocumentType;\nexports.DOMImplementation = DOMImplementation;\nexports.Element = Element;\nexports.Entity = Entity;\nexports.EntityReference = EntityReference;\nexports.LiveNodeList = LiveNodeList;\nexports.NamedNodeMap = NamedNodeMap;\nexports.Node = Node;\nexports.NodeList = NodeList;\nexports.Notation = Notation;\nexports.Text = Text;\nexports.ProcessingInstruction = ProcessingInstruction;\nexports.XMLSerializer = XMLSerializer;","map":{"version":3,"names":["conventions","require","find","hasDefaultHTMLNamespace","hasOwn","isHTMLMimeType","isHTMLRawTextElement","isHTMLVoidElement","MIME_TYPE","NAMESPACE","PDC","Symbol","errors","DOMException","DOMExceptionName","g","checkSymbol","symbol","TypeError","notEmptyString","input","splitOnASCIIWhitespace","split","filter","orderedSetReducer","current","element","toOrderedSet","list","Object","keys","reduce","arrayIncludes","indexOf","validateQualifiedName","qualifiedName","QName_exact","test","INVALID_CHARACTER_ERR","validateAndExtract","namespace","prefix","localName","splitResult","NAMESPACE_ERR","XML","XMLNS","copy","src","dest","p","_extends","Class","Super","pt","prototype","t","constructor","console","error","NodeType","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","DocumentPosition","freeze","DOCUMENT_POSITION_DISCONNECTED","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","commonAncestor","a","b","length","c","n","docGUID","doc","guid","Math","random","NodeList","item","index","toString","nodeFilter","buf","i","serializeToString","join","predicate","Array","call","iterator","me","next","value","done","return","LiveNodeList","node","refresh","_node","_refresh","_updateLiveList","inc","_inc","ownerDocument","ls","__set__","$$length","NamedNodeMap","_findNodeIndex","_addNamedNode","el","newAttr","oldAttr","ownerElement","_onRemoveAttribute","_onAddAttribute","_removeNamedNode","attr","lastIndex","getNamedItem","_ownerElement","_isInHTMLDocumentAndNamespace","toLowerCase","nodeName","setNamedItem","INUSE_ATTRIBUTE_ERR","getNamedItemNS","namespaceURI","setNamedItemNS","removeNamedItem","NOT_FOUND_ERR","removeNamedItemNS","DOMImplementation","hasFeature","feature","version","createDocument","doctype","contentType","XML_APPLICATION","HTML","XML_XHTML_APPLICATION","SVG","XML_SVG_IMAGE","Document","implementation","childNodes","appendChild","root","createElementNS","createDocumentType","publicId","systemId","internalSubset","DocumentType","name","createHTMLDocument","title","htmlNode","createElement","headNode","titleNode","createTextNode","Node","firstChild","lastChild","previousSibling","nextSibling","parentNode","parentElement","nodeType","nodeValue","baseURI","isConnected","rootNode","getRootNode","contains","other","parent","options","isEqualNode","otherNode","attributes","getAttributeNodeNS","target","data","isSameNode","insertBefore","newChild","refChild","_insertBefore","replaceChild","oldChild","assertPreReplacementValidityInDocument","removeChild","_removeChild","hasChildNodes","cloneNode","deep","normalize","child","appendData","isSupported","lookupPrefix","map","_nsMap","lookupNamespaceURI","isDefaultNamespace","compareDocumentPosition","node1","node2","attr1","attr2","Attr","chain1","ancestor1","push","reverse","chain2","ancestor2","ca","_xmlEncoder","charCodeAt","_visitNode","callback","opt","type","ns","remove","_onUpdateChild","oldPreviousSibling","oldNextSibling","hasValidParentNodeType","hasInsertableNodeType","isDocTypeNode","isElementNode","isTextNode","isElementInsertionPossible","parentChildNodes","docTypeNode","isElementReplacementPossible","hasElementChildThatIsNotChild","assertPreInsertionValidity1to5","HIERARCHY_REQUEST_ERR","assertPreInsertionValidityInDocument","nodeChildNodes","nodeChildElements","parentElementChild","hasDoctypeChildThatIsNotChild","_inDocumentAssertion","cp","newFirst","newLast","pre","documentElement","removed","importNode","importedNode","getElementById","id","rtv","getAttribute","tagName","Element","attrs","createDocumentFragment","DocumentFragment","Text","createComment","Comment","createCDATASection","CDATASection","createProcessingInstruction","ProcessingInstruction","createAttribute","_createAttribute","specified","createEntityReference","Name","NotSupportedError","EntityReference","validated","createAttributeNS","create","getQualifiedName","hasAttributes","hasAttribute","getAttributeNode","setAttribute","setAttributeNode","removeAttribute","removeAttributeNode","setAttributeNodeNS","removeAttributeNS","old","hasAttributeNS","getAttributeNS","setAttributeNS","getElementsByClassName","classNames","classNamesSet","base","nodeClassNames","matches","nodeClassNamesSet","every","getElementsByTagName","isHTMLDocument","lowerQualifiedName","nodeQualifiedName","matchingQName","getElementsByTagNameNS","CharacterData","substringData","offset","count","substring","text","insertData","replaceData","deleteData","start","end","splitText","newText","newNode","Notation","Entity","XMLSerializer","nodeSerializeToString","refNode","uri","visibleNamespaces","needNamespaceDefine","isHTML","addSerializedAttribute","replace","len","prefixedNodeName","defaultNS","ai","nsi","canCloseTag","slice","CDATA_START","CDATA_END","COMMENT_START","COMMENT_END","pubid","sysid","DOCTYPE_DECL_START","PUBLIC","SYSTEM","v","attrs2","object","key","defineProperty","get","getTextContent","set","String","e","exports"],"sources":["C:/Users/rc_sh/Desktop/Unidad oftalmologica/Clinica_rosmarian_castillo/frontend/node_modules/@xmldom/xmldom/lib/dom.js"],"sourcesContent":["'use strict';\n\nvar conventions = require('./conventions');\nvar find = conventions.find;\nvar hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;\nvar hasOwn = conventions.hasOwn;\nvar isHTMLMimeType = conventions.isHTMLMimeType;\nvar isHTMLRawTextElement = conventions.isHTMLRawTextElement;\nvar isHTMLVoidElement = conventions.isHTMLVoidElement;\nvar MIME_TYPE = conventions.MIME_TYPE;\nvar NAMESPACE = conventions.NAMESPACE;\n\n/**\n * Private DOM Constructor symbol\n *\n * Internal symbol used for construction of all classes whose constructors should be private.\n * Currently used for checks in `Node`, `Document`, `Element`, `Attr`, `CharacterData`, `Text`, `Comment`,\n * `CDATASection`, `DocumentType`, `Notation`, `Entity`, `EntityReference`, `DocumentFragment`, `ProcessingInstruction`\n * so the constructor can't be used from outside the module.\n */\nvar PDC = Symbol();\n\nvar errors = require('./errors');\nvar DOMException = errors.DOMException;\nvar DOMExceptionName = errors.DOMExceptionName;\n\nvar g = require('./grammar');\n\n/**\n * Checks if the given symbol equals the Private DOM Constructor symbol (PDC)\n * and throws an Illegal constructor exception when the symbols don't match.\n * This ensures that the constructor remains private and can't be used outside this module.\n */\nfunction checkSymbol(symbol) {\n\tif (symbol !== PDC) {\n\t\tthrow new TypeError('Illegal constructor');\n\t}\n}\n\n/**\n * A prerequisite for `[].filter`, to drop elements that are empty.\n *\n * @param {string} input\n * The string to be checked.\n * @returns {boolean}\n * Returns `true` if the input string is not empty, `false` otherwise.\n */\nfunction notEmptyString(input) {\n\treturn input !== '';\n}\n/**\n * Splits a string on ASCII whitespace characters (U+0009 TAB, U+000A LF, U+000C FF, U+000D CR,\n * U+0020 SPACE).\n * It follows the definition from the infra specification from WHATWG.\n *\n * @param {string} input\n * The string to be split.\n * @returns {string[]}\n * An array of the split strings. The array can be empty if the input string is empty or only\n * contains whitespace characters.\n * @see {@link https://infra.spec.whatwg.org/#split-on-ascii-whitespace}\n * @see {@link https://infra.spec.whatwg.org/#ascii-whitespace}\n */\nfunction splitOnASCIIWhitespace(input) {\n\t// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE\n\treturn input ? input.split(/[\\t\\n\\f\\r ]+/).filter(notEmptyString) : [];\n}\n\n/**\n * Adds element as a key to current if it is not already present.\n *\n * @param {Record<string, boolean | undefined>} current\n * The current record object to which the element will be added as a key.\n * The object's keys are string types and values are either boolean or undefined.\n * @param {string} element\n * The string to be added as a key to the current record.\n * @returns {Record<string, boolean | undefined>}\n * The updated record object after the addition of the new element.\n */\nfunction orderedSetReducer(current, element) {\n\tif (!hasOwn(current, element)) {\n\t\tcurrent[element] = true;\n\t}\n\treturn current;\n}\n\n/**\n * Converts a string into an ordered set by splitting the input on ASCII whitespace and\n * ensuring uniqueness of elements.\n * This follows the definition of an ordered set from the infra specification by WHATWG.\n *\n * @param {string} input\n * The input string to be transformed into an ordered set.\n * @returns {string[]}\n * An array of unique strings obtained from the input, preserving the original order.\n * The array can be empty if the input string is empty or only contains whitespace characters.\n * @see {@link https://infra.spec.whatwg.org/#ordered-set}\n */\nfunction toOrderedSet(input) {\n\tif (!input) return [];\n\tvar list = splitOnASCIIWhitespace(input);\n\treturn Object.keys(list.reduce(orderedSetReducer, {}));\n}\n\n/**\n * Uses `list.indexOf` to implement a function that behaves like `Array.prototype.includes`.\n * This function is used in environments where `Array.prototype.includes` may not be available.\n *\n * @param {any[]} list\n * The array in which to search for the element.\n * @returns {function(any): boolean}\n * A function that accepts an element and returns a boolean indicating whether the element is\n * included in the provided list.\n */\nfunction arrayIncludes(list) {\n\treturn function (element) {\n\t\treturn list && list.indexOf(element) !== -1;\n\t};\n}\n\n/**\n * Validates a qualified name based on the criteria provided in the DOM specification by\n * WHATWG.\n *\n * @param {string} qualifiedName\n * The qualified name to be validated.\n * @throws {DOMException}\n * With code {@link DOMException.INVALID_CHARACTER_ERR} if the qualified name contains an\n * invalid character.\n * @see {@link https://dom.spec.whatwg.org/#validate}\n */\nfunction validateQualifiedName(qualifiedName) {\n\tif (!g.QName_exact.test(qualifiedName)) {\n\t\tthrow new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in qualified name \"' + qualifiedName + '\"');\n\t}\n}\n\n/**\n * Validates a qualified name and the namespace associated with it,\n * based on the criteria provided in the DOM specification by WHATWG.\n *\n * @param {string | null} namespace\n * The namespace to be validated. It can be a string or null.\n * @param {string} qualifiedName\n * The qualified name to be validated.\n * @returns {[namespace: string | null, prefix: string | null, localName: string]}\n * Returns a tuple with the namespace,\n * prefix and local name of the qualified name.\n * @throws {DOMException}\n * Throws a DOMException if the qualified name or the namespace is not valid.\n * @see {@link https://dom.spec.whatwg.org/#validate-and-extract}\n */\nfunction validateAndExtract(namespace, qualifiedName) {\n\tvalidateQualifiedName(qualifiedName);\n\tnamespace = namespace || null;\n\t/**\n\t * @type {string | null}\n\t */\n\tvar prefix = null;\n\tvar localName = qualifiedName;\n\tif (qualifiedName.indexOf(':') >= 0) {\n\t\tvar splitResult = qualifiedName.split(':');\n\t\tprefix = splitResult[0];\n\t\tlocalName = splitResult[1];\n\t}\n\tif (prefix !== null && namespace === null) {\n\t\tthrow new DOMException(DOMException.NAMESPACE_ERR, 'prefix is non-null and namespace is null');\n\t}\n\tif (prefix === 'xml' && namespace !== conventions.NAMESPACE.XML) {\n\t\tthrow new DOMException(DOMException.NAMESPACE_ERR, 'prefix is \"xml\" and namespace is not the XML namespace');\n\t}\n\tif ((prefix === 'xmlns' || qualifiedName === 'xmlns') && namespace !== conventions.NAMESPACE.XMLNS) {\n\t\tthrow new DOMException(\n\t\t\tDOMException.NAMESPACE_ERR,\n\t\t\t'either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace'\n\t\t);\n\t}\n\tif (namespace === conventions.NAMESPACE.XMLNS && prefix !== 'xmlns' && qualifiedName !== 'xmlns') {\n\t\tthrow new DOMException(\n\t\t\tDOMException.NAMESPACE_ERR,\n\t\t\t'namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\"'\n\t\t);\n\t}\n\treturn [namespace, prefix, localName];\n}\n\n/**\n * Copies properties from one object to another.\n * It only copies the object's own (not inherited) properties.\n *\n * @param {Object} src\n * The source object from which properties are copied.\n * @param {Object} dest\n * The destination object to which properties are copied.\n */\nfunction copy(src, dest) {\n\tfor (var p in src) {\n\t\tif (hasOwn(src, p)) {\n\t\t\tdest[p] = src[p];\n\t\t}\n\t}\n}\n\n/**\n * Extends a class with the properties and methods of a super class.\n * It uses a form of prototypal inheritance, and establishes the `constructor` property\n * correctly(?).\n *\n * It is not clear to the current maintainers if this implementation is making sense,\n * since it creates an intermediate prototype function,\n * which all properties of `Super` are copied onto using `_copy`.\n *\n * @param {Object} Class\n * The class that is to be extended.\n * @param {Object} Super\n * The super class from which properties and methods are inherited.\n * @private\n */\nfunction _extends(Class, Super) {\n\tvar pt = Class.prototype;\n\tif (!(pt instanceof Super)) {\n\t\tfunction t() {}\n\t\tt.prototype = Super.prototype;\n\t\tt = new t();\n\t\tcopy(pt, t);\n\t\tClass.prototype = pt = t;\n\t}\n\tif (pt.constructor != Class) {\n\t\tif (typeof Class != 'function') {\n\t\t\tconsole.error('unknown Class:' + Class);\n\t\t}\n\t\tpt.constructor = Class;\n\t}\n}\n\nvar NodeType = {};\nvar ELEMENT_NODE = (NodeType.ELEMENT_NODE = 1);\nvar ATTRIBUTE_NODE = (NodeType.ATTRIBUTE_NODE = 2);\nvar TEXT_NODE = (NodeType.TEXT_NODE = 3);\nvar CDATA_SECTION_NODE = (NodeType.CDATA_SECTION_NODE = 4);\nvar ENTITY_REFERENCE_NODE = (NodeType.ENTITY_REFERENCE_NODE = 5);\nvar ENTITY_NODE = (NodeType.ENTITY_NODE = 6);\nvar PROCESSING_INSTRUCTION_NODE = (NodeType.PROCESSING_INSTRUCTION_NODE = 7);\nvar COMMENT_NODE = (NodeType.COMMENT_NODE = 8);\nvar DOCUMENT_NODE = (NodeType.DOCUMENT_NODE = 9);\nvar DOCUMENT_TYPE_NODE = (NodeType.DOCUMENT_TYPE_NODE = 10);\nvar DOCUMENT_FRAGMENT_NODE = (NodeType.DOCUMENT_FRAGMENT_NODE = 11);\nvar NOTATION_NODE = (NodeType.NOTATION_NODE = 12);\n\nvar DocumentPosition = conventions.freeze({\n\tDOCUMENT_POSITION_DISCONNECTED: 1,\n\tDOCUMENT_POSITION_PRECEDING: 2,\n\tDOCUMENT_POSITION_FOLLOWING: 4,\n\tDOCUMENT_POSITION_CONTAINS: 8,\n\tDOCUMENT_POSITION_CONTAINED_BY: 16,\n\tDOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32,\n});\n\n//helper functions for compareDocumentPosition\n/**\n * Finds the common ancestor in two parent chains.\n *\n * @param {Node[]} a\n * The first parent chain.\n * @param {Node[]} b\n * The second parent chain.\n * @returns {Node}\n * The common ancestor node if it exists. If there is no common ancestor, the function will\n * return `null`.\n */\nfunction commonAncestor(a, b) {\n\tif (b.length < a.length) return commonAncestor(b, a);\n\tvar c = null;\n\tfor (var n in a) {\n\t\tif (a[n] !== b[n]) return c;\n\t\tc = a[n];\n\t}\n\treturn c;\n}\n\n/**\n * Assigns a unique identifier to a document to ensure consistency while comparing unrelated\n * nodes.\n *\n * @param {Document} doc\n * The document to which a unique identifier is to be assigned.\n * @returns {string}\n * The unique identifier of the document. If the document already had a unique identifier, the\n * function will return the existing one.\n */\nfunction docGUID(doc) {\n\tif (!doc.guid) doc.guid = Math.random();\n\treturn doc.guid;\n}\n//-- end of helper functions\n\n/**\n * The NodeList interface provides the abstraction of an ordered collection of nodes,\n * without defining or constraining how this collection is implemented.\n * NodeList objects in the DOM are live.\n * The items in the NodeList are accessible via an integral index, starting from 0.\n * You can also access the items of the NodeList with a `for...of` loop.\n *\n * @class NodeList\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n * @constructs NodeList\n */\nfunction NodeList() {}\nNodeList.prototype = {\n\t/**\n\t * The number of nodes in the list. The range of valid child node indices is 0 to length-1\n\t * inclusive.\n\t *\n\t * @type {number}\n\t */\n\tlength: 0,\n\t/**\n\t * Returns the item at `index`. If index is greater than or equal to the number of nodes in\n\t * the list, this returns null.\n\t *\n\t * @param index\n\t * Unsigned long Index into the collection.\n\t * @returns {Node | null}\n\t * The node at position `index` in the NodeList,\n\t * or null if that is not a valid index.\n\t */\n\titem: function (index) {\n\t\treturn index >= 0 && index < this.length ? this[index] : null;\n\t},\n\t/**\n\t * Returns a string representation of the NodeList.\n\t *\n\t * @param {unknown} nodeFilter\n\t * __A filter function? Not implemented according to the spec?__.\n\t * @returns {string}\n\t * A string representation of the NodeList.\n\t */\n\ttoString: function (nodeFilter) {\n\t\tfor (var buf = [], i = 0; i < this.length; i++) {\n\t\t\tserializeToString(this[i], buf, nodeFilter);\n\t\t}\n\t\treturn buf.join('');\n\t},\n\t/**\n\t * Filters the NodeList based on a predicate.\n\t *\n\t * @param {function(Node): boolean} predicate\n\t * - A predicate function to filter the NodeList.\n\t * @returns {Node[]}\n\t * An array of nodes that satisfy the predicate.\n\t * @private\n\t */\n\tfilter: function (predicate) {\n\t\treturn Array.prototype.filter.call(this, predicate);\n\t},\n\t/**\n\t * Returns the first index at which a given node can be found in the NodeList, or -1 if it is\n\t * not present.\n\t *\n\t * @param {Node} item\n\t * - The Node item to locate in the NodeList.\n\t * @returns {number}\n\t * The first index of the node in the NodeList; -1 if not found.\n\t * @private\n\t */\n\tindexOf: function (item) {\n\t\treturn Array.prototype.indexOf.call(this, item);\n\t},\n};\nNodeList.prototype[Symbol.iterator] = function () {\n\tvar me = this;\n\tvar index = 0;\n\n\treturn {\n\t\tnext: function () {\n\t\t\tif (index < me.length) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: me[index++],\n\t\t\t\t\tdone: false,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\treturn: function () {\n\t\t\treturn {\n\t\t\t\tdone: true,\n\t\t\t};\n\t\t},\n\t};\n};\n\n/**\n * Represents a live collection of nodes that is automatically updated when its associated\n * document changes.\n *\n * @class LiveNodeList\n * @param {Node} node\n * The associated node.\n * @param {function} refresh\n * The function to refresh the live node list.\n * @augments NodeList\n * @constructs LiveNodeList\n */\nfunction LiveNodeList(node, refresh) {\n\tthis._node = node;\n\tthis._refresh = refresh;\n\t_updateLiveList(this);\n}\n/**\n * Updates the live node list.\n *\n * @param {LiveNodeList} list\n * The live node list to update.\n * @private\n */\nfunction _updateLiveList(list) {\n\tvar inc = list._node._inc || list._node.ownerDocument._inc;\n\tif (list._inc !== inc) {\n\t\tvar ls = list._refresh(list._node);\n\t\t__set__(list, 'length', ls.length);\n\t\tif (!list.$$length || ls.length < list.$$length) {\n\t\t\tfor (var i = ls.length; i in list; i++) {\n\t\t\t\tif (hasOwn(list, i)) {\n\t\t\t\t\tdelete list[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcopy(ls, list);\n\t\tlist._inc = inc;\n\t}\n}\n/**\n * Returns the node at position `index` in the LiveNodeList, or null if that is not a valid\n * index.\n *\n * @param {number} i\n * Index into the collection.\n * @returns {Node | null}\n * The node at position `index` in the LiveNodeList, or null if that is not a valid index.\n */\nLiveNodeList.prototype.item = function (i) {\n\t_updateLiveList(this);\n\treturn this[i] || null;\n};\n\n_extends(LiveNodeList, NodeList);\n\n/**\n * Objects implementing the NamedNodeMap interface are used to represent collections of nodes\n * that can be accessed by name.\n * Note that NamedNodeMap does not inherit from NodeList;\n * NamedNodeMaps are not maintained in any particular order.\n * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal\n * index,\n * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,\n * and does not imply that the DOM specifies an order to these Nodes.\n * NamedNodeMap objects in the DOM are live.\n * used for attributes or DocumentType entities\n *\n * This implementation only supports property indices, but does not support named properties,\n * as specified in the living standard.\n *\n * @class NamedNodeMap\n * @see https://dom.spec.whatwg.org/#interface-namednodemap\n * @see https://webidl.spec.whatwg.org/#dfn-supported-property-names\n * @constructs NamedNodeMap\n */\nfunction NamedNodeMap() {}\n/**\n * Returns the index of a node within the list.\n *\n * @param {Array} list\n * The list of nodes.\n * @param {Node} node\n * The node to find.\n * @returns {number}\n * The index of the node within the list, or -1 if not found.\n * @private\n */\nfunction _findNodeIndex(list, node) {\n\tvar i = 0;\n\twhile (i < list.length) {\n\t\tif (list[i] === node) {\n\t\t\treturn i;\n\t\t}\n\t\ti++;\n\t}\n}\n/**\n * Adds a new attribute to the list and updates the owner element of the attribute.\n *\n * @param {Element} el\n * The element which will become the owner of the new attribute.\n * @param {NamedNodeMap} list\n * The list to which the new attribute will be added.\n * @param {Attr} newAttr\n * The new attribute to be added.\n * @param {Attr} oldAttr\n * The old attribute to be replaced, or null if no attribute is to be replaced.\n * @returns {void}\n * @private\n */\nfunction _addNamedNode(el, list, newAttr, oldAttr) {\n\tif (oldAttr) {\n\t\tlist[_findNodeIndex(list, oldAttr)] = newAttr;\n\t} else {\n\t\tlist[list.length] = newAttr;\n\t\tlist.length++;\n\t}\n\tif (el) {\n\t\tnewAttr.ownerElement = el;\n\t\tvar doc = el.ownerDocument;\n\t\tif (doc) {\n\t\t\toldAttr && _onRemoveAttribute(doc, el, oldAttr);\n\t\t\t_onAddAttribute(doc, el, newAttr);\n\t\t}\n\t}\n}\n/**\n * Removes an attribute from the list and updates the owner element of the attribute.\n *\n * @param {Element} el\n * The element which is the current owner of the attribute.\n * @param {NamedNodeMap} list\n * The list from which the attribute will be removed.\n * @param {Attr} attr\n * The attribute to be removed.\n * @returns {void}\n * @private\n */\nfunction _removeNamedNode(el, list, attr) {\n\t//console.log('remove attr:'+attr)\n\tvar i = _findNodeIndex(list, attr);\n\tif (i >= 0) {\n\t\tvar lastIndex = list.length - 1;\n\t\twhile (i <= lastIndex) {\n\t\t\tlist[i] = list[++i];\n\t\t}\n\t\tlist.length = lastIndex;\n\t\tif (el) {\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tif (doc) {\n\t\t\t\t_onRemoveAttribute(doc, el, attr);\n\t\t\t}\n\t\t\tattr.ownerElement = null;\n\t\t}\n\t}\n}\nNamedNodeMap.prototype = {\n\tlength: 0,\n\titem: NodeList.prototype.item,\n\n\t/**\n\t * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and\n\t * document.\n\t *\n\t * @param {string} localName\n\t * The local name of the attribute.\n\t * @returns {Attr | null}\n\t * The attribute with the given local name, or null if no such attribute exists.\n\t * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name\n\t */\n\tgetNamedItem: function (localName) {\n\t\tif (this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace()) {\n\t\t\tlocalName = localName.toLowerCase();\n\t\t}\n\t\tvar i = 0;\n\t\twhile (i < this.length) {\n\t\t\tvar attr = this[i];\n\t\t\tif (attr.nodeName === localName) {\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn null;\n\t},\n\n\t/**\n\t * Set an attribute.\n\t *\n\t * @param {Attr} attr\n\t * The attribute to set.\n\t * @returns {Attr | null}\n\t * The old attribute with the same local name and namespace URI as the new one, or null if no\n\t * such attribute exists.\n\t * @throws {DOMException}\n\t * With code:\n\t * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another\n\t * element.\n\t * @see https://dom.spec.whatwg.org/#concept-element-attributes-set\n\t */\n\tsetNamedItem: function (attr) {\n\t\tvar el = attr.ownerElement;\n\t\tif (el && el !== this._ownerElement) {\n\t\t\tthrow new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n\t\t}\n\t\tvar oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\n\t\tif (oldAttr === attr) {\n\t\t\treturn attr;\n\t\t}\n\t\t_addNamedNode(this._ownerElement, this, attr, oldAttr);\n\t\treturn oldAttr;\n\t},\n\n\t/**\n\t * Set an attribute, replacing an existing attribute with the same local name and namespace\n\t * URI if one exists.\n\t *\n\t * @param {Attr} attr\n\t * The attribute to set.\n\t * @returns {Attr | null}\n\t * The old attribute with the same local name and namespace URI as the new one, or null if no\n\t * such attribute exists.\n\t * @throws {DOMException}\n\t * Throws a DOMException with the name \"InUseAttributeError\" if the attribute is already an\n\t * attribute of another element.\n\t * @see https://dom.spec.whatwg.org/#concept-element-attributes-set\n\t */\n\tsetNamedItemNS: function (attr) {\n\t\treturn this.setNamedItem(attr);\n\t},\n\n\t/**\n\t * Removes an attribute specified by the local name.\n\t *\n\t * @param {string} localName\n\t * The local name of the attribute to be removed.\n\t * @returns {Attr}\n\t * The attribute node that was removed.\n\t * @throws {DOMException}\n\t * With code:\n\t * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.\n\t * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem\n\t * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name\n\t */\n\tremoveNamedItem: function (localName) {\n\t\tvar attr = this.getNamedItem(localName);\n\t\tif (!attr) {\n\t\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, localName);\n\t\t}\n\t\t_removeNamedNode(this._ownerElement, this, attr);\n\t\treturn attr;\n\t},\n\n\t/**\n\t * Removes an attribute specified by the namespace and local name.\n\t *\n\t * @param {string | null} namespaceURI\n\t * The namespace URI of the attribute to be removed.\n\t * @param {string} localName\n\t * The local name of the attribute to be removed.\n\t * @returns {Attr}\n\t * The attribute node that was removed.\n\t * @throws {DOMException}\n\t * With code:\n\t * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local\n\t * name is found.\n\t * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns\n\t * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace\n\t */\n\tremoveNamedItemNS: function (namespaceURI, localName) {\n\t\tvar attr = this.getNamedItemNS(namespaceURI, localName);\n\t\tif (!attr) {\n\t\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, namespaceURI ? namespaceURI + ' : ' + localName : localName);\n\t\t}\n\t\t_removeNamedNode(this._ownerElement, this, attr);\n\t\treturn attr;\n\t},\n\n\t/**\n\t * Get an attribute by namespace and local name.\n\t *\n\t * @param {string | null} namespaceURI\n\t * The namespace URI of the attribute.\n\t * @param {string} localName\n\t * The local name of the attribute.\n\t * @returns {Attr | null}\n\t * The attribute with the given namespace URI and local name, or null if no such attribute\n\t * exists.\n\t * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace\n\t */\n\tgetNamedItemNS: function (namespaceURI, localName) {\n\t\tif (!namespaceURI) {\n\t\t\tnamespaceURI = null;\n\t\t}\n\t\tvar i = 0;\n\t\twhile (i < this.length) {\n\t\t\tvar node = this[i];\n\t\t\tif (node.localName === localName && node.namespaceURI === namespaceURI) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn null;\n\t},\n};\nNamedNodeMap.prototype[Symbol.iterator] = function () {\n\tvar me = this;\n\tvar index = 0;\n\n\treturn {\n\t\tnext: function () {\n\t\t\tif (index < me.length) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: me[index++],\n\t\t\t\t\tdone: false,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\treturn: function () {\n\t\t\treturn {\n\t\t\t\tdone: true,\n\t\t\t};\n\t\t},\n\t};\n};\n\n/**\n * The DOMImplementation interface provides a number of methods for performing operations that\n * are independent of any particular instance of the document object model.\n *\n * The DOMImplementation interface represents an object providing methods which are not\n * dependent on any particular document.\n * Such an object is returned by the `Document.implementation` property.\n *\n * **The individual methods describe the differences compared to the specs**.\n *\n * @class DOMImplementation\n * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN\n * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core\n *      (Initial)\n * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core\n * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core\n * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard\n * @constructs DOMImplementation\n */\nfunction DOMImplementation() {}\n\nDOMImplementation.prototype = {\n\t/**\n\t * Test if the DOM implementation implements a specific feature and version, as specified in\n\t * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.\n\t *\n\t * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given\n\t * feature is supported. The different implementations fairly diverged in what kind of\n\t * features were reported. The latest version of the spec settled to force this method to\n\t * always return true, where the functionality was accurate and in use.\n\t *\n\t * @deprecated\n\t * It is deprecated and modern browsers return true in all cases.\n\t * @function DOMImplementation#hasFeature\n\t * @param {string} feature\n\t * The name of the feature to test.\n\t * @param {string} [version]\n\t * This is the version number of the feature to test.\n\t * @returns {boolean}\n\t * Always returns true.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN\n\t * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core\n\t */\n\thasFeature: function (feature, version) {\n\t\treturn true;\n\t},\n\t/**\n\t * Creates a DOM Document object of the specified type with its document element. Note that\n\t * based on the {@link DocumentType}\n\t * given to create the document, the implementation may instantiate specialized\n\t * {@link Document} objects that support additional features than the \"Core\", such as \"HTML\"\n\t * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.\n\t * On the other hand, setting the {@link DocumentType} after the document was created makes\n\t * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,\n\t * such as createHTMLDocument\n\t * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},\n\t * can be used to obtain specific types of {@link Document} objects.\n\t *\n\t * __It behaves slightly different from the description in the living standard__:\n\t * - There is no interface/class `XMLDocument`, it returns a `Document`\n\t * instance (with it's `type` set to `'xml'`).\n\t * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n\t *\n\t * @function DOMImplementation.createDocument\n\t * @param {string | null} namespaceURI\n\t * The\n\t * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}\n\t * of the document element to create or null.\n\t * @param {string | null} qualifiedName\n\t * The\n\t * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}\n\t * of the document element to be created or null.\n\t * @param {DocumentType | null} [doctype=null]\n\t * The type of document to be created or null. When doctype is not null, its\n\t * {@link Node#ownerDocument} attribute is set to the document being created. Default is\n\t * `null`\n\t * @returns {Document}\n\t * A new {@link Document} object with its document element. If the NamespaceURI,\n\t * qualifiedName, and doctype are null, the returned {@link Document} is empty with no\n\t * document element.\n\t * @throws {DOMException}\n\t * With code:\n\t *\n\t * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name\n\t * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.\n\t * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a\n\t * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI\n\t * is different from null, or if the qualifiedName has a prefix that is \"xml\" and the\n\t * namespaceURI is different from \"{@link http://www.w3.org/XML/1998/namespace}\"\n\t * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},\n\t * or if the DOM implementation does not support the \"XML\" feature but a non-null namespace\n\t * URI was provided, since namespaces were defined by XML.\n\t * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document\n\t * or was created from a different implementation.\n\t * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature\n\t * \"XML\" and the language exposed through the Document does not support XML Namespaces (such\n\t * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).\n\t * @since DOM Level 2.\n\t * @see {@link #createHTMLDocument}\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM\n\t *      Level 3 Core\n\t * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM\n\t *      Level 2 Core (initial)\n\t */\n\tcreateDocument: function (namespaceURI, qualifiedName, doctype) {\n\t\tvar contentType = MIME_TYPE.XML_APPLICATION;\n\t\tif (namespaceURI === NAMESPACE.HTML) {\n\t\t\tcontentType = MIME_TYPE.XML_XHTML_APPLICATION;\n\t\t} else if (namespaceURI === NAMESPACE.SVG) {\n\t\t\tcontentType = MIME_TYPE.XML_SVG_IMAGE;\n\t\t}\n\t\tvar doc = new Document(PDC, { contentType: contentType });\n\t\tdoc.implementation = this;\n\t\tdoc.childNodes = new NodeList();\n\t\tdoc.doctype = doctype || null;\n\t\tif (doctype) {\n\t\t\tdoc.appendChild(doctype);\n\t\t}\n\t\tif (qualifiedName) {\n\t\t\tvar root = doc.createElementNS(namespaceURI, qualifiedName);\n\t\t\tdoc.appendChild(root);\n\t\t}\n\t\treturn doc;\n\t},\n\t/**\n\t * Creates an empty DocumentType node. Entity declarations and notations are not made\n\t * available. Entity reference expansions and default attribute additions do not occur.\n\t *\n\t * **This behavior is slightly different from the one in the specs**:\n\t * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n\t * - `publicId` and `systemId` contain the raw data including any possible quotes,\n\t *   so they can always be serialized back to the original value\n\t * - `internalSubset` contains the raw string between `[` and `]` if present,\n\t *   but is not parsed or validated in any form.\n\t *\n\t * @function DOMImplementation#createDocumentType\n\t * @param {string} qualifiedName\n\t * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified\n\t * name} of the document type to be created.\n\t * @param {string} [publicId]\n\t * The external subset public identifier.\n\t * @param {string} [systemId]\n\t * The external subset system identifier.\n\t * @param {string} [internalSubset]\n\t * the internal subset or an empty string if it is not present\n\t * @returns {DocumentType}\n\t * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.\n\t * @throws {DOMException}\n\t * With code:\n\t *\n\t * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name\n\t * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.\n\t * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.\n\t * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature\n\t * \"XML\" and the language exposed through the Document does not support XML Namespaces (such\n\t * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).\n\t * @since DOM Level 2.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType\n\t *      MDN\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living\n\t *      Standard\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM\n\t *      Level 3 Core\n\t * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM\n\t *      Level 2 Core\n\t * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050\n\t * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset\n\t * @prettierignore\n\t */\n\tcreateDocumentType: function (qualifiedName, publicId, systemId, internalSubset) {\n\t\tvalidateQualifiedName(qualifiedName);\n\t\tvar node = new DocumentType(PDC);\n\t\tnode.name = qualifiedName;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.publicId = publicId || '';\n\t\tnode.systemId = systemId || '';\n\t\tnode.internalSubset = internalSubset || '';\n\t\tnode.childNodes = new NodeList();\n\n\t\treturn node;\n\t},\n\t/**\n\t * Returns an HTML document, that might already have a basic DOM structure.\n\t *\n\t * __It behaves slightly different from the description in the living standard__:\n\t * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are\n\t * omitted)\n\t * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n\t *\n\t * @param {string | false} [title]\n\t * A string containing the title to give the new HTML document.\n\t * @returns {Document}\n\t * The HTML document.\n\t * @since WHATWG Living Standard.\n\t * @see {@link #createDocument}\n\t * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument\n\t * @see https://dom.spec.whatwg.org/#html-document\n\t */\n\tcreateHTMLDocument: function (title) {\n\t\tvar doc = new Document(PDC, { contentType: MIME_TYPE.HTML });\n\t\tdoc.implementation = this;\n\t\tdoc.childNodes = new NodeList();\n\t\tif (title !== false) {\n\t\t\tdoc.doctype = this.createDocumentType('html');\n\t\t\tdoc.doctype.ownerDocument = doc;\n\t\t\tdoc.appendChild(doc.doctype);\n\t\t\tvar htmlNode = doc.createElement('html');\n\t\t\tdoc.appendChild(htmlNode);\n\t\t\tvar headNode = doc.createElement('head');\n\t\t\thtmlNode.appendChild(headNode);\n\t\t\tif (typeof title === 'string') {\n\t\t\t\tvar titleNode = doc.createElement('title');\n\t\t\t\ttitleNode.appendChild(doc.createTextNode(title));\n\t\t\t\theadNode.appendChild(titleNode);\n\t\t\t}\n\t\t\thtmlNode.appendChild(doc.createElement('body'));\n\t\t}\n\t\treturn doc;\n\t},\n};\n\n/**\n * The DOM Node interface is an abstract base class upon which many other DOM API objects are\n * based, thus letting those object types to be used similarly and often interchangeably. As an\n * abstract class, there is no such thing as a plain Node object. All objects that implement\n * Node functionality are based on one of its subclasses. Most notable are Document, Element,\n * and DocumentFragment.\n *\n * In addition, every kind of DOM node is represented by an interface based on Node. These\n * include Attr, CharacterData (which Text, Comment, CDATASection and ProcessingInstruction are\n * all based on), and DocumentType.\n *\n * In some cases, a particular feature of the base Node interface may not apply to one of its\n * child interfaces; in that case, the inheriting node may return null or throw an exception,\n * depending on circumstances. For example, attempting to add children to a node type that\n * cannot have children will throw an exception.\n *\n * **This behavior is slightly different from the in the specs**:\n * - unimplemented interfaces: `EventTarget`\n *\n * @class\n * @abstract\n * @param {Symbol} symbol\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n * @see https://dom.spec.whatwg.org/#node\n * @prettierignore\n */\nfunction Node(symbol) {\n\tcheckSymbol(symbol);\n}\n\nNode.prototype = {\n\t/**\n\t * The first child of this node.\n\t *\n\t * @type {Node | null}\n\t */\n\tfirstChild: null,\n\t/**\n\t * The last child of this node.\n\t *\n\t * @type {Node | null}\n\t */\n\tlastChild: null,\n\t/**\n\t * The previous sibling of this node.\n\t *\n\t * @type {Node | null}\n\t */\n\tpreviousSibling: null,\n\t/**\n\t * The next sibling of this node.\n\t *\n\t * @type {Node | null}\n\t */\n\tnextSibling: null,\n\t/**\n\t * The parent node of this node.\n\t *\n\t * @type {Node | null}\n\t */\n\tparentNode: null,\n\t/**\n\t * The parent element of this node.\n\t *\n\t * @type {Element | null}\n\t */\n\tget parentElement() {\n\t\treturn this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;\n\t},\n\t/**\n\t * The child nodes of this node.\n\t *\n\t * @type {NodeList}\n\t */\n\tchildNodes: null,\n\t/**\n\t * The document object associated with this node.\n\t *\n\t * @type {Document | null}\n\t */\n\townerDocument: null,\n\t/**\n\t * The value of this node.\n\t *\n\t * @type {string | null}\n\t */\n\tnodeValue: null,\n\t/**\n\t * The namespace URI of this node.\n\t *\n\t * @type {string | null}\n\t */\n\tnamespaceURI: null,\n\t/**\n\t * The prefix of the namespace for this node.\n\t *\n\t * @type {string | null}\n\t */\n\tprefix: null,\n\t/**\n\t * The local part of the qualified name of this node.\n\t *\n\t * @type {string | null}\n\t */\n\tlocalName: null,\n\t/**\n\t * The baseURI is currently always `about:blank`,\n\t * since that's what happens when you create a document from scratch.\n\t *\n\t * @type {'about:blank'}\n\t */\n\tbaseURI: 'about:blank',\n\t/**\n\t * Is true if this node is part of a document.\n\t *\n\t * @type {boolean}\n\t */\n\tget isConnected() {\n\t\tvar rootNode = this.getRootNode();\n\t\treturn rootNode && rootNode.nodeType === rootNode.DOCUMENT_NODE;\n\t},\n\t/**\n\t * Checks whether `other` is an inclusive descendant of this node.\n\t *\n\t * @param {Node | null | undefined} other\n\t * The node to check.\n\t * @returns {boolean}\n\t * True if `other` is an inclusive descendant of this node; false otherwise.\n\t * @see https://dom.spec.whatwg.org/#dom-node-contains\n\t */\n\tcontains: function (other) {\n\t\tif (!other) return false;\n\t\tvar parent = other;\n\t\tdo {\n\t\t\tif (this === parent) return true;\n\t\t\tparent = other.parentNode;\n\t\t} while (parent);\n\t\treturn false;\n\t},\n\t/**\n\t * @typedef GetRootNodeOptions\n\t * @property {boolean} [composed=false]\n\t */\n\t/**\n\t * Searches for the root node of this node.\n\t *\n\t * **This behavior is slightly different from the in the specs**:\n\t * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.\n\t *\n\t * @param {GetRootNodeOptions} [options]\n\t * @returns {Node}\n\t * Root node.\n\t * @see https://dom.spec.whatwg.org/#dom-node-getrootnode\n\t * @see https://dom.spec.whatwg.org/#concept-shadow-including-root\n\t */\n\tgetRootNode: function (options) {\n\t\tvar parent = this;\n\t\tdo {\n\t\t\tif (!parent.parentNode) {\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t\tparent = parent.parentNode;\n\t\t} while (parent);\n\t},\n\t/**\n\t * Checks whether the given node is equal to this node.\n\t *\n\t * @param {Node} [otherNode]\n\t * @see https://dom.spec.whatwg.org/#concept-node-equals\n\t */\n\tisEqualNode: function (otherNode) {\n\t\tif (!otherNode) return false;\n\n\t\tif (this.nodeType !== otherNode.nodeType) return false;\n\n\t\tswitch (this.nodeType) {\n\t\t\tcase this.DOCUMENT_TYPE_NODE:\n\t\t\t\tif (this.name !== otherNode.name) return false;\n\t\t\t\tif (this.publicId !== otherNode.publicId) return false;\n\t\t\t\tif (this.systemId !== otherNode.systemId) return false;\n\t\t\t\tbreak;\n\t\t\tcase this.ELEMENT_NODE:\n\t\t\t\tif (this.namespaceURI !== otherNode.namespaceURI) return false;\n\t\t\t\tif (this.prefix !== otherNode.prefix) return false;\n\t\t\t\tif (this.localName !== otherNode.localName) return false;\n\t\t\t\tif (this.attributes.length !== otherNode.attributes.length) return false;\n\t\t\t\tfor (var i = 0; i < this.attributes.length; i++) {\n\t\t\t\t\tvar attr = this.attributes.item(i);\n\t\t\t\t\tif (!attr.isEqualNode(otherNode.getAttributeNodeNS(attr.namespaceURI, attr.localName))) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase this.ATTRIBUTE_NODE:\n\t\t\t\tif (this.namespaceURI !== otherNode.namespaceURI) return false;\n\t\t\t\tif (this.localName !== otherNode.localName) return false;\n\t\t\t\tif (this.value !== otherNode.value) return false;\n\n\t\t\t\tbreak;\n\t\t\tcase this.PROCESSING_INSTRUCTION_NODE:\n\t\t\t\tif (this.target !== otherNode.target || this.data !== otherNode.data) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase this.TEXT_NODE:\n\t\t\tcase this.COMMENT_NODE:\n\t\t\t\tif (this.data !== otherNode.data) return false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (this.childNodes.length !== otherNode.childNodes.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (var i = 0; i < this.childNodes.length; i++) {\n\t\t\tif (!this.childNodes[i].isEqualNode(otherNode.childNodes[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\t/**\n\t * Checks whether or not the given node is this node.\n\t *\n\t * @param {Node} [otherNode]\n\t */\n\tisSameNode: function (otherNode) {\n\t\treturn this === otherNode;\n\t},\n\t/**\n\t * Inserts a node before a reference node as a child of this node.\n\t *\n\t * @param {Node} newChild\n\t * The new child node to be inserted.\n\t * @param {Node | null} refChild\n\t * The reference node before which newChild will be inserted.\n\t * @returns {Node}\n\t * The new child node successfully inserted.\n\t * @throws {DOMException}\n\t * Throws a DOMException if inserting the node would result in a DOM tree that is not\n\t * well-formed, or if `child` is provided but is not a child of `parent`.\n\t * See {@link _insertBefore} for more details.\n\t * @since Modified in DOM L2\n\t */\n\tinsertBefore: function (newChild, refChild) {\n\t\treturn _insertBefore(this, newChild, refChild);\n\t},\n\t/**\n\t * Replaces an old child node with a new child node within this node.\n\t *\n\t * @param {Node} newChild\n\t * The new node that is to replace the old node.\n\t * If it already exists in the DOM, it is removed from its original position.\n\t * @param {Node} oldChild\n\t * The existing child node to be replaced.\n\t * @returns {Node}\n\t * Returns the replaced child node.\n\t * @throws {DOMException}\n\t * Throws a DOMException if replacing the node would result in a DOM tree that is not\n\t * well-formed, or if `oldChild` is not a child of `this`.\n\t * This can also occur if the pre-replacement validity assertion fails.\n\t * See {@link _insertBefore}, {@link Node.removeChild}, and\n\t * {@link assertPreReplacementValidityInDocument} for more details.\n\t * @see https://dom.spec.whatwg.org/#concept-node-replace\n\t */\n\treplaceChild: function (newChild, oldChild) {\n\t\t_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n\t\tif (oldChild) {\n\t\t\tthis.removeChild(oldChild);\n\t\t}\n\t},\n\t/**\n\t * Removes an existing child node from this node.\n\t *\n\t * @param {Node} oldChild\n\t * The child node to be removed.\n\t * @returns {Node}\n\t * Returns the removed child node.\n\t * @throws {DOMException}\n\t * Throws a DOMException if `oldChild` is not a child of `this`.\n\t * See {@link _removeChild} for more details.\n\t */\n\tremoveChild: function (oldChild) {\n\t\treturn _removeChild(this, oldChild);\n\t},\n\t/**\n\t * Appends a child node to this node.\n\t *\n\t * @param {Node} newChild\n\t * The child node to be appended to this node.\n\t * If it already exists in the DOM, it is removed from its original position.\n\t * @returns {Node}\n\t * Returns the appended child node.\n\t * @throws {DOMException}\n\t * Throws a DOMException if appending the node would result in a DOM tree that is not\n\t * well-formed, or if `newChild` is not a valid Node.\n\t * See {@link insertBefore} for more details.\n\t */\n\tappendChild: function (newChild) {\n\t\treturn this.insertBefore(newChild, null);\n\t},\n\t/**\n\t * Determines whether this node has any child nodes.\n\t *\n\t * @returns {boolean}\n\t * Returns true if this node has any child nodes, and false otherwise.\n\t */\n\thasChildNodes: function () {\n\t\treturn this.firstChild != null;\n\t},\n\t/**\n\t * Creates a copy of the calling node.\n\t *\n\t * @param {boolean} deep\n\t * If true, the contents of the node are recursively copied.\n\t * If false, only the node itself (and its attributes, if it is an element) are copied.\n\t * @returns {Node}\n\t * Returns the newly created copy of the node.\n\t * @throws {DOMException}\n\t * May throw a DOMException if operations within {@link Element#setAttributeNode} or\n\t * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their\n\t * specific constraints.\n\t * @see {@link cloneNode}\n\t */\n\tcloneNode: function (deep) {\n\t\treturn cloneNode(this.ownerDocument || this, this, deep);\n\t},\n\t/**\n\t * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\n\t * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\n\t *\n\t * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`\n\t * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text\n\t * nodes.\n\t *\n\t * This method operates recursively, so it also normalizes any and all descendent nodes within\n\t * the subtree.\n\t *\n\t * @throws {DOMException}\n\t * May throw a DOMException if operations within removeChild or appendData (which are\n\t * potentially invoked in this method) do not meet their specific constraints.\n\t * @since Modified in DOM Level 2\n\t * @see {@link Node.removeChild}\n\t * @see {@link CharacterData.appendData}\n\t */\n\tnormalize: function () {\n\t\tvar child = this.firstChild;\n\t\twhile (child) {\n\t\t\tvar next = child.nextSibling;\n\t\t\tif (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\n\t\t\t\tthis.removeChild(next);\n\t\t\t\tchild.appendData(next.data);\n\t\t\t} else {\n\t\t\t\tchild.normalize();\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * Checks whether the DOM implementation implements a specific feature and its version.\n\t *\n\t * @deprecated\n\t * Since `DOMImplementation.hasFeature` is deprecated and always returns true.\n\t * @param {string} feature\n\t * The package name of the feature to test. This is the same name that can be passed to the\n\t * method `hasFeature` on `DOMImplementation`.\n\t * @param {string} version\n\t * This is the version number of the package name to test.\n\t * @returns {boolean}\n\t * Returns true in all cases in the current implementation.\n\t * @since Introduced in DOM Level 2\n\t * @see {@link DOMImplementation.hasFeature}\n\t */\n\tisSupported: function (feature, version) {\n\t\treturn this.ownerDocument.implementation.hasFeature(feature, version);\n\t},\n\t/**\n\t * Look up the prefix associated to the given namespace URI, starting from this node.\n\t * **The default namespace declarations are ignored by this method.**\n\t * See Namespace Prefix Lookup for details on the algorithm used by this method.\n\t *\n\t * **This behavior is different from the in the specs**:\n\t * - no node type specific handling\n\t * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes\n\t *\n\t * @param {string | null} namespaceURI\n\t * The namespace URI for which to find the associated prefix.\n\t * @returns {string | null}\n\t * The associated prefix, if found; otherwise, null.\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo\n\t * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix\n\t * @see https://github.com/xmldom/xmldom/issues/322\n\t * @prettierignore\n\t */\n\tlookupPrefix: function (namespaceURI) {\n\t\tvar el = this;\n\t\twhile (el) {\n\t\t\tvar map = el._nsMap;\n\t\t\t//console.dir(map)\n\t\t\tif (map) {\n\t\t\t\tfor (var n in map) {\n\t\t\t\t\tif (hasOwn(map, n) && map[n] === namespaceURI) {\n\t\t\t\t\t\treturn n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tel = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n\t\t}\n\t\treturn null;\n\t},\n\t/**\n\t * This function is used to look up the namespace URI associated with the given prefix,\n\t * starting from this node.\n\t *\n\t * **This behavior is different from the in the specs**:\n\t * - no node type specific handling\n\t * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes\n\t *\n\t * @param {string | null} prefix\n\t * The prefix for which to find the associated namespace URI.\n\t * @returns {string | null}\n\t * The associated namespace URI, if found; otherwise, null.\n\t * @since DOM Level 3\n\t * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI\n\t * @prettierignore\n\t */\n\tlookupNamespaceURI: function (prefix) {\n\t\tvar el = this;\n\t\twhile (el) {\n\t\t\tvar map = el._nsMap;\n\t\t\t//console.dir(map)\n\t\t\tif (map) {\n\t\t\t\tif (hasOwn(map, prefix)) {\n\t\t\t\t\treturn map[prefix];\n\t\t\t\t}\n\t\t\t}\n\t\t\tel = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n\t\t}\n\t\treturn null;\n\t},\n\t/**\n\t * Determines whether the given namespace URI is the default namespace.\n\t *\n\t * The function works by looking up the prefix associated with the given namespace URI. If no\n\t * prefix is found (i.e., the namespace URI is not registered in the namespace map of this\n\t * node or any of its ancestors), it returns `true`, implying the namespace URI is considered\n\t * the default.\n\t *\n\t * **This behavior is different from the in the specs**:\n\t * - no node type specific handling\n\t * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes\n\t *\n\t * @param {string | null} namespaceURI\n\t * The namespace URI to be checked.\n\t * @returns {boolean}\n\t * Returns true if the given namespace URI is the default namespace, false otherwise.\n\t * @since DOM Level 3\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace\n\t * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace\n\t * @prettierignore\n\t */\n\tisDefaultNamespace: function (namespaceURI) {\n\t\tvar prefix = this.lookupPrefix(namespaceURI);\n\t\treturn prefix == null;\n\t},\n\t/**\n\t * Compares the reference node with a node with regard to their position in the document and\n\t * according to the document order.\n\t *\n\t * @param {Node} other\n\t * The node to compare the reference node to.\n\t * @returns {number}\n\t * Returns how the node is positioned relatively to the reference node according to the\n\t * bitmask. 0 if reference node and given node are the same.\n\t * @since DOM Level 3\n\t * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare\n\t * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition\n\t */\n\tcompareDocumentPosition: function (other) {\n\t\tif (this === other) return 0;\n\t\tvar node1 = other;\n\t\tvar node2 = this;\n\t\tvar attr1 = null;\n\t\tvar attr2 = null;\n\t\tif (node1 instanceof Attr) {\n\t\t\tattr1 = node1;\n\t\t\tnode1 = attr1.ownerElement;\n\t\t}\n\t\tif (node2 instanceof Attr) {\n\t\t\tattr2 = node2;\n\t\t\tnode2 = attr2.ownerElement;\n\t\t\tif (attr1 && node1 && node2 === node1) {\n\t\t\t\tfor (var i = 0, attr; (attr = node2.attributes[i]); i++) {\n\t\t\t\t\tif (attr === attr1)\n\t\t\t\t\t\treturn DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n\t\t\t\t\tif (attr === attr2)\n\t\t\t\t\t\treturn DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!node1 || !node2 || node2.ownerDocument !== node1.ownerDocument) {\n\t\t\treturn (\n\t\t\t\tDocumentPosition.DOCUMENT_POSITION_DISCONNECTED +\n\t\t\t\tDocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC +\n\t\t\t\t(docGUID(node2.ownerDocument) > docGUID(node1.ownerDocument)\n\t\t\t\t\t? DocumentPosition.DOCUMENT_POSITION_FOLLOWING\n\t\t\t\t\t: DocumentPosition.DOCUMENT_POSITION_PRECEDING)\n\t\t\t);\n\t\t}\n\t\tif (attr2 && node1 === node2) {\n\t\t\treturn DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n\t\t}\n\t\tif (attr1 && node1 === node2) {\n\t\t\treturn DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n\t\t}\n\n\t\tvar chain1 = [];\n\t\tvar ancestor1 = node1.parentNode;\n\t\twhile (ancestor1) {\n\t\t\tif (!attr2 && ancestor1 === node2) {\n\t\t\t\treturn DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n\t\t\t}\n\t\t\tchain1.push(ancestor1);\n\t\t\tancestor1 = ancestor1.parentNode;\n\t\t}\n\t\tchain1.reverse();\n\n\t\tvar chain2 = [];\n\t\tvar ancestor2 = node2.parentNode;\n\t\twhile (ancestor2) {\n\t\t\tif (!attr1 && ancestor2 === node1) {\n\t\t\t\treturn DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n\t\t\t}\n\t\t\tchain2.push(ancestor2);\n\t\t\tancestor2 = ancestor2.parentNode;\n\t\t}\n\t\tchain2.reverse();\n\n\t\tvar ca = commonAncestor(chain1, chain2);\n\t\tfor (var n in ca.childNodes) {\n\t\t\tvar child = ca.childNodes[n];\n\t\t\tif (child === node2) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n\t\t\tif (child === node1) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n\t\t\tif (chain2.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;\n\t\t\tif (chain1.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;\n\t\t}\n\t\treturn 0;\n\t},\n};\n\n/**\n * Encodes special XML characters to their corresponding entities.\n *\n * @param {string} c\n * The character to be encoded.\n * @returns {string}\n * The encoded character.\n * @private\n */\nfunction _xmlEncoder(c) {\n\treturn (\n\t\t(c == '<' && '&lt;') || (c == '>' && '&gt;') || (c == '&' && '&amp;') || (c == '\"' && '&quot;') || '&#' + c.charCodeAt() + ';'\n\t);\n}\n\ncopy(NodeType, Node);\ncopy(NodeType, Node.prototype);\ncopy(DocumentPosition, Node);\ncopy(DocumentPosition, Node.prototype);\n\n/**\n * @param callback\n * Return true for continue,false for break.\n * @returns\n * boolean true: break visit;\n */\nfunction _visitNode(node, callback) {\n\tif (callback(node)) {\n\t\treturn true;\n\t}\n\tif ((node = node.firstChild)) {\n\t\tdo {\n\t\t\tif (_visitNode(node, callback)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} while ((node = node.nextSibling));\n\t}\n}\n\n/**\n * @typedef DocumentOptions\n * @property {string} [contentType=MIME_TYPE.XML_APPLICATION]\n */\n/**\n * The Document interface describes the common properties and methods for any kind of document.\n *\n * It should usually be created using `new DOMImplementation().createDocument(...)`\n * or `new DOMImplementation().createHTMLDocument(...)`.\n *\n * The constructor is considered a private API and offers to initially set the `contentType`\n * property via it's options parameter.\n *\n * @class\n * @param {Symbol} symbol\n * @param {DocumentOptions} [options]\n * @augments Node\n * @private\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document\n * @see https://dom.spec.whatwg.org/#interface-document\n */\nfunction Document(symbol, options) {\n\tcheckSymbol(symbol);\n\n\tvar opt = options || {};\n\tthis.ownerDocument = this;\n\t/**\n\t * The mime type of the document is determined at creation time and can not be modified.\n\t *\n\t * @type {string}\n\t * @see https://dom.spec.whatwg.org/#concept-document-content-type\n\t * @see {@link DOMImplementation}\n\t * @see {@link MIME_TYPE}\n\t * @readonly\n\t */\n\tthis.contentType = opt.contentType || MIME_TYPE.XML_APPLICATION;\n\t/**\n\t * @type {'html' | 'xml'}\n\t * @see https://dom.spec.whatwg.org/#concept-document-type\n\t * @see {@link DOMImplementation}\n\t * @readonly\n\t */\n\tthis.type = isHTMLMimeType(this.contentType) ? 'html' : 'xml';\n}\n\n/**\n * Updates the namespace mapping of an element when a new attribute is added.\n *\n * @param {Document} doc\n * The document that the element belongs to.\n * @param {Element} el\n * The element to which the attribute is being added.\n * @param {Attr} newAttr\n * The new attribute being added.\n * @private\n */\nfunction _onAddAttribute(doc, el, newAttr) {\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI;\n\tif (ns === NAMESPACE.XMLNS) {\n\t\t//update namespace\n\t\tel._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\n\t}\n}\n\n/**\n * Updates the namespace mapping of an element when an attribute is removed.\n *\n * @param {Document} doc\n * The document that the element belongs to.\n * @param {Element} el\n * The element from which the attribute is being removed.\n * @param {Attr} newAttr\n * The attribute being removed.\n * @param {boolean} remove\n * Indicates whether the attribute is to be removed.\n * @private\n */\nfunction _onRemoveAttribute(doc, el, newAttr, remove) {\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI;\n\tif (ns === NAMESPACE.XMLNS) {\n\t\t//update namespace\n\t\tdelete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\n\t}\n}\n\n/**\n * Updates `parent.childNodes`, adjusting the indexed items and its `length`.\n * If `newChild` is provided and has no nextSibling, it will be appended.\n * Otherwise, it's assumed that an item has been removed or inserted,\n * and `parent.firstNode` and its `.nextSibling` to re-indexing all child nodes of `parent`.\n *\n * @param {Document} doc\n * The parent document of `el`.\n * @param {Node} parent\n * The parent node whose childNodes list needs to be updated.\n * @param {Node} [newChild]\n * The new child node to be appended. If not provided, the function assumes a node has been\n * removed.\n * @private\n */\nfunction _onUpdateChild(doc, parent, newChild) {\n\tif (doc && doc._inc) {\n\t\tdoc._inc++;\n\t\tvar childNodes = parent.childNodes;\n\t\t// assumes nextSibling and previousSibling were already configured upfront\n\t\tif (newChild && !newChild.nextSibling) {\n\t\t\t// if an item has been appended, we only need to update the last index and the length\n\t\t\tchildNodes[childNodes.length++] = newChild;\n\t\t} else {\n\t\t\t// otherwise we need to reindex all items,\n\t\t\t// which can take a while when processing nodes with a lot of children\n\t\t\tvar child = parent.firstChild;\n\t\t\tvar i = 0;\n\t\t\twhile (child) {\n\t\t\t\tchildNodes[i++] = child;\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t\tchildNodes.length = i;\n\t\t\tdelete childNodes[childNodes.length];\n\t\t}\n\t}\n}\n\n/**\n * Removes the connections between `parentNode` and `child`\n * and any existing `child.previousSibling` or `child.nextSibling`.\n *\n * @param {Node} parentNode\n * The parent node from which the child node is to be removed.\n * @param {Node} child\n * The child node to be removed from the parentNode.\n * @returns {Node}\n * Returns the child node that was removed.\n * @throws {DOMException}\n * With code:\n * - {@link DOMException.NOT_FOUND_ERR} If the parentNode is not the parent of the child node.\n * @private\n * @see https://github.com/xmldom/xmldom/issues/135\n * @see https://github.com/xmldom/xmldom/issues/145\n */\nfunction _removeChild(parentNode, child) {\n\tif (parentNode !== child.parentNode) {\n\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, \"child's parent is not parent\");\n\t}\n\tvar oldPreviousSibling = child.previousSibling;\n\tvar oldNextSibling = child.nextSibling;\n\tif (oldPreviousSibling) {\n\t\toldPreviousSibling.nextSibling = oldNextSibling;\n\t} else {\n\t\tparentNode.firstChild = oldNextSibling;\n\t}\n\tif (oldNextSibling) {\n\t\toldNextSibling.previousSibling = oldPreviousSibling;\n\t} else {\n\t\tparentNode.lastChild = oldPreviousSibling;\n\t}\n\t_onUpdateChild(parentNode.ownerDocument, parentNode);\n\tchild.parentNode = null;\n\tchild.previousSibling = null;\n\tchild.nextSibling = null;\n\treturn child;\n}\n\n/**\n * Returns `true` if `node` can be a parent for insertion.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction hasValidParentNodeType(node) {\n\treturn (\n\t\tnode &&\n\t\t(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)\n\t);\n}\n\n/**\n * Returns `true` if `node` can be inserted according to it's `nodeType`.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction hasInsertableNodeType(node) {\n\treturn (\n\t\tnode &&\n\t\t(node.nodeType === Node.CDATA_SECTION_NODE ||\n\t\t\tnode.nodeType === Node.COMMENT_NODE ||\n\t\t\tnode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||\n\t\t\tnode.nodeType === Node.DOCUMENT_TYPE_NODE ||\n\t\t\tnode.nodeType === Node.ELEMENT_NODE ||\n\t\t\tnode.nodeType === Node.PROCESSING_INSTRUCTION_NODE ||\n\t\t\tnode.nodeType === Node.TEXT_NODE)\n\t);\n}\n\n/**\n * Returns true if `node` is a DOCTYPE node.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isDocTypeNode(node) {\n\treturn node && node.nodeType === Node.DOCUMENT_TYPE_NODE;\n}\n\n/**\n * Returns true if the node is an element.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isElementNode(node) {\n\treturn node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Returns true if `node` is a text node.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction isTextNode(node) {\n\treturn node && node.nodeType === Node.TEXT_NODE;\n}\n\n/**\n * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n * according to the presence and position of a doctype node on the same level.\n *\n * @param {Document} doc\n * The document node.\n * @param {Node} child\n * The node that would become the nextSibling if the element would be inserted.\n * @returns {boolean}\n * `true` if an element can be inserted before child.\n * @private\n */\nfunction isElementInsertionPossible(doc, child) {\n\tvar parentChildNodes = doc.childNodes || [];\n\tif (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {\n\t\treturn false;\n\t}\n\tvar docTypeNode = find(parentChildNodes, isDocTypeNode);\n\treturn !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n}\n\n/**\n * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n * according to the presence and position of a doctype node on the same level.\n *\n * @param {Node} doc\n * The document node.\n * @param {Node} child\n * The node that would become the nextSibling if the element would be inserted.\n * @returns {boolean}\n * `true` if an element can be inserted before child.\n * @private\n */\nfunction isElementReplacementPossible(doc, child) {\n\tvar parentChildNodes = doc.childNodes || [];\n\n\tfunction hasElementChildThatIsNotChild(node) {\n\t\treturn isElementNode(node) && node !== child;\n\t}\n\n\tif (find(parentChildNodes, hasElementChildThatIsNotChild)) {\n\t\treturn false;\n\t}\n\tvar docTypeNode = find(parentChildNodes, isDocTypeNode);\n\treturn !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n}\n\n/**\n * Asserts pre-insertion validity of a node into a parent before a child.\n * Throws errors for invalid node combinations that would result in an ill-formed DOM.\n *\n * @param {Node} parent\n * The parent node to insert `node` into.\n * @param {Node} node\n * The node to insert.\n * @param {Node | null} child\n * The node that should become the `nextSibling` of `node`. If null, no sibling is considered.\n * @throws {DOMException}\n * With code:\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `parent` is not a Document,\n * DocumentFragment, or Element node.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a host-including inclusive\n * ancestor of `parent`. (Currently not implemented)\n * - {@link DOMException.NOT_FOUND_ERR} If `child` is non-null and its `parent` is not\n * `parent`.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is not a DocumentFragment,\n * DocumentType, Element, or CharacterData node.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If either `node` is a Text node and `parent` is\n * a document, or if `node` is a doctype and `parent` is not a document.\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreInsertionValidity1to5(parent, node, child) {\n\t// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a \"HierarchyRequestError\" DOMException.\n\tif (!hasValidParentNodeType(parent)) {\n\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);\n\t}\n\t// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a \"HierarchyRequestError\" DOMException.\n\t// not implemented!\n\t// 3. If `child` is non-null and its parent is not `parent`, then throw a \"NotFoundError\" DOMException.\n\tif (child && child.parentNode !== parent) {\n\t\tthrow new DOMException(DOMException.NOT_FOUND_ERR, 'child not in parent');\n\t}\n\tif (\n\t\t// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a \"HierarchyRequestError\" DOMException.\n\t\t!hasInsertableNodeType(node) ||\n\t\t// 5. If either `node` is a Text node and `parent` is a document,\n\t\t// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0\n\t\t// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)\n\t\t// or `node` is a doctype and `parent` is not a document, then throw a \"HierarchyRequestError\" DOMException.\n\t\t(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)\n\t) {\n\t\tthrow new DOMException(\n\t\t\tDOMException.HIERARCHY_REQUEST_ERR,\n\t\t\t'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType\n\t\t);\n\t}\n}\n\n/**\n * Asserts pre-insertion validity of a node into a document before a child.\n * Throws errors for invalid node combinations that would result in an ill-formed DOM.\n *\n * @param {Document} parent\n * The parent node to insert `node` into.\n * @param {Node} node\n * The node to insert.\n * @param {Node | undefined} child\n * The node that should become the `nextSibling` of `node`. If undefined, no sibling is\n * considered.\n * @returns {Node}\n * @throws {DOMException}\n * With code:\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with more than\n * one element child or has a Text node child.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentFragment with one\n * element child and either `parent` has an element child, `child` is a doctype, or `child` is\n * non-null and a doctype is following `child`.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is an Element and `parent` has an\n * element child, `child` is a doctype, or `child` is non-null and a doctype is following\n * `child`.\n * - {@link DOMException.HIERARCHY_REQUEST_ERR} If `node` is a DocumentType and `parent` has a\n * doctype child, `child` is non-null and an element is preceding `child`, or `child` is null\n * and `parent` has an element child.\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreInsertionValidityInDocument(parent, node, child) {\n\tvar parentChildNodes = parent.childNodes || [];\n\tvar nodeChildNodes = node.childNodes || [];\n\n\t// DocumentFragment\n\tif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\tvar nodeChildElements = nodeChildNodes.filter(isElementNode);\n\t\t// If node has more than one element child or has a Text node child.\n\t\tif (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n\t\t}\n\t\t// Otherwise, if `node` has one element child and either `parent` has an element child,\n\t\t// `child` is a doctype, or `child` is non-null and a doctype is following `child`.\n\t\tif (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n\t\t}\n\t}\n\t// Element\n\tif (isElementNode(node)) {\n\t\t// `parent` has an element child, `child` is a doctype,\n\t\t// or `child` is non-null and a doctype is following `child`.\n\t\tif (!isElementInsertionPossible(parent, child)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n\t\t}\n\t}\n\t// DocumentType\n\tif (isDocTypeNode(node)) {\n\t\t// `parent` has a doctype child,\n\t\tif (find(parentChildNodes, isDocTypeNode)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n\t\t}\n\t\tvar parentElementChild = find(parentChildNodes, isElementNode);\n\t\t// `child` is non-null and an element is preceding `child`,\n\t\tif (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n\t\t}\n\t\t// or `child` is null and `parent` has an element child.\n\t\tif (!child && parentElementChild) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');\n\t\t}\n\t}\n}\n\n/**\n * @param {Document} parent\n * The parent node to insert `node` into.\n * @param {Node} node\n * The node to insert.\n * @param {Node | undefined} child\n * the node that should become the `nextSibling` of `node`\n * @returns {Node}\n * @throws {DOMException}\n * For several node combinations that would create a DOM that is not well-formed.\n * @throws {DOMException}\n * If `child` is provided but is not a child of `parent`.\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n * @see https://dom.spec.whatwg.org/#concept-node-replace\n */\nfunction assertPreReplacementValidityInDocument(parent, node, child) {\n\tvar parentChildNodes = parent.childNodes || [];\n\tvar nodeChildNodes = node.childNodes || [];\n\n\t// DocumentFragment\n\tif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\tvar nodeChildElements = nodeChildNodes.filter(isElementNode);\n\t\t// If `node` has more than one element child or has a Text node child.\n\t\tif (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n\t\t}\n\t\t// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.\n\t\tif (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n\t\t}\n\t}\n\t// Element\n\tif (isElementNode(node)) {\n\t\t// `parent` has an element child that is not `child` or a doctype is following `child`.\n\t\tif (!isElementReplacementPossible(parent, child)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n\t\t}\n\t}\n\t// DocumentType\n\tif (isDocTypeNode(node)) {\n\t\tfunction hasDoctypeChildThatIsNotChild(node) {\n\t\t\treturn isDocTypeNode(node) && node !== child;\n\t\t}\n\n\t\t// `parent` has a doctype child that is not `child`,\n\t\tif (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n\t\t}\n\t\tvar parentElementChild = find(parentChildNodes, isElementNode);\n\t\t// or an element is preceding `child`.\n\t\tif (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n\t\t\tthrow new DOMException(DOMException.HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n\t\t}\n\t}\n}\n\n/**\n * Inserts a node into a parent node before a child node.\n *\n * @param {Node} parent\n * The parent node to insert the node into.\n * @param {Node} node\n * The node to insert into the parent.\n * @param {Node | null} child\n * The node that should become the next sibling of the node.\n * If null, the function inserts the node at the end of the children of the parent node.\n * @param {Function} [_inDocumentAssertion]\n * An optional function to check pre-insertion validity if parent is a document node.\n * Defaults to {@link assertPreInsertionValidityInDocument}\n * @returns {Node}\n * Returns the inserted node.\n * @throws {DOMException}\n * Throws a DOMException if inserting the node would result in a DOM tree that is not\n * well-formed. See {@link assertPreInsertionValidity1to5},\n * {@link assertPreInsertionValidityInDocument}.\n * @throws {DOMException}\n * Throws a DOMException if child is provided but is not a child of the parent. See\n * {@link Node.removeChild}\n * @private\n * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n */\nfunction _insertBefore(parent, node, child, _inDocumentAssertion) {\n\t// To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n\tassertPreInsertionValidity1to5(parent, node, child);\n\n\t// If parent is a document, and any of the statements below, switched on the interface node implements,\n\t// are true, then throw a \"HierarchyRequestError\" DOMException.\n\tif (parent.nodeType === Node.DOCUMENT_NODE) {\n\t\t(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);\n\t}\n\n\tvar cp = node.parentNode;\n\tif (cp) {\n\t\tcp.removeChild(node); //remove and update\n\t}\n\tif (node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n\t\tvar newFirst = node.firstChild;\n\t\tif (newFirst == null) {\n\t\t\treturn node;\n\t\t}\n\t\tvar newLast = node.lastChild;\n\t} else {\n\t\tnewFirst = newLast = node;\n\t}\n\tvar pre = child ? child.previousSibling : parent.lastChild;\n\n\tnewFirst.previousSibling = pre;\n\tnewLast.nextSibling = child;\n\n\tif (pre) {\n\t\tpre.nextSibling = newFirst;\n\t} else {\n\t\tparent.firstChild = newFirst;\n\t}\n\tif (child == null) {\n\t\tparent.lastChild = newLast;\n\t} else {\n\t\tchild.previousSibling = newLast;\n\t}\n\tdo {\n\t\tnewFirst.parentNode = parent;\n\t} while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\n\t_onUpdateChild(parent.ownerDocument || parent, parent, node);\n\tif (node.nodeType == DOCUMENT_FRAGMENT_NODE) {\n\t\tnode.firstChild = node.lastChild = null;\n\t}\n\n\treturn node;\n}\n\nDocument.prototype = {\n\t/**\n\t * The implementation that created this document.\n\t *\n\t * @type DOMImplementation\n\t * @readonly\n\t */\n\timplementation: null,\n\tnodeName: '#document',\n\tnodeType: DOCUMENT_NODE,\n\t/**\n\t * The DocumentType node of the document.\n\t *\n\t * @type DocumentType\n\t * @readonly\n\t */\n\tdoctype: null,\n\tdocumentElement: null,\n\t_inc: 1,\n\n\tinsertBefore: function (newChild, refChild) {\n\t\t//raises\n\t\tif (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n\t\t\tvar child = newChild.firstChild;\n\t\t\twhile (child) {\n\t\t\t\tvar next = child.nextSibling;\n\t\t\t\tthis.insertBefore(child, refChild);\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t\treturn newChild;\n\t\t}\n\t\t_insertBefore(this, newChild, refChild);\n\t\tnewChild.ownerDocument = this;\n\t\tif (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {\n\t\t\tthis.documentElement = newChild;\n\t\t}\n\n\t\treturn newChild;\n\t},\n\tremoveChild: function (oldChild) {\n\t\tvar removed = _removeChild(this, oldChild);\n\t\tif (removed === this.documentElement) {\n\t\t\tthis.documentElement = null;\n\t\t}\n\t\treturn removed;\n\t},\n\treplaceChild: function (newChild, oldChild) {\n\t\t//raises\n\t\t_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n\t\tnewChild.ownerDocument = this;\n\t\tif (oldChild) {\n\t\t\tthis.removeChild(oldChild);\n\t\t}\n\t\tif (isElementNode(newChild)) {\n\t\t\tthis.documentElement = newChild;\n\t\t}\n\t},\n\t// Introduced in DOM Level 2:\n\timportNode: function (importedNode, deep) {\n\t\treturn importNode(this, importedNode, deep);\n\t},\n\t// Introduced in DOM Level 2:\n\tgetElementById: function (id) {\n\t\tvar rtv = null;\n\t\t_visitNode(this.documentElement, function (node) {\n\t\t\tif (node.nodeType == ELEMENT_NODE) {\n\t\t\t\tif (node.getAttribute('id') == id) {\n\t\t\t\t\trtv = node;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn rtv;\n\t},\n\n\t/**\n\t * Creates a new `Element` that is owned by this `Document`.\n\t * In HTML Documents `localName` is the lower cased `tagName`,\n\t * otherwise no transformation is being applied.\n\t * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.\n\t *\n\t * __This implementation differs from the specification:__ - The provided name is not checked\n\t * against the `Name` production,\n\t * so no related error will be thrown.\n\t * - There is no interface `HTMLElement`, it is always an `Element`.\n\t * - There is no support for a second argument to indicate using custom elements.\n\t *\n\t * @param {string} tagName\n\t * @returns {Element}\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\n\t * @see https://dom.spec.whatwg.org/#dom-document-createelement\n\t * @see https://dom.spec.whatwg.org/#concept-create-element\n\t */\n\tcreateElement: function (tagName) {\n\t\tvar node = new Element(PDC);\n\t\tnode.ownerDocument = this;\n\t\tif (this.type === 'html') {\n\t\t\ttagName = tagName.toLowerCase();\n\t\t}\n\t\tif (hasDefaultHTMLNamespace(this.contentType)) {\n\t\t\tnode.namespaceURI = NAMESPACE.HTML;\n\t\t}\n\t\tnode.nodeName = tagName;\n\t\tnode.tagName = tagName;\n\t\tnode.localName = tagName;\n\t\tnode.childNodes = new NodeList();\n\t\tvar attrs = (node.attributes = new NamedNodeMap());\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\t/**\n\t * @returns {DocumentFragment}\n\t */\n\tcreateDocumentFragment: function () {\n\t\tvar node = new DocumentFragment(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\treturn node;\n\t},\n\t/**\n\t * @param {string} data\n\t * @returns {Text}\n\t */\n\tcreateTextNode: function (data) {\n\t\tvar node = new Text(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\tnode.appendData(data);\n\t\treturn node;\n\t},\n\t/**\n\t * @param {string} data\n\t * @returns {Comment}\n\t */\n\tcreateComment: function (data) {\n\t\tvar node = new Comment(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\tnode.appendData(data);\n\t\treturn node;\n\t},\n\t/**\n\t * @param {string} data\n\t * @returns {CDATASection}\n\t */\n\tcreateCDATASection: function (data) {\n\t\tvar node = new CDATASection(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\tnode.appendData(data);\n\t\treturn node;\n\t},\n\t/**\n\t * @param {string} target\n\t * @param {string} data\n\t * @returns {ProcessingInstruction}\n\t */\n\tcreateProcessingInstruction: function (target, data) {\n\t\tvar node = new ProcessingInstruction(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\tnode.nodeName = node.target = target;\n\t\tnode.nodeValue = node.data = data;\n\t\treturn node;\n\t},\n\t/**\n\t * Creates an `Attr` node that is owned by this document.\n\t * In HTML Documents `localName` is the lower cased `name`,\n\t * otherwise no transformation is being applied.\n\t *\n\t * __This implementation differs from the specification:__ - The provided name is not checked\n\t * against the `Name` production,\n\t * so no related error will be thrown.\n\t *\n\t * @param {string} name\n\t * @returns {Attr}\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute\n\t * @see https://dom.spec.whatwg.org/#dom-document-createattribute\n\t */\n\tcreateAttribute: function (name) {\n\t\tif (!g.QName_exact.test(name)) {\n\t\t\tthrow new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in name \"' + name + '\"');\n\t\t}\n\t\tif (this.type === 'html') {\n\t\t\tname = name.toLowerCase();\n\t\t}\n\t\treturn this._createAttribute(name);\n\t},\n\t_createAttribute: function (name) {\n\t\tvar node = new Attr(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\tnode.name = name;\n\t\tnode.nodeName = name;\n\t\tnode.localName = name;\n\t\tnode.specified = true;\n\t\treturn node;\n\t},\n\t/**\n\t * Creates an EntityReference object.\n\t * The current implementation does not fill the `childNodes` with those of the corresponding\n\t * `Entity`\n\t *\n\t * @deprecated\n\t * In DOM Level 4.\n\t * @param {string} name\n\t * The name of the entity to reference. No namespace well-formedness checks are performed.\n\t * @returns {EntityReference}\n\t * @throws {DOMException}\n\t * With code `INVALID_CHARACTER_ERR` when `name` is not valid.\n\t * @throws {DOMException}\n\t * with code `NOT_SUPPORTED_ERR` when the document is of type `html`\n\t * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE\n\t */\n\tcreateEntityReference: function (name) {\n\t\tif (!g.Name.test(name)) {\n\t\t\tthrow new DOMException(DOMException.INVALID_CHARACTER_ERR, 'not a valid xml name \"' + name + '\"');\n\t\t}\n\t\tif (this.type === 'html') {\n\t\t\tthrow new DOMException('document is an html document', DOMExceptionName.NotSupportedError);\n\t\t}\n\n\t\tvar node = new EntityReference(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\tnode.nodeName = name;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\t/**\n\t * @param {string} namespaceURI\n\t * @param {string} qualifiedName\n\t * @returns {Element}\n\t */\n\tcreateElementNS: function (namespaceURI, qualifiedName) {\n\t\tvar validated = validateAndExtract(namespaceURI, qualifiedName);\n\t\tvar node = new Element(PDC);\n\t\tvar attrs = (node.attributes = new NamedNodeMap());\n\t\tnode.childNodes = new NodeList();\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.tagName = qualifiedName;\n\t\tnode.namespaceURI = validated[0];\n\t\tnode.prefix = validated[1];\n\t\tnode.localName = validated[2];\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\t/**\n\t * @param {string} namespaceURI\n\t * @param {string} qualifiedName\n\t * @returns {Attr}\n\t */\n\tcreateAttributeNS: function (namespaceURI, qualifiedName) {\n\t\tvar validated = validateAndExtract(namespaceURI, qualifiedName);\n\t\tvar node = new Attr(PDC);\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.name = qualifiedName;\n\t\tnode.specified = true;\n\t\tnode.namespaceURI = validated[0];\n\t\tnode.prefix = validated[1];\n\t\tnode.localName = validated[2];\n\t\treturn node;\n\t},\n};\n_extends(Document, Node);\n\nfunction Element(symbol) {\n\tcheckSymbol(symbol);\n\n\tthis._nsMap = Object.create(null);\n}\nElement.prototype = {\n\tnodeType: ELEMENT_NODE,\n\t/**\n\t * The attributes of this element.\n\t *\n\t * @type {NamedNodeMap | null}\n\t */\n\tattributes: null,\n\tgetQualifiedName: function () {\n\t\treturn this.prefix ? this.prefix + ':' + this.localName : this.localName;\n\t},\n\t_isInHTMLDocumentAndNamespace: function () {\n\t\treturn this.ownerDocument.type === 'html' && this.namespaceURI === NAMESPACE.HTML;\n\t},\n\t/**\n\t * Implementaton of Level2 Core function hasAttributes.\n\t *\n\t * @returns {boolean}\n\t * True if attribute list is not empty.\n\t * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs\n\t */\n\thasAttributes: function () {\n\t\treturn !!(this.attributes && this.attributes.length);\n\t},\n\thasAttribute: function (name) {\n\t\treturn !!this.getAttributeNode(name);\n\t},\n\t/**\n\t * Returns elements first attribute whose qualified name is `name`, and `null`\n\t * if there is no such attribute.\n\t *\n\t * @param {string} name\n\t * @returns {string | null}\n\t */\n\tgetAttribute: function (name) {\n\t\tvar attr = this.getAttributeNode(name);\n\t\treturn attr ? attr.value : null;\n\t},\n\tgetAttributeNode: function (name) {\n\t\tif (this._isInHTMLDocumentAndNamespace()) {\n\t\t\tname = name.toLowerCase();\n\t\t}\n\t\treturn this.attributes.getNamedItem(name);\n\t},\n\t/**\n\t * Sets the value of elements first attribute whose qualified name is qualifiedName to value.\n\t *\n\t * @param {string} name\n\t * @param {string} value\n\t */\n\tsetAttribute: function (name, value) {\n\t\tif (this._isInHTMLDocumentAndNamespace()) {\n\t\t\tname = name.toLowerCase();\n\t\t}\n\t\tvar attr = this.getAttributeNode(name);\n\t\tif (attr) {\n\t\t\tattr.value = attr.nodeValue = '' + value;\n\t\t} else {\n\t\t\tattr = this.ownerDocument._createAttribute(name);\n\t\t\tattr.value = attr.nodeValue = '' + value;\n\t\t\tthis.setAttributeNode(attr);\n\t\t}\n\t},\n\tremoveAttribute: function (name) {\n\t\tvar attr = this.getAttributeNode(name);\n\t\tattr && this.removeAttributeNode(attr);\n\t},\n\tsetAttributeNode: function (newAttr) {\n\t\treturn this.attributes.setNamedItem(newAttr);\n\t},\n\tsetAttributeNodeNS: function (newAttr) {\n\t\treturn this.attributes.setNamedItemNS(newAttr);\n\t},\n\tremoveAttributeNode: function (oldAttr) {\n\t\t//console.log(this == oldAttr.ownerElement)\n\t\treturn this.attributes.removeNamedItem(oldAttr.nodeName);\n\t},\n\t//get real attribute name,and remove it by removeAttributeNode\n\tremoveAttributeNS: function (namespaceURI, localName) {\n\t\tvar old = this.getAttributeNodeNS(namespaceURI, localName);\n\t\told && this.removeAttributeNode(old);\n\t},\n\n\thasAttributeNS: function (namespaceURI, localName) {\n\t\treturn this.getAttributeNodeNS(namespaceURI, localName) != null;\n\t},\n\t/**\n\t * Returns elements attribute whose namespace is `namespaceURI` and local name is\n\t * `localName`,\n\t * or `null` if there is no such attribute.\n\t *\n\t * @param {string} namespaceURI\n\t * @param {string} localName\n\t * @returns {string | null}\n\t */\n\tgetAttributeNS: function (namespaceURI, localName) {\n\t\tvar attr = this.getAttributeNodeNS(namespaceURI, localName);\n\t\treturn attr ? attr.value : null;\n\t},\n\t/**\n\t * Sets the value of elements attribute whose namespace is `namespaceURI` and local name is\n\t * `localName` to value.\n\t *\n\t * @param {string} namespaceURI\n\t * @param {string} qualifiedName\n\t * @param {string} value\n\t * @see https://dom.spec.whatwg.org/#dom-element-setattributens\n\t */\n\tsetAttributeNS: function (namespaceURI, qualifiedName, value) {\n\t\tvar validated = validateAndExtract(namespaceURI, qualifiedName);\n\t\tvar localName = validated[2];\n\t\tvar attr = this.getAttributeNodeNS(namespaceURI, localName);\n\t\tif (attr) {\n\t\t\tattr.value = attr.nodeValue = '' + value;\n\t\t} else {\n\t\t\tattr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n\t\t\tattr.value = attr.nodeValue = '' + value;\n\t\t\tthis.setAttributeNode(attr);\n\t\t}\n\t},\n\tgetAttributeNodeNS: function (namespaceURI, localName) {\n\t\treturn this.attributes.getNamedItemNS(namespaceURI, localName);\n\t},\n\n\t/**\n\t * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).\n\t *\n\t * Returns an empty list if `classNames` is an empty string or only contains HTML white space\n\t * characters.\n\t *\n\t * Warning: This returns a live LiveNodeList.\n\t * Changes in the DOM will reflect in the array as the changes occur.\n\t * If an element selected by this array no longer qualifies for the selector,\n\t * it will automatically be removed. Be aware of this for iteration purposes.\n\t *\n\t * @param {string} classNames\n\t * Is a string representing the class name(s) to match; multiple class names are separated by\n\t * (ASCII-)whitespace.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\n\t * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname\n\t */\n\tgetElementsByClassName: function (classNames) {\n\t\tvar classNamesSet = toOrderedSet(classNames);\n\t\treturn new LiveNodeList(this, function (base) {\n\t\t\tvar ls = [];\n\t\t\tif (classNamesSet.length > 0) {\n\t\t\t\t_visitNode(base, function (node) {\n\t\t\t\t\tif (node !== base && node.nodeType === ELEMENT_NODE) {\n\t\t\t\t\t\tvar nodeClassNames = node.getAttribute('class');\n\t\t\t\t\t\t// can be null if the attribute does not exist\n\t\t\t\t\t\tif (nodeClassNames) {\n\t\t\t\t\t\t\t// before splitting and iterating just compare them for the most common case\n\t\t\t\t\t\t\tvar matches = classNames === nodeClassNames;\n\t\t\t\t\t\t\tif (!matches) {\n\t\t\t\t\t\t\t\tvar nodeClassNamesSet = toOrderedSet(nodeClassNames);\n\t\t\t\t\t\t\t\tmatches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (matches) {\n\t\t\t\t\t\t\t\tls.push(node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn ls;\n\t\t});\n\t},\n\n\t/**\n\t * Returns a LiveNodeList of elements with the given qualifiedName.\n\t * Searching for all descendants can be done by passing `*` as `qualifiedName`.\n\t *\n\t * All descendants of the specified element are searched, but not the element itself.\n\t * The returned list is live, which means it updates itself with the DOM tree automatically.\n\t * Therefore, there is no need to call `Element.getElementsByTagName()`\n\t * with the same element and arguments repeatedly if the DOM changes in between calls.\n\t *\n\t * When called on an HTML element in an HTML document,\n\t * `getElementsByTagName` lower-cases the argument before searching for it.\n\t * This is undesirable when trying to match camel-cased SVG elements (such as\n\t * `<linearGradient>`) in an HTML document.\n\t * Instead, use `Element.getElementsByTagNameNS()`,\n\t * which preserves the capitalization of the tag name.\n\t *\n\t * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,\n\t * except that it only searches for elements that are descendants of the specified element.\n\t *\n\t * @param {string} qualifiedName\n\t * @returns {LiveNodeList}\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\n\t * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname\n\t */\n\tgetElementsByTagName: function (qualifiedName) {\n\t\tvar isHTMLDocument = (this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument).type === 'html';\n\t\tvar lowerQualifiedName = qualifiedName.toLowerCase();\n\t\treturn new LiveNodeList(this, function (base) {\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base, function (node) {\n\t\t\t\tif (node === base || node.nodeType !== ELEMENT_NODE) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (qualifiedName === '*') {\n\t\t\t\t\tls.push(node);\n\t\t\t\t} else {\n\t\t\t\t\tvar nodeQualifiedName = node.getQualifiedName();\n\t\t\t\t\tvar matchingQName = isHTMLDocument && node.namespaceURI === NAMESPACE.HTML ? lowerQualifiedName : qualifiedName;\n\t\t\t\t\tif (nodeQualifiedName === matchingQName) {\n\t\t\t\t\t\tls.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\t\t});\n\t},\n\tgetElementsByTagNameNS: function (namespaceURI, localName) {\n\t\treturn new LiveNodeList(this, function (base) {\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base, function (node) {\n\t\t\t\tif (\n\t\t\t\t\tnode !== base &&\n\t\t\t\t\tnode.nodeType === ELEMENT_NODE &&\n\t\t\t\t\t(namespaceURI === '*' || node.namespaceURI === namespaceURI) &&\n\t\t\t\t\t(localName === '*' || node.localName == localName)\n\t\t\t\t) {\n\t\t\t\t\tls.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\t\t});\n\t},\n};\nDocument.prototype.getElementsByClassName = Element.prototype.getElementsByClassName;\nDocument.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\nDocument.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n\n_extends(Element, Node);\nfunction Attr(symbol) {\n\tcheckSymbol(symbol);\n\n\tthis.namespaceURI = null;\n\tthis.prefix = null;\n\tthis.ownerElement = null;\n}\nAttr.prototype.nodeType = ATTRIBUTE_NODE;\n_extends(Attr, Node);\n\nfunction CharacterData(symbol) {\n\tcheckSymbol(symbol);\n}\nCharacterData.prototype = {\n\tdata: '',\n\tsubstringData: function (offset, count) {\n\t\treturn this.data.substring(offset, offset + count);\n\t},\n\tappendData: function (text) {\n\t\ttext = this.data + text;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t},\n\tinsertData: function (offset, text) {\n\t\tthis.replaceData(offset, 0, text);\n\t},\n\tdeleteData: function (offset, count) {\n\t\tthis.replaceData(offset, count, '');\n\t},\n\treplaceData: function (offset, count, text) {\n\t\tvar start = this.data.substring(0, offset);\n\t\tvar end = this.data.substring(offset + count);\n\t\ttext = start + text + end;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t},\n};\n_extends(CharacterData, Node);\nfunction Text(symbol) {\n\tcheckSymbol(symbol);\n}\nText.prototype = {\n\tnodeName: '#text',\n\tnodeType: TEXT_NODE,\n\tsplitText: function (offset) {\n\t\tvar text = this.data;\n\t\tvar newText = text.substring(offset);\n\t\ttext = text.substring(0, offset);\n\t\tthis.data = this.nodeValue = text;\n\t\tthis.length = text.length;\n\t\tvar newNode = this.ownerDocument.createTextNode(newText);\n\t\tif (this.parentNode) {\n\t\t\tthis.parentNode.insertBefore(newNode, this.nextSibling);\n\t\t}\n\t\treturn newNode;\n\t},\n};\n_extends(Text, CharacterData);\nfunction Comment(symbol) {\n\tcheckSymbol(symbol);\n}\nComment.prototype = {\n\tnodeName: '#comment',\n\tnodeType: COMMENT_NODE,\n};\n_extends(Comment, CharacterData);\n\nfunction CDATASection(symbol) {\n\tcheckSymbol(symbol);\n}\nCDATASection.prototype = {\n\tnodeName: '#cdata-section',\n\tnodeType: CDATA_SECTION_NODE,\n};\n_extends(CDATASection, Text);\n\nfunction DocumentType(symbol) {\n\tcheckSymbol(symbol);\n}\nDocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n_extends(DocumentType, Node);\n\nfunction Notation(symbol) {\n\tcheckSymbol(symbol);\n}\nNotation.prototype.nodeType = NOTATION_NODE;\n_extends(Notation, Node);\n\nfunction Entity(symbol) {\n\tcheckSymbol(symbol);\n}\nEntity.prototype.nodeType = ENTITY_NODE;\n_extends(Entity, Node);\n\nfunction EntityReference(symbol) {\n\tcheckSymbol(symbol);\n}\nEntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n_extends(EntityReference, Node);\n\nfunction DocumentFragment(symbol) {\n\tcheckSymbol(symbol);\n}\nDocumentFragment.prototype.nodeName = '#document-fragment';\nDocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\n_extends(DocumentFragment, Node);\n\nfunction ProcessingInstruction(symbol) {\n\tcheckSymbol(symbol);\n}\nProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n_extends(ProcessingInstruction, CharacterData);\nfunction XMLSerializer() {}\nXMLSerializer.prototype.serializeToString = function (node, nodeFilter) {\n\treturn nodeSerializeToString.call(node, nodeFilter);\n};\nNode.prototype.toString = nodeSerializeToString;\nfunction nodeSerializeToString(nodeFilter) {\n\tvar buf = [];\n\tvar refNode = (this.nodeType === DOCUMENT_NODE && this.documentElement) || this;\n\tvar prefix = refNode.prefix;\n\tvar uri = refNode.namespaceURI;\n\n\tif (uri && prefix == null) {\n\t\tvar prefix = refNode.lookupPrefix(uri);\n\t\tif (prefix == null) {\n\t\t\tvar visibleNamespaces = [\n\t\t\t\t{ namespace: uri, prefix: null },\n\t\t\t\t//{namespace:uri,prefix:''}\n\t\t\t];\n\t\t}\n\t}\n\tserializeToString(this, buf, nodeFilter, visibleNamespaces);\n\treturn buf.join('');\n}\n\nfunction needNamespaceDefine(node, isHTML, visibleNamespaces) {\n\tvar prefix = node.prefix || '';\n\tvar uri = node.namespaceURI;\n\t// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\n\t// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\n\t// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\n\t// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\n\t// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\n\t// > [...] Furthermore, the attribute value [...] must not be an empty string.\n\t// so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\n\tif (!uri) {\n\t\treturn false;\n\t}\n\tif ((prefix === 'xml' && uri === NAMESPACE.XML) || uri === NAMESPACE.XMLNS) {\n\t\treturn false;\n\t}\n\n\tvar i = visibleNamespaces.length;\n\twhile (i--) {\n\t\tvar ns = visibleNamespaces[i];\n\t\t// get namespace prefix\n\t\tif (ns.prefix === prefix) {\n\t\t\treturn ns.namespace !== uri;\n\t\t}\n\t}\n\treturn true;\n}\n/**\n * Literal whitespace other than space that appear in attribute values are serialized as\n * their entity references, so they will be preserved.\n * (In contrast to whitespace literals in the input which are normalized to spaces).\n *\n * Well-formed constraint: No < in Attribute Values:\n * > The replacement text of any entity referred to directly or indirectly\n * > in an attribute value must not contain a <.\n *\n * @see https://www.w3.org/TR/xml11/#CleanAttrVals\n * @see https://www.w3.org/TR/xml11/#NT-AttValue\n * @see https://www.w3.org/TR/xml11/#AVNormalize\n * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes\n * @prettierignore\n */\nfunction addSerializedAttribute(buf, qualifiedName, value) {\n\tbuf.push(' ', qualifiedName, '=\"', value.replace(/[<>&\"\\t\\n\\r]/g, _xmlEncoder), '\"');\n}\n\nfunction serializeToString(node, buf, nodeFilter, visibleNamespaces) {\n\tif (!visibleNamespaces) {\n\t\tvisibleNamespaces = [];\n\t}\n\tvar doc = node.nodeType === DOCUMENT_NODE ? node : node.ownerDocument;\n\tvar isHTML = doc.type === 'html';\n\n\tif (nodeFilter) {\n\t\tnode = nodeFilter(node);\n\t\tif (node) {\n\t\t\tif (typeof node == 'string') {\n\t\t\t\tbuf.push(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\t//buf.sort.apply(attrs, attributeSorter);\n\t}\n\n\tswitch (node.nodeType) {\n\t\tcase ELEMENT_NODE:\n\t\t\tvar attrs = node.attributes;\n\t\t\tvar len = attrs.length;\n\t\t\tvar child = node.firstChild;\n\t\t\tvar nodeName = node.tagName;\n\n\t\t\tvar prefixedNodeName = nodeName;\n\t\t\tif (!isHTML && !node.prefix && node.namespaceURI) {\n\t\t\t\tvar defaultNS;\n\t\t\t\t// lookup current default ns from `xmlns` attribute\n\t\t\t\tfor (var ai = 0; ai < attrs.length; ai++) {\n\t\t\t\t\tif (attrs.item(ai).name === 'xmlns') {\n\t\t\t\t\t\tdefaultNS = attrs.item(ai).value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!defaultNS) {\n\t\t\t\t\t// lookup current default ns in visibleNamespaces\n\t\t\t\t\tfor (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n\t\t\t\t\t\tvar namespace = visibleNamespaces[nsi];\n\t\t\t\t\t\tif (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\n\t\t\t\t\t\t\tdefaultNS = namespace.namespace;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (defaultNS !== node.namespaceURI) {\n\t\t\t\t\tfor (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n\t\t\t\t\t\tvar namespace = visibleNamespaces[nsi];\n\t\t\t\t\t\tif (namespace.namespace === node.namespaceURI) {\n\t\t\t\t\t\t\tif (namespace.prefix) {\n\t\t\t\t\t\t\t\tprefixedNodeName = namespace.prefix + ':' + nodeName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuf.push('<', prefixedNodeName);\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\t// add namespaces for attributes\n\t\t\t\tvar attr = attrs.item(i);\n\t\t\t\tif (attr.prefix == 'xmlns') {\n\t\t\t\t\tvisibleNamespaces.push({\n\t\t\t\t\t\tprefix: attr.localName,\n\t\t\t\t\t\tnamespace: attr.value,\n\t\t\t\t\t});\n\t\t\t\t} else if (attr.nodeName == 'xmlns') {\n\t\t\t\t\tvisibleNamespaces.push({ prefix: '', namespace: attr.value });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar attr = attrs.item(i);\n\t\t\t\tif (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {\n\t\t\t\t\tvar prefix = attr.prefix || '';\n\t\t\t\t\tvar uri = attr.namespaceURI;\n\t\t\t\t\taddSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);\n\t\t\t\t\tvisibleNamespaces.push({ prefix: prefix, namespace: uri });\n\t\t\t\t}\n\t\t\t\tserializeToString(attr, buf, nodeFilter, visibleNamespaces);\n\t\t\t}\n\n\t\t\t// add namespace for current node\n\t\t\tif (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {\n\t\t\t\tvar prefix = node.prefix || '';\n\t\t\t\tvar uri = node.namespaceURI;\n\t\t\t\taddSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : 'xmlns', uri);\n\t\t\t\tvisibleNamespaces.push({ prefix: prefix, namespace: uri });\n\t\t\t}\n\t\t\t// in XML elements can be closed when they have no children\n\t\t\tvar canCloseTag = !child;\n\t\t\tif (canCloseTag && (isHTML || node.namespaceURI === NAMESPACE.HTML)) {\n\t\t\t\t// in HTML (doc or ns) only void elements can be closed right away\n\t\t\t\tcanCloseTag = isHTMLVoidElement(nodeName);\n\t\t\t}\n\t\t\tif (canCloseTag) {\n\t\t\t\tbuf.push('/>');\n\t\t\t} else {\n\t\t\t\tbuf.push('>');\n\t\t\t\t//if is cdata child node\n\t\t\t\tif (isHTML && isHTMLRawTextElement(nodeName)) {\n\t\t\t\t\twhile (child) {\n\t\t\t\t\t\tif (child.data) {\n\t\t\t\t\t\t\tbuf.push(child.data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tserializeToString(child, buf, nodeFilter, visibleNamespaces.slice());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (child) {\n\t\t\t\t\t\tserializeToString(child, buf, nodeFilter, visibleNamespaces.slice());\n\t\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf.push('</', prefixedNodeName, '>');\n\t\t\t}\n\t\t\t// remove added visible namespaces\n\t\t\t//visibleNamespaces.length = startVisibleNamespaces;\n\t\t\treturn;\n\t\tcase DOCUMENT_NODE:\n\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tvar child = node.firstChild;\n\t\t\twhile (child) {\n\t\t\t\tserializeToString(child, buf, nodeFilter, visibleNamespaces.slice());\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t\treturn;\n\t\tcase ATTRIBUTE_NODE:\n\t\t\treturn addSerializedAttribute(buf, node.name, node.value);\n\t\tcase TEXT_NODE:\n\t\t\t/*\n\t\t\t * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\n\t\t\t * except when used as markup delimiters, or within a comment, a processing instruction,\n\t\t\t * or a CDATA section.\n\t\t\t * If they are needed elsewhere, they must be escaped using either numeric character\n\t\t\t * references or the strings `&amp;` and `&lt;` respectively.\n\t\t\t * The right angle bracket (>) may be represented using the string \" &gt; \",\n\t\t\t * and must, for compatibility, be escaped using either `&gt;`,\n\t\t\t * or a character reference when it appears in the string `]]>` in content,\n\t\t\t * when that string is not marking the end of a CDATA section.\n\t\t\t *\n\t\t\t * In the content of elements, character data is any string of characters which does not\n\t\t\t * contain the start-delimiter of any markup and does not include the CDATA-section-close\n\t\t\t * delimiter, `]]>`.\n\t\t\t *\n\t\t\t * @see https://www.w3.org/TR/xml/#NT-CharData\n\t\t\t * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node\n\t\t\t */\n\t\t\treturn buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));\n\t\tcase CDATA_SECTION_NODE:\n\t\t\treturn buf.push(g.CDATA_START, node.data, g.CDATA_END);\n\t\tcase COMMENT_NODE:\n\t\t\treturn buf.push(g.COMMENT_START, node.data, g.COMMENT_END);\n\t\tcase DOCUMENT_TYPE_NODE:\n\t\t\tvar pubid = node.publicId;\n\t\t\tvar sysid = node.systemId;\n\t\t\tbuf.push(g.DOCTYPE_DECL_START, ' ', node.name);\n\t\t\tif (pubid) {\n\t\t\t\tbuf.push(' ', g.PUBLIC, ' ', pubid);\n\t\t\t\tif (sysid && sysid !== '.') {\n\t\t\t\t\tbuf.push(' ', sysid);\n\t\t\t\t}\n\t\t\t} else if (sysid && sysid !== '.') {\n\t\t\t\tbuf.push(' ', g.SYSTEM, ' ', sysid);\n\t\t\t}\n\t\t\tif (node.internalSubset) {\n\t\t\t\tbuf.push(' [', node.internalSubset, ']');\n\t\t\t}\n\t\t\tbuf.push('>');\n\t\t\treturn;\n\t\tcase PROCESSING_INSTRUCTION_NODE:\n\t\t\treturn buf.push('<?', node.target, ' ', node.data, '?>');\n\t\tcase ENTITY_REFERENCE_NODE:\n\t\t\treturn buf.push('&', node.nodeName, ';');\n\t\t//case ENTITY_NODE:\n\t\t//case NOTATION_NODE:\n\t\tdefault:\n\t\t\tbuf.push('??', node.nodeName);\n\t}\n}\nfunction importNode(doc, node, deep) {\n\tvar node2;\n\tswitch (node.nodeType) {\n\t\tcase ELEMENT_NODE:\n\t\t\tnode2 = node.cloneNode(false);\n\t\t\tnode2.ownerDocument = doc;\n\t\t//var attrs = node2.attributes;\n\t\t//var len = attrs.length;\n\t\t//for(var i=0;i<len;i++){\n\t\t//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n\t\t//}\n\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tbreak;\n\t\tcase ATTRIBUTE_NODE:\n\t\t\tdeep = true;\n\t\t\tbreak;\n\t\t//case ENTITY_REFERENCE_NODE:\n\t\t//case PROCESSING_INSTRUCTION_NODE:\n\t\t////case TEXT_NODE:\n\t\t//case CDATA_SECTION_NODE:\n\t\t//case COMMENT_NODE:\n\t\t//\tdeep = false;\n\t\t//\tbreak;\n\t\t//case DOCUMENT_NODE:\n\t\t//case DOCUMENT_TYPE_NODE:\n\t\t//cannot be imported.\n\t\t//case ENTITY_NODE:\n\t\t//case NOTATION_NODE\n\t\t//can not hit in level3\n\t\t//default:throw e;\n\t}\n\tif (!node2) {\n\t\tnode2 = node.cloneNode(false); //false\n\t}\n\tnode2.ownerDocument = doc;\n\tnode2.parentNode = null;\n\tif (deep) {\n\t\tvar child = node.firstChild;\n\t\twhile (child) {\n\t\t\tnode2.appendChild(importNode(doc, child, deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n\n/**\n * Creates a copy of a node from an existing one.\n *\n * @param {Document} doc\n * The Document object representing the document that the new node will belong to.\n * @param {Node} node\n * The node to clone.\n * @param {boolean} deep\n * If true, the contents of the node are recursively copied.\n * If false, only the node itself (and its attributes, if it is an element) are copied.\n * @returns {Node}\n * Returns the newly created copy of the node.\n * @throws {DOMException}\n * May throw a DOMException if operations within setAttributeNode or appendChild (which are\n * potentially invoked in this function) do not meet their specific constraints.\n */\nfunction cloneNode(doc, node, deep) {\n\tvar node2 = new node.constructor(PDC);\n\tfor (var n in node) {\n\t\tif (hasOwn(node, n)) {\n\t\t\tvar v = node[n];\n\t\t\tif (typeof v != 'object') {\n\t\t\t\tif (v != node2[n]) {\n\t\t\t\t\tnode2[n] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (node.childNodes) {\n\t\tnode2.childNodes = new NodeList();\n\t}\n\tnode2.ownerDocument = doc;\n\tswitch (node2.nodeType) {\n\t\tcase ELEMENT_NODE:\n\t\t\tvar attrs = node.attributes;\n\t\t\tvar attrs2 = (node2.attributes = new NamedNodeMap());\n\t\t\tvar len = attrs.length;\n\t\t\tattrs2._ownerElement = node2;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tnode2.setAttributeNode(cloneNode(doc, attrs.item(i), true));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ATTRIBUTE_NODE:\n\t\t\tdeep = true;\n\t}\n\tif (deep) {\n\t\tvar child = node.firstChild;\n\t\twhile (child) {\n\t\t\tnode2.appendChild(cloneNode(doc, child, deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n\nfunction __set__(object, key, value) {\n\tobject[key] = value;\n}\n//do dynamic\ntry {\n\tif (Object.defineProperty) {\n\t\tObject.defineProperty(LiveNodeList.prototype, 'length', {\n\t\t\tget: function () {\n\t\t\t\t_updateLiveList(this);\n\t\t\t\treturn this.$$length;\n\t\t\t},\n\t\t});\n\n\t\tObject.defineProperty(Node.prototype, 'textContent', {\n\t\t\tget: function () {\n\t\t\t\treturn getTextContent(this);\n\t\t\t},\n\n\t\t\tset: function (data) {\n\t\t\t\tswitch (this.nodeType) {\n\t\t\t\t\tcase ELEMENT_NODE:\n\t\t\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t\t\twhile (this.firstChild) {\n\t\t\t\t\t\t\tthis.removeChild(this.firstChild);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (data || String(data)) {\n\t\t\t\t\t\t\tthis.appendChild(this.ownerDocument.createTextNode(data));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.data = data;\n\t\t\t\t\t\tthis.value = data;\n\t\t\t\t\t\tthis.nodeValue = data;\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\n\t\tfunction getTextContent(node) {\n\t\t\tswitch (node.nodeType) {\n\t\t\t\tcase ELEMENT_NODE:\n\t\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t\tvar buf = [];\n\t\t\t\t\tnode = node.firstChild;\n\t\t\t\t\twhile (node) {\n\t\t\t\t\t\tif (node.nodeType !== 7 && node.nodeType !== 8) {\n\t\t\t\t\t\t\tbuf.push(getTextContent(node));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf.join('');\n\t\t\t\tdefault:\n\t\t\t\t\treturn node.nodeValue;\n\t\t\t}\n\t\t}\n\n\t\t__set__ = function (object, key, value) {\n\t\t\t//console.log(value)\n\t\t\tobject['$$' + key] = value;\n\t\t};\n\t}\n} catch (e) {\n\t//ie8\n}\n\nexports._updateLiveList = _updateLiveList;\nexports.Attr = Attr;\nexports.CDATASection = CDATASection;\nexports.CharacterData = CharacterData;\nexports.Comment = Comment;\nexports.Document = Document;\nexports.DocumentFragment = DocumentFragment;\nexports.DocumentType = DocumentType;\nexports.DOMImplementation = DOMImplementation;\nexports.Element = Element;\nexports.Entity = Entity;\nexports.EntityReference = EntityReference;\nexports.LiveNodeList = LiveNodeList;\nexports.NamedNodeMap = NamedNodeMap;\nexports.Node = Node;\nexports.NodeList = NodeList;\nexports.Notation = Notation;\nexports.Text = Text;\nexports.ProcessingInstruction = ProcessingInstruction;\nexports.XMLSerializer = XMLSerializer;\n"],"mappings":"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CAb,CAAC,EAAE;IACJ;IACA,OAAO,IAAI;EACZ;AACD,CAAC;AACDwB,YAAY,CAACnE,SAAS,CAAC5C,MAAM,CAAC6F,QAAQ,CAAC,GAAG,YAAY;EACrD,IAAIC,EAAE,GAAG,IAAI;EACb,IAAIX,KAAK,GAAG,CAAC;EAEb,OAAO;IACNY,IAAI,EAAE,SAAAA,CAAA,EAAY;MACjB,IAAIZ,KAAK,GAAGW,EAAE,CAACrB,MAAM,EAAE;QACtB,OAAO;UACNuB,KAAK,EAAEF,EAAE,CAACX,KAAK,EAAE,CAAC;UAClBc,IAAI,EAAE;QACP,CAAC;MACF,CAAC,MAAM;QACN,OAAO;UACNA,IAAI,EAAE;QACP,CAAC;MACF;IACD,CAAC;IACDC,MAAM,EAAE,SAAAA,CAAA,EAAY;MACnB,OAAO;QACND,IAAI,EAAE;MACP,CAAC;IACF;EACD,CAAC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuC,iBAAiBA,CAAA,EAAG,CAAC;AAE9BA,iBAAiB,CAAC5F,SAAS,GAAG;EAC7B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC6F,UAAU,EAAE,SAAAA,CAAUC,OAAO,EAAEC,OAAO,EAAE;IACvC,OAAO,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,cAAc,EAAE,SAAAA,CAAUT,YAAY,EAAE3G,aAAa,EAAEqH,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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0F,IAAIA,CAACjK,MAAM,EAAE;EACrBD,WAAW,CAACC,MAAM,CAAC;AACpB;AAEAiK,IAAI,CAAC3H,SAAS,GAAG;EAChB;AACD;AACA;AACA;AACA;EACC4H,UAAU,EAAE,IAAI;EAChB;AACD;AACA;AACA;AACA;EACCC,SAAS,EAAE,IAAI;EACf;AACD;AACA;AACA;AACA;EACCC,eAAe,EAAE,IAAI;EACrB;AACD;AACA;AACA;AACA;EACCC,WAAW,EAAE,IAAI;EACjB;AACD;AACA;AACA;AACA;EACCC,UAAU,EAAE,IAAI;EAChB;AACD;AACA;AACA;AACA;EACC,IAAIC,aAAaA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACD,UAAU,IAAI,IAAI,CAACA,UAAU,CAACE,QAAQ,KAAK,IAAI,CAAC5H,YAAY,GAAG,IAAI,CAAC0H,UAAU,GAAG,IAAI;EAClG,CAAC;EACD;AACD;AACA;AACA;AACA;EACCtB,UAAU,EAAE,IAAI;EAChB;AACD;AACA;AACA;AACA;EACC3C,aAAa,EAAE,IAAI;EACnB;AACD;AACA;AACA;AACA;EACCoE,SAAS,EAAE,IAAI;EACf;AACD;AACA;AACA;AACA;EACC5C,YAAY,EAAE,IAAI;EAClB;AACD;AACA;AACA;AACA;EACCrG,MAAM,EAAE,IAAI;EACZ;AACD;AACA;AACA;AACA;EACCC,SAAS,EAAE,IAAI;EACf;AACD;AACA;AACA;AACA;AACA;EACCiJ,OAAO,EAAE,aAAa;EACtB;AACD;AACA;AACA;AACA;EACC,IAAIC,WAAWA,CAAA,EAAG;IACjB,IAAIC,QAAQ,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;IACjC,OAAOD,QAAQ,IAAIA,QAAQ,CAACJ,QAAQ,KAAKI,QAAQ,CAACxH,aAAa;EAChE,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC0H,QAAQ,EAAE,SAAAA,CAAUC,KAAK,EAAE;IAC1B,IAAI,CAACA,KAAK,EAAE,OAAO,KAAK;IACxB,IAAIC,MAAM,GAAGD,KAAK;IAClB,GAAG;MACF,IAAI,IAAI,KAAKC,MAAM,EAAE,OAAO,IAAI;MAChCA,MAAM,GAAGD,KAAK,CAACT,UAAU;IAC1B,CAAC,QAAQU,MAAM;IACf,OAAO,KAAK;EACb,CAAC;EACD;AACD;AACA;AACA;EACC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCH,WAAW,EAAE,SAAAA,CAAUI,OAAO,EAAE;IAC/B,IAAID,MAAM,GAAG,IAAI;IACjB,GAAG;MACF,IAAI,CAACA,MAAM,CAACV,UAAU,EAAE;QACvB,OAAOU,MAAM;MACd;MACAA,MAAM,GAAGA,MAAM,CAACV,UAAU;IAC3B,CAAC,QAAQU,MAAM;EAChB,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;EACCE,WAAW,EAAE,SAAAA,CAAUC,SAAS,EAAE;IACjC,IAAI,CAACA,SAAS,EAAE,OAAO,KAAK;IAE5B,IAAI,IAAI,CAACX,QAAQ,KAAKW,SAAS,CAACX,QAAQ,EAAE,OAAO,KAAK;IAEtD,QAAQ,IAAI,CAACA,QAAQ;MACpB,KAAK,IAAI,CAACnH,kBAAkB;QAC3B,IAAI,IAAI,CAACoG,IAAI,KAAK0B,SAAS,CAAC1B,IAAI,EAAE,OAAO,KAAK;QAC9C,IAAI,IAAI,CAACJ,QAAQ,KAAK8B,SAAS,CAAC9B,QAAQ,EAAE,OAAO,KAAK;QACtD,IAAI,IAAI,CAACC,QAAQ,KAAK6B,SAAS,CAAC7B,QAAQ,EAAE,OAAO,KAAK;QACtD;MACD,KAAK,IAAI,CAAC1G,YAAY;QACrB,IAAI,IAAI,CAACiF,YAAY,KAAKsD,SAAS,CAACtD,YAAY,EAAE,OAAO,KAAK;QAC9D,IAAI,IAAI,CAACrG,MAAM,KAAK2J,SAAS,CAAC3J,MAAM,EAAE,OAAO,KAAK;QAClD,IAAI,IAAI,CAACC,SAAS,KAAK0J,SAAS,CAAC1J,SAAS,EAAE,OAAO,KAAK;QACxD,IAAI,IAAI,CAAC2J,UAAU,CAACjH,MAAM,KAAKgH,SAAS,CAACC,UAAU,CAACjH,MAAM,EAAE,OAAO,KAAK;QACxE,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACmG,UAAU,CAACjH,MAAM,EAAEc,CAAC,EAAE,EAAE;UAChD,IAAIkC,IAAI,GAAG,IAAI,CAACiE,UAAU,CAACxG,IAAI,CAACK,CAAC,CAAC;UAClC,IAAI,CAACkC,IAAI,CAAC+D,WAAW,CAACC,SAAS,CAACE,kBAAkB,CAAClE,IAAI,CAACU,YAAY,EAAEV,IAAI,CAAC1F,SAAS,CAAC,CAAC,EAAE;YACvF,OAAO,KAAK;UACb;QACD;QACA;MACD,KAAK,IAAI,CAACoB,cAAc;QACvB,IAAI,IAAI,CAACgF,YAAY,KAAKsD,SAAS,CAACtD,YAAY,EAAE,OAAO,KAAK;QAC9D,IAAI,IAAI,CAACpG,SAAS,KAAK0J,SAAS,CAAC1J,SAAS,EAAE,OAAO,KAAK;QACxD,IAAI,IAAI,CAACiE,KAAK,KAAKyF,SAAS,CAACzF,KAAK,EAAE,OAAO,KAAK;QAEhD;MACD,KAAK,IAAI,CAACxC,2BAA2B;QACpC,IAAI,IAAI,CAACoI,MAAM,KAAKH,SAAS,CAACG,MAAM,IAAI,IAAI,CAACC,IAAI,KAAKJ,SAAS,CAACI,IAAI,EAAE;UACrE,OAAO,KAAK;QACb;QACA;MACD,KAAK,IAAI,CAACzI,SAAS;MACnB,KAAK,IAAI,CAACK,YAAY;QACrB,IAAI,IAAI,CAACoI,IAAI,KAAKJ,SAAS,CAACI,IAAI,EAAE,OAAO,KAAK;QAC9C;IACF;IAEA,IAAI,IAAI,CAACvC,UAAU,CAAC7E,MAAM,KAAKgH,SAAS,CAACnC,UAAU,CAAC7E,MAAM,EAAE;MAC3D,OAAO,KAAK;IACb;IAEA,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC+D,UAAU,CAAC7E,MAAM,EAAEc,CAAC,EAAE,EAAE;MAChD,IAAI,CAAC,IAAI,CAAC+D,UAAU,CAAC/D,CAAC,CAAC,CAACiG,WAAW,CAACC,SAAS,CAACnC,UAAU,CAAC/D,CAAC,CAAC,CAAC,EAAE;QAC7D,OAAO,KAAK;MACb;IACD;IAEA,OAAO,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;AACA;EACCuG,UAAU,EAAE,SAAAA,CAAUL,SAAS,EAAE;IAChC,OAAO,IAAI,KAAKA,SAAS;EAC1B,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCM,YAAY,EAAE,SAAAA,CAAUC,QAAQ,EAAEC,QAAQ,EAAE;IAC3C,OAAOC,aAAa,CAAC,IAAI,EAAEF,QAAQ,EAAEC,QAAQ,CAAC;EAC/C,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCE,YAAY,EAAE,SAAAA,CAAUH,QAAQ,EAAEI,QAAQ,EAAE;IAC3CF,aAAa,CAAC,IAAI,EAAEF,QAAQ,EAAEI,QAAQ,EAAEC,sCAAsC,CAAC;IAC/E,IAAID,QAAQ,EAAE;MACb,IAAI,CAACE,WAAW,CAACF,QAAQ,CAAC;IAC3B;EACD,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCE,WAAW,EAAE,SAAAA,CAAUF,QAAQ,EAAE;IAChC,OAAOG,YAAY,CAAC,IAAI,EAAEH,QAAQ,CAAC;EACpC,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC7C,WAAW,EAAE,SAAAA,CAAUyC,QAAQ,EAAE;IAChC,OAAO,IAAI,CAACD,YAAY,CAACC,QAAQ,EAAE,IAAI,CAAC;EACzC,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;EACCQ,aAAa,EAAE,SAAAA,CAAA,EAAY;IAC1B,OAAO,IAAI,CAAChC,UAAU,IAAI,IAAI;EAC/B,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCiC,SAAS,EAAE,SAAAA,CAAUC,IAAI,EAAE;IAC1B,OAAOD,SAAS,CAAC,IAAI,CAAC9F,aAAa,IAAI,IAAI,EAAE,IAAI,EAAE+F,IAAI,CAAC;EACzD,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCC,SAAS,EAAE,SAAAA,CAAA,EAAY;IACtB,IAAIC,KAAK,GAAG,IAAI,CAACpC,UAAU;IAC3B,OAAOoC,KAAK,EAAE;MACb,IAAI7G,IAAI,GAAG6G,KAAK,CAACjC,WAAW;MAC5B,IAAI5E,IAAI,IAAIA,IAAI,CAAC+E,QAAQ,IAAI1H,SAAS,IAAIwJ,KAAK,CAAC9B,QAAQ,IAAI1H,SAAS,EAAE;QACtE,IAAI,CAACkJ,WAAW,CAACvG,IAAI,CAAC;QACtB6G,KAAK,CAACC,UAAU,CAAC9G,IAAI,CAAC8F,IAAI,CAAC;MAC5B,CAAC,MAAM;QACNe,KAAK,CAACD,SAAS,CAAC,CAAC;QACjBC,KAAK,GAAG7G,IAAI;MACb;IACD;EACD,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC+G,WAAW,EAAE,SAAAA,CAAUpE,OAAO,EAAEC,OAAO,EAAE;IACxC,OAAO,IAAI,CAAChC,aAAa,CAAC0C,cAAc,CAACZ,UAAU,CAACC,OAAO,EAAEC,OAAO,CAAC;EACtE,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCoE,YAAY,EAAE,SAAAA,CAAU5E,YAAY,EAAE;IACrC,IAAIjB,EAAE,GAAG,IAAI;IACb,OAAOA,EAAE,EAAE;MACV,IAAI8F,GAAG,GAAG9F,EAAE,CAAC+F,MAAM;MACnB;MACA,IAAID,GAAG,EAAE;QACR,KAAK,IAAIrI,CAAC,IAAIqI,GAAG,EAAE;UAClB,IAAIvN,MAAM,CAACuN,GAAG,EAAErI,CAAC,CAAC,IAAIqI,GAAG,CAACrI,CAAC,CAAC,KAAKwD,YAAY,EAAE;YAC9C,OAAOxD,CAAC;UACT;QACD;MACD;MACAuC,EAAE,GAAGA,EAAE,CAAC4D,QAAQ,IAAI3H,cAAc,GAAG+D,EAAE,CAACP,aAAa,GAAGO,EAAE,CAAC0D,UAAU;IACtE;IACA,OAAO,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCsC,kBAAkB,EAAE,SAAAA,CAAUpL,MAAM,EAAE;IACrC,IAAIoF,EAAE,GAAG,IAAI;IACb,OAAOA,EAAE,EAAE;MACV,IAAI8F,GAAG,GAAG9F,EAAE,CAAC+F,MAAM;MACnB;MACA,IAAID,GAAG,EAAE;QACR,IAAIvN,MAAM,CAACuN,GAAG,EAAElL,MAAM,CAAC,EAAE;UACxB,OAAOkL,GAAG,CAAClL,MAAM,CAAC;QACnB;MACD;MACAoF,EAAE,GAAGA,EAAE,CAAC4D,QAAQ,IAAI3H,cAAc,GAAG+D,EAAE,CAACP,aAAa,GAAGO,EAAE,CAAC0D,UAAU;IACtE;IACA,OAAO,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCuC,kBAAkB,EAAE,SAAAA,CAAUhF,YAAY,EAAE;IAC3C,IAAIrG,MAAM,GAAG,IAAI,CAACiL,YAAY,CAAC5E,YAAY,CAAC;IAC5C,OAAOrG,MAAM,IAAI,IAAI;EACtB,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCsL,uBAAuB,EAAE,SAAAA,CAAU/B,KAAK,EAAE;IACzC,IAAI,IAAI,KAAKA,KAAK,EAAE,OAAO,CAAC;IAC5B,IAAIgC,KAAK,GAAGhC,KAAK;IACjB,IAAIiC,KAAK,GAAG,IAAI;IAChB,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIH,KAAK,YAAYI,IAAI,EAAE;MAC1BF,KAAK,GAAGF,KAAK;MACbA,KAAK,GAAGE,KAAK,CAAClG,YAAY;IAC3B;IACA,IAAIiG,KAAK,YAAYG,IAAI,EAAE;MAC1BD,KAAK,GAAGF,KAAK;MACbA,KAAK,GAAGE,KAAK,CAACnG,YAAY;MAC1B,IAAIkG,KAAK,IAAIF,KAAK,IAAIC,KAAK,KAAKD,KAAK,EAAE;QACtC,KAAK,IAAI9H,CAAC,GAAG,CAAC,EAAEkC,IAAI,EAAGA,IAAI,GAAG6F,KAAK,CAAC5B,UAAU,CAACnG,CAAC,CAAC,EAAGA,CAAC,EAAE,EAAE;UACxD,IAAIkC,IAAI,KAAK8F,KAAK,EACjB,OAAOzJ,gBAAgB,CAACO,yCAAyC,GAAGP,gBAAgB,CAACG,2BAA2B;UACjH,IAAIwD,IAAI,KAAK+F,KAAK,EACjB,OAAO1J,gBAAgB,CAACO,yCAAyC,GAAGP,gBAAgB,CAACI,2BAA2B;QAClH;MACD;IACD;IACA,IAAI,CAACmJ,KAAK,IAAI,CAACC,KAAK,IAAIA,KAAK,CAAC3G,aAAa,KAAK0G,KAAK,CAAC1G,aAAa,EAAE;MACpE,OACC7C,gBAAgB,CAACE,8BAA8B,GAC/CF,gBAAgB,CAACO,yCAAyC,IACzDO,OAAO,CAAC0I,KAAK,CAAC3G,aAAa,CAAC,GAAG/B,OAAO,CAACyI,KAAK,CAAC1G,aAAa,CAAC,GACzD7C,gBAAgB,CAACI,2BAA2B,GAC5CJ,gBAAgB,CAACG,2BAA2B,CAAC;IAElD;IACA,IAAIuJ,KAAK,IAAIH,KAAK,KAAKC,KAAK,EAAE;MAC7B,OAAOxJ,gBAAgB,CAACK,0BAA0B,GAAGL,gBAAgB,CAACG,2BAA2B;IAClG;IACA,IAAIsJ,KAAK,IAAIF,KAAK,KAAKC,KAAK,EAAE;MAC7B,OAAOxJ,gBAAgB,CAACM,8BAA8B,GAAGN,gBAAgB,CAACI,2BAA2B;IACtG;IAEA,IAAIwJ,MAAM,GAAG,EAAE;IACf,IAAIC,SAAS,GAAGN,KAAK,CAACzC,UAAU;IAChC,OAAO+C,SAAS,EAAE;MACjB,IAAI,CAACH,KAAK,IAAIG,SAAS,KAAKL,KAAK,EAAE;QAClC,OAAOxJ,gBAAgB,CAACM,8BAA8B,GAAGN,gBAAgB,CAACI,2BAA2B;MACtG;MACAwJ,MAAM,CAACE,IAAI,CAACD,SAAS,CAAC;MACtBA,SAAS,GAAGA,SAAS,CAAC/C,UAAU;IACjC;IACA8C,MAAM,CAACG,OAAO,CAAC,CAAC;IAEhB,IAAIC,MAAM,GAAG,EAAE;IACf,IAAIC,SAAS,GAAGT,KAAK,CAAC1C,UAAU;IAChC,OAAOmD,SAAS,EAAE;MACjB,IAAI,CAACR,KAAK,IAAIQ,SAAS,KAAKV,KAAK,EAAE;QAClC,OAAOvJ,gBAAgB,CAACK,0BAA0B,GAAGL,gBAAgB,CAACG,2BAA2B;MAClG;MACA6J,MAAM,CAACF,IAAI,CAACG,SAAS,CAAC;MACtBA,SAAS,GAAGA,SAAS,CAACnD,UAAU;IACjC;IACAkD,MAAM,CAACD,OAAO,CAAC,CAAC;IAEhB,IAAIG,EAAE,GAAG1J,cAAc,CAACoJ,MAAM,EAAEI,MAAM,CAAC;IACvC,KAAK,IAAInJ,CAAC,IAAIqJ,EAAE,CAAC1E,UAAU,EAAE;MAC5B,IAAIsD,KAAK,GAAGoB,EAAE,CAAC1E,UAAU,CAAC3E,CAAC,CAAC;MAC5B,IAAIiI,KAAK,KAAKU,KAAK,EAAE,OAAOxJ,gBAAgB,CAACI,2BAA2B;MACxE,IAAI0I,KAAK,KAAKS,KAAK,EAAE,OAAOvJ,gBAAgB,CAACG,2BAA2B;MACxE,IAAI6J,MAAM,CAACxM,OAAO,CAACsL,KAAK,CAAC,IAAI,CAAC,EAAE,OAAO9I,gBAAgB,CAACI,2BAA2B;MACnF,IAAIwJ,MAAM,CAACpM,OAAO,CAACsL,KAAK,CAAC,IAAI,CAAC,EAAE,OAAO9I,gBAAgB,CAACG,2BAA2B;IACpF;IACA,OAAO,CAAC;EACT;AACD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgK,WAAWA,CAACvJ,CAAC,EAAE;EACvB,OACEA,CAAC,IAAI,GAAG,IAAI,MAAM,IAAMA,CAAC,IAAI,GAAG,IAAI,MAAO,IAAKA,CAAC,IAAI,GAAG,IAAI,OAAQ,IAAKA,CAAC,IAAI,GAAG,IAAI,QAAS,IAAI,IAAI,GAAGA,CAAC,CAACwJ,UAAU,CAAC,CAAC,GAAG,GAAG;AAEhI;AAEA9L,IAAI,CAACa,QAAQ,EAAEsH,IAAI,CAAC;AACpBnI,IAAI,CAACa,QAAQ,EAAEsH,IAAI,CAAC3H,SAAS,CAAC;AAC9BR,IAAI,CAAC0B,gBAAgB,EAAEyG,IAAI,CAAC;AAC5BnI,IAAI,CAAC0B,gBAAgB,EAAEyG,IAAI,CAAC3H,SAAS,CAAC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,SAASuL,UAAUA,CAAC/H,IAAI,EAAEgI,QAAQ,EAAE;EACnC,IAAIA,QAAQ,CAAChI,IAAI,CAAC,EAAE;IACnB,OAAO,IAAI;EACZ;EACA,IAAKA,IAAI,GAAGA,IAAI,CAACoE,UAAU,EAAG;IAC7B,GAAG;MACF,IAAI2D,UAAU,CAAC/H,IAAI,EAAEgI,QAAQ,CAAC,EAAE;QAC/B,OAAO,IAAI;MACZ;IACD,CAAC,QAAShI,IAAI,GAAGA,IAAI,CAACuE,WAAW;EAClC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvB,QAAQA,CAAC9I,MAAM,EAAEiL,OAAO,EAAE;EAClClL,WAAW,CAACC,MAAM,CAAC;EAEnB,IAAI+N,GAAG,GAAG9C,OAAO,IAAI,CAAC,CAAC;EACvB,IAAI,CAAC5E,aAAa,GAAG,IAAI;EACzB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC,IAAI,CAACmC,WAAW,GAAGuF,GAAG,CAACvF,WAAW,IAAIjJ,SAAS,CAACkJ,eAAe;EAC/D;AACD;AACA;AACA;AACA;AACA;EACC,IAAI,CAACuF,IAAI,GAAG5O,cAAc,CAAC,IAAI,CAACoJ,WAAW,CAAC,GAAG,MAAM,GAAG,KAAK;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvB,eAAeA,CAAC1C,GAAG,EAAEqC,EAAE,EAAEC,OAAO,EAAE;EAC1CtC,GAAG,IAAIA,GAAG,CAAC6B,IAAI,EAAE;EACjB,IAAI6H,EAAE,GAAGpH,OAAO,CAACgB,YAAY;EAC7B,IAAIoG,EAAE,KAAKzO,SAAS,CAACqC,KAAK,EAAE;IAC3B;IACA+E,EAAE,CAAC+F,MAAM,CAAC9F,OAAO,CAACrF,MAAM,GAAGqF,OAAO,CAACpF,SAAS,GAAG,EAAE,CAAC,GAAGoF,OAAO,CAACnB,KAAK;EACnE;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASsB,kBAAkBA,CAACzC,GAAG,EAAEqC,EAAE,EAAEC,OAAO,EAAEqH,MAAM,EAAE;EACrD3J,GAAG,IAAIA,GAAG,CAAC6B,IAAI,EAAE;EACjB,IAAI6H,EAAE,GAAGpH,OAAO,CAACgB,YAAY;EAC7B,IAAIoG,EAAE,KAAKzO,SAAS,CAACqC,KAAK,EAAE;IAC3B;IACA,OAAO+E,EAAE,CAAC+F,MAAM,CAAC9F,OAAO,CAACrF,MAAM,GAAGqF,OAAO,CAACpF,SAAS,GAAG,EAAE,CAAC;EAC1D;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0M,cAAcA,CAAC5J,GAAG,EAAEyG,MAAM,EAAEU,QAAQ,EAAE;EAC9C,IAAInH,GAAG,IAAIA,GAAG,CAAC6B,IAAI,EAAE;IACpB7B,GAAG,CAAC6B,IAAI,EAAE;IACV,IAAI4C,UAAU,GAAGgC,MAAM,CAAChC,UAAU;IAClC;IACA,IAAI0C,QAAQ,IAAI,CAACA,QAAQ,CAACrB,WAAW,EAAE;MACtC;MACArB,UAAU,CAACA,UAAU,CAAC7E,MAAM,EAAE,CAAC,GAAGuH,QAAQ;IAC3C,CAAC,MAAM;MACN;MACA;MACA,IAAIY,KAAK,GAAGtB,MAAM,CAACd,UAAU;MAC7B,IAAIjF,CAAC,GAAG,CAAC;MACT,OAAOqH,KAAK,EAAE;QACbtD,UAAU,CAAC/D,CAAC,EAAE,CAAC,GAAGqH,KAAK;QACvBA,KAAK,GAAGA,KAAK,CAACjC,WAAW;MAC1B;MACArB,UAAU,CAAC7E,MAAM,GAAGc,CAAC;MACrB,OAAO+D,UAAU,CAACA,UAAU,CAAC7E,MAAM,CAAC;IACrC;EACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8H,YAAYA,CAAC3B,UAAU,EAAEgC,KAAK,EAAE;EACxC,IAAIhC,UAAU,KAAKgC,KAAK,CAAChC,UAAU,EAAE;IACpC,MAAM,IAAI1K,YAAY,CAACA,YAAY,CAACoI,aAAa,EAAE,8BAA8B,CAAC;EACnF;EACA,IAAIoG,kBAAkB,GAAG9B,KAAK,CAAClC,eAAe;EAC9C,IAAIiE,cAAc,GAAG/B,KAAK,CAACjC,WAAW;EACtC,IAAI+D,kBAAkB,EAAE;IACvBA,kBAAkB,CAAC/D,WAAW,GAAGgE,cAAc;EAChD,CAAC,MAAM;IACN/D,UAAU,CAACJ,UAAU,GAAGmE,cAAc;EACvC;EACA,IAAIA,cAAc,EAAE;IACnBA,cAAc,CAACjE,eAAe,GAAGgE,kBAAkB;EACpD,CAAC,MAAM;IACN9D,UAAU,CAACH,SAAS,GAAGiE,kBAAkB;EAC1C;EACAD,cAAc,CAAC7D,UAAU,CAACjE,aAAa,EAAEiE,UAAU,CAAC;EACpDgC,KAAK,CAAChC,UAAU,GAAG,IAAI;EACvBgC,KAAK,CAAClC,eAAe,GAAG,IAAI;EAC5BkC,KAAK,CAACjC,WAAW,GAAG,IAAI;EACxB,OAAOiC,KAAK;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgC,sBAAsBA,CAACxI,IAAI,EAAE;EACrC,OACCA,IAAI,KACHA,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC7G,aAAa,IAAI0C,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC3G,sBAAsB,IAAIwC,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAACrH,YAAY,CAAC;AAEhI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2L,qBAAqBA,CAACzI,IAAI,EAAE;EACpC,OACCA,IAAI,KACHA,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAClH,kBAAkB,IACzC+C,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC9G,YAAY,IACnC2C,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC3G,sBAAsB,IAC7CwC,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC5G,kBAAkB,IACzCyC,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAACrH,YAAY,IACnCkD,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC/G,2BAA2B,IAClD4C,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAACnH,SAAS,CAAC;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0L,aAAaA,CAAC1I,IAAI,EAAE;EAC5B,OAAOA,IAAI,IAAIA,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC5G,kBAAkB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoL,aAAaA,CAAC3I,IAAI,EAAE;EAC5B,OAAOA,IAAI,IAAIA,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAACrH,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8L,UAAUA,CAAC5I,IAAI,EAAE;EACzB,OAAOA,IAAI,IAAIA,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAACnH,SAAS;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6L,0BAA0BA,CAACpK,GAAG,EAAE+H,KAAK,EAAE;EAC/C,IAAIsC,gBAAgB,GAAGrK,GAAG,CAACyE,UAAU,IAAI,EAAE;EAC3C,IAAI/J,IAAI,CAAC2P,gBAAgB,EAAEH,aAAa,CAAC,IAAID,aAAa,CAAClC,KAAK,CAAC,EAAE;IAClE,OAAO,KAAK;EACb;EACA,IAAIuC,WAAW,GAAG5P,IAAI,CAAC2P,gBAAgB,EAAEJ,aAAa,CAAC;EACvD,OAAO,EAAElC,KAAK,IAAIuC,WAAW,IAAID,gBAAgB,CAAC5N,OAAO,CAAC6N,WAAW,CAAC,GAAGD,gBAAgB,CAAC5N,OAAO,CAACsL,KAAK,CAAC,CAAC;AAC1G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwC,4BAA4BA,CAACvK,GAAG,EAAE+H,KAAK,EAAE;EACjD,IAAIsC,gBAAgB,GAAGrK,GAAG,CAACyE,UAAU,IAAI,EAAE;EAE3C,SAAS+F,6BAA6BA,CAACjJ,IAAI,EAAE;IAC5C,OAAO2I,aAAa,CAAC3I,IAAI,CAAC,IAAIA,IAAI,KAAKwG,KAAK;EAC7C;EAEA,IAAIrN,IAAI,CAAC2P,gBAAgB,EAAEG,6BAA6B,CAAC,EAAE;IAC1D,OAAO,KAAK;EACb;EACA,IAAIF,WAAW,GAAG5P,IAAI,CAAC2P,gBAAgB,EAAEJ,aAAa,CAAC;EACvD,OAAO,EAAElC,KAAK,IAAIuC,WAAW,IAAID,gBAAgB,CAAC5N,OAAO,CAAC6N,WAAW,CAAC,GAAGD,gBAAgB,CAAC5N,OAAO,CAACsL,KAAK,CAAC,CAAC;AAC1G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0C,8BAA8BA,CAAChE,MAAM,EAAElF,IAAI,EAAEwG,KAAK,EAAE;EAC5D;EACA,IAAI,CAACgC,sBAAsB,CAACtD,MAAM,CAAC,EAAE;IACpC,MAAM,IAAIpL,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,8BAA8B,GAAGjE,MAAM,CAACR,QAAQ,CAAC;EAC7G;EACA;EACA;EACA;EACA,IAAI8B,KAAK,IAAIA,KAAK,CAAChC,UAAU,KAAKU,MAAM,EAAE;IACzC,MAAM,IAAIpL,YAAY,CAACA,YAAY,CAACoI,aAAa,EAAE,qBAAqB,CAAC;EAC1E;EACA;EACC;EACA,CAACuG,qBAAqB,CAACzI,IAAI,CAAC;EAC5B;EACA;EACA;EACA;EACC0I,aAAa,CAAC1I,IAAI,CAAC,IAAIkF,MAAM,CAACR,QAAQ,KAAKP,IAAI,CAAC7G,aAAc,EAC9D;IACD,MAAM,IAAIxD,YAAY,CACrBA,YAAY,CAACqP,qBAAqB,EAClC,uBAAuB,GAAGnJ,IAAI,CAAC0E,QAAQ,GAAG,wBAAwB,GAAGQ,MAAM,CAACR,QAC7E,CAAC;EACF;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0E,oCAAoCA,CAAClE,MAAM,EAAElF,IAAI,EAAEwG,KAAK,EAAE;EAClE,IAAIsC,gBAAgB,GAAG5D,MAAM,CAAChC,UAAU,IAAI,EAAE;EAC9C,IAAImG,cAAc,GAAGrJ,IAAI,CAACkD,UAAU,IAAI,EAAE;;EAE1C;EACA,IAAIlD,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC3G,sBAAsB,EAAE;IAClD,IAAI8L,iBAAiB,GAAGD,cAAc,CAAC7O,MAAM,CAACmO,aAAa,CAAC;IAC5D;IACA,IAAIW,iBAAiB,CAACjL,MAAM,GAAG,CAAC,IAAIlF,IAAI,CAACkQ,cAAc,EAAET,UAAU,CAAC,EAAE;MACrE,MAAM,IAAI9O,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,2CAA2C,CAAC;IACxG;IACA;IACA;IACA,IAAIG,iBAAiB,CAACjL,MAAM,KAAK,CAAC,IAAI,CAACwK,0BAA0B,CAAC3D,MAAM,EAAEsB,KAAK,CAAC,EAAE;MACjF,MAAM,IAAI1M,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,wDAAwD,CAAC;IACrH;EACD;EACA;EACA,IAAIR,aAAa,CAAC3I,IAAI,CAAC,EAAE;IACxB;IACA;IACA,IAAI,CAAC6I,0BAA0B,CAAC3D,MAAM,EAAEsB,KAAK,CAAC,EAAE;MAC/C,MAAM,IAAI1M,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,sDAAsD,CAAC;IACnH;EACD;EACA;EACA,IAAIT,aAAa,CAAC1I,IAAI,CAAC,EAAE;IACxB;IACA,IAAI7G,IAAI,CAAC2P,gBAAgB,EAAEJ,aAAa,CAAC,EAAE;MAC1C,MAAM,IAAI5O,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,6BAA6B,CAAC;IAC1F;IACA,IAAII,kBAAkB,GAAGpQ,IAAI,CAAC2P,gBAAgB,EAAEH,aAAa,CAAC;IAC9D;IACA,IAAInC,KAAK,IAAIsC,gBAAgB,CAAC5N,OAAO,CAACqO,kBAAkB,CAAC,GAAGT,gBAAgB,CAAC5N,OAAO,CAACsL,KAAK,CAAC,EAAE;MAC5F,MAAM,IAAI1M,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,gDAAgD,CAAC;IAC7G;IACA;IACA,IAAI,CAAC3C,KAAK,IAAI+C,kBAAkB,EAAE;MACjC,MAAM,IAAIzP,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,sDAAsD,CAAC;IACnH;EACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASlD,sCAAsCA,CAACf,MAAM,EAAElF,IAAI,EAAEwG,KAAK,EAAE;EACpE,IAAIsC,gBAAgB,GAAG5D,MAAM,CAAChC,UAAU,IAAI,EAAE;EAC9C,IAAImG,cAAc,GAAGrJ,IAAI,CAACkD,UAAU,IAAI,EAAE;;EAE1C;EACA,IAAIlD,IAAI,CAAC0E,QAAQ,KAAKP,IAAI,CAAC3G,sBAAsB,EAAE;IAClD,IAAI8L,iBAAiB,GAAGD,cAAc,CAAC7O,MAAM,CAACmO,aAAa,CAAC;IAC5D;IACA,IAAIW,iBAAiB,CAACjL,MAAM,GAAG,CAAC,IAAIlF,IAAI,CAACkQ,cAAc,EAAET,UAAU,CAAC,EAAE;MACrE,MAAM,IAAI9O,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,2CAA2C,CAAC;IACxG;IACA;IACA,IAAIG,iBAAiB,CAACjL,MAAM,KAAK,CAAC,IAAI,CAAC2K,4BAA4B,CAAC9D,MAAM,EAAEsB,KAAK,CAAC,EAAE;MACnF,MAAM,IAAI1M,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,wDAAwD,CAAC;IACrH;EACD;EACA;EACA,IAAIR,aAAa,CAAC3I,IAAI,CAAC,EAAE;IACxB;IACA,IAAI,CAACgJ,4BAA4B,CAAC9D,MAAM,EAAEsB,KAAK,CAAC,EAAE;MACjD,MAAM,IAAI1M,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,sDAAsD,CAAC;IACnH;EACD;EACA;EACA,IAAIT,aAAa,CAAC1I,IAAI,CAAC,EAAE;IACxB,SAASwJ,6BAA6BA,CAACxJ,IAAI,EAAE;MAC5C,OAAO0I,aAAa,CAAC1I,IAAI,CAAC,IAAIA,IAAI,KAAKwG,KAAK;IAC7C;;IAEA;IACA,IAAIrN,IAAI,CAAC2P,gBAAgB,EAAEU,6BAA6B,CAAC,EAAE;MAC1D,MAAM,IAAI1P,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,6BAA6B,CAAC;IAC1F;IACA,IAAII,kBAAkB,GAAGpQ,IAAI,CAAC2P,gBAAgB,EAAEH,aAAa,CAAC;IAC9D;IACA,IAAInC,KAAK,IAAIsC,gBAAgB,CAAC5N,OAAO,CAACqO,kBAAkB,CAAC,GAAGT,gBAAgB,CAAC5N,OAAO,CAACsL,KAAK,CAAC,EAAE;MAC5F,MAAM,IAAI1M,YAAY,CAACA,YAAY,CAACqP,qBAAqB,EAAE,gDAAgD,CAAC;IAC7G;EACD;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrD,aAAaA,CAACZ,MAAM,EAAElF,IAAI,EAAEwG,KAAK,EAAEiD,oBAAoB,EAAE;EACjE;EACAP,8BAA8B,CAAChE,MAAM,EAAElF,IAAI,EAAEwG,KAAK,CAAC;;EAEnD;EACA;EACA,IAAItB,MAAM,CAACR,QAAQ,KAAKP,IAAI,CAAC7G,aAAa,EAAE;IAC3C,CAACmM,oBAAoB,IAAIL,oCAAoC,EAAElE,MAAM,EAAElF,IAAI,EAAEwG,KAAK,CAAC;EACpF;EAEA,IAAIkD,EAAE,GAAG1J,IAAI,CAACwE,UAAU;EACxB,IAAIkF,EAAE,EAAE;IACPA,EAAE,CAACxD,WAAW,CAAClG,IAAI,CAAC,CAAC,CAAC;EACvB;EACA,IAAIA,IAAI,CAAC0E,QAAQ,KAAKlH,sBAAsB,EAAE;IAC7C,IAAImM,QAAQ,GAAG3J,IAAI,CAACoE,UAAU;IAC9B,IAAIuF,QAAQ,IAAI,IAAI,EAAE;MACrB,OAAO3J,IAAI;IACZ;IACA,IAAI4J,OAAO,GAAG5J,IAAI,CAACqE,SAAS;EAC7B,CAAC,MAAM;IACNsF,QAAQ,GAAGC,OAAO,GAAG5J,IAAI;EAC1B;EACA,IAAI6J,GAAG,GAAGrD,KAAK,GAAGA,KAAK,CAAClC,eAAe,GAAGY,MAAM,CAACb,SAAS;EAE1DsF,QAAQ,CAACrF,eAAe,GAAGuF,GAAG;EAC9BD,OAAO,CAACrF,WAAW,GAAGiC,KAAK;EAE3B,IAAIqD,GAAG,EAAE;IACRA,GAAG,CAACtF,WAAW,GAAGoF,QAAQ;EAC3B,CAAC,MAAM;IACNzE,MAAM,CAACd,UAAU,GAAGuF,QAAQ;EAC7B;EACA,IAAInD,KAAK,IAAI,IAAI,EAAE;IAClBtB,MAAM,CAACb,SAAS,GAAGuF,OAAO;EAC3B,CAAC,MAAM;IACNpD,KAAK,CAAClC,eAAe,GAAGsF,OAAO;EAChC;EACA,GAAG;IACFD,QAAQ,CAACnF,UAAU,GAAGU,MAAM;EAC7B,CAAC,QAAQyE,QAAQ,KAAKC,OAAO,KAAKD,QAAQ,GAAGA,QAAQ,CAACpF,WAAW,CAAC;EAClE8D,cAAc,CAACnD,MAAM,CAAC3E,aAAa,IAAI2E,MAAM,EAAEA,MAAM,EAAElF,IAAI,CAAC;EAC5D,IAAIA,IAAI,CAAC0E,QAAQ,IAAIlH,sBAAsB,EAAE;IAC5CwC,IAAI,CAACoE,UAAU,GAAGpE,IAAI,CAACqE,SAAS,GAAG,IAAI;EACxC;EAEA,OAAOrE,IAAI;AACZ;AAEAgD,QAAQ,CAACxG,SAAS,GAAG;EACpB;AACD;AACA;AACA;AACA;AACA;EACCyG,cAAc,EAAE,IAAI;EACpBtB,QAAQ,EAAE,WAAW;EACrB+C,QAAQ,EAAEpH,aAAa;EACvB;AACD;AACA;AACA;AACA;AACA;EACCmF,OAAO,EAAE,IAAI;EACbqH,eAAe,EAAE,IAAI;EACrBxJ,IAAI,EAAE,CAAC;EAEPqF,YAAY,EAAE,SAAAA,CAAUC,QAAQ,EAAEC,QAAQ,EAAE;IAC3C;IACA,IAAID,QAAQ,CAAClB,QAAQ,KAAKlH,sBAAsB,EAAE;MACjD,IAAIgJ,KAAK,GAAGZ,QAAQ,CAACxB,UAAU;MAC/B,OAAOoC,KAAK,EAAE;QACb,IAAI7G,IAAI,GAAG6G,KAAK,CAACjC,WAAW;QAC5B,IAAI,CAACoB,YAAY,CAACa,KAAK,EAAEX,QAAQ,CAAC;QAClCW,KAAK,GAAG7G,IAAI;MACb;MACA,OAAOiG,QAAQ;IAChB;IACAE,aAAa,CAAC,IAAI,EAAEF,QAAQ,EAAEC,QAAQ,CAAC;IACvCD,QAAQ,CAACrF,aAAa,GAAG,IAAI;IAC7B,IAAI,IAAI,CAACuJ,eAAe,KAAK,IAAI,IAAIlE,QAAQ,CAAClB,QAAQ,KAAK5H,YAAY,EAAE;MACxE,IAAI,CAACgN,eAAe,GAAGlE,QAAQ;IAChC;IAEA,OAAOA,QAAQ;EAChB,CAAC;EACDM,WAAW,EAAE,SAAAA,CAAUF,QAAQ,EAAE;IAChC,IAAI+D,OAAO,GAAG5D,YAAY,CAAC,IAAI,EAAEH,QAAQ,CAAC;IAC1C,IAAI+D,OAAO,KAAK,IAAI,CAACD,eAAe,EAAE;MACrC,IAAI,CAACA,eAAe,GAAG,IAAI;IAC5B;IACA,OAAOC,OAAO;EACf,CAAC;EACDhE,YAAY,EAAE,SAAAA,CAAUH,QAAQ,EAAEI,QAAQ,EAAE;IAC3C;IACAF,aAAa,CAAC,IAAI,EAAEF,QAAQ,EAAEI,QAAQ,EAAEC,sCAAsC,CAAC;IAC/EL,QAAQ,CAACrF,aAAa,GAAG,IAAI;IAC7B,IAAIyF,QAAQ,EAAE;MACb,IAAI,CAACE,WAAW,CAACF,QAAQ,CAAC;IAC3B;IACA,IAAI2C,aAAa,CAAC/C,QAAQ,CAAC,EAAE;MAC5B,IAAI,CAACkE,eAAe,GAAGlE,QAAQ;IAChC;EACD,CAAC;EACD;EACAoE,UAAU,EAAE,SAAAA,CAAUC,YAAY,EAAE3D,IAAI,EAAE;IACzC,OAAO0D,UAAU,CAAC,IAAI,EAAEC,YAAY,EAAE3D,IAAI,CAAC;EAC5C,CAAC;EACD;EACA4D,cAAc,EAAE,SAAAA,CAAUC,EAAE,EAAE;IAC7B,IAAIC,GAAG,GAAG,IAAI;IACdrC,UAAU,CAAC,IAAI,CAAC+B,eAAe,EAAE,UAAU9J,IAAI,EAAE;MAChD,IAAIA,IAAI,CAAC0E,QAAQ,IAAI5H,YAAY,EAAE;QAClC,IAAIkD,IAAI,CAACqK,YAAY,CAAC,IAAI,CAAC,IAAIF,EAAE,EAAE;UAClCC,GAAG,GAAGpK,IAAI;UACV,OAAO,IAAI;QACZ;MACD;IACD,CAAC,CAAC;IACF,OAAOoK,GAAG;EACX,CAAC;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCrG,aAAa,EAAE,SAAAA,CAAUuG,OAAO,EAAE;IACjC,IAAItK,IAAI,GAAG,IAAIuK,OAAO,CAAC5Q,GAAG,CAAC;IAC3BqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzB,IAAI,IAAI,CAAC2H,IAAI,KAAK,MAAM,EAAE;MACzBoC,OAAO,GAAGA,OAAO,CAAC5I,WAAW,CAAC,CAAC;IAChC;IACA,IAAItI,uBAAuB,CAAC,IAAI,CAACsJ,WAAW,CAAC,EAAE;MAC9C1C,IAAI,CAAC+B,YAAY,GAAGrI,SAAS,CAACkJ,IAAI;IACnC;IACA5C,IAAI,CAAC2B,QAAQ,GAAG2I,OAAO;IACvBtK,IAAI,CAACsK,OAAO,GAAGA,OAAO;IACtBtK,IAAI,CAACrE,SAAS,GAAG2O,OAAO;IACxBtK,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChC,IAAI2L,KAAK,GAAIxK,IAAI,CAACsF,UAAU,GAAG,IAAI3E,YAAY,CAAC,CAAE;IAClD6J,KAAK,CAAChJ,aAAa,GAAGxB,IAAI;IAC1B,OAAOA,IAAI;EACZ,CAAC;EACD;AACD;AACA;EACCyK,sBAAsB,EAAE,SAAAA,CAAA,EAAY;IACnC,IAAIzK,IAAI,GAAG,IAAI0K,gBAAgB,CAAC/Q,GAAG,CAAC;IACpCqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChC,OAAOmB,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;EACCkE,cAAc,EAAE,SAAAA,CAAUuB,IAAI,EAAE;IAC/B,IAAIzF,IAAI,GAAG,IAAI2K,IAAI,CAAChR,GAAG,CAAC;IACxBqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAACyG,UAAU,CAAChB,IAAI,CAAC;IACrB,OAAOzF,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;EACC4K,aAAa,EAAE,SAAAA,CAAUnF,IAAI,EAAE;IAC9B,IAAIzF,IAAI,GAAG,IAAI6K,OAAO,CAAClR,GAAG,CAAC;IAC3BqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAACyG,UAAU,CAAChB,IAAI,CAAC;IACrB,OAAOzF,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;EACC8K,kBAAkB,EAAE,SAAAA,CAAUrF,IAAI,EAAE;IACnC,IAAIzF,IAAI,GAAG,IAAI+K,YAAY,CAACpR,GAAG,CAAC;IAChCqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAACyG,UAAU,CAAChB,IAAI,CAAC;IACrB,OAAOzF,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;AACA;EACCgL,2BAA2B,EAAE,SAAAA,CAAUxF,MAAM,EAAEC,IAAI,EAAE;IACpD,IAAIzF,IAAI,GAAG,IAAIiL,qBAAqB,CAACtR,GAAG,CAAC;IACzCqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAAC2B,QAAQ,GAAG3B,IAAI,CAACwF,MAAM,GAAGA,MAAM;IACpCxF,IAAI,CAAC2E,SAAS,GAAG3E,IAAI,CAACyF,IAAI,GAAGA,IAAI;IACjC,OAAOzF,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCkL,eAAe,EAAE,SAAAA,CAAUvH,IAAI,EAAE;IAChC,IAAI,CAAC3J,CAAC,CAACqB,WAAW,CAACC,IAAI,CAACqI,IAAI,CAAC,EAAE;MAC9B,MAAM,IAAI7J,YAAY,CAACA,YAAY,CAACyB,qBAAqB,EAAE,6BAA6B,GAAGoI,IAAI,GAAG,GAAG,CAAC;IACvG;IACA,IAAI,IAAI,CAACuE,IAAI,KAAK,MAAM,EAAE;MACzBvE,IAAI,GAAGA,IAAI,CAACjC,WAAW,CAAC,CAAC;IAC1B;IACA,OAAO,IAAI,CAACyJ,gBAAgB,CAACxH,IAAI,CAAC;EACnC,CAAC;EACDwH,gBAAgB,EAAE,SAAAA,CAAUxH,IAAI,EAAE;IACjC,IAAI3D,IAAI,GAAG,IAAIqH,IAAI,CAAC1N,GAAG,CAAC;IACxBqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAAC2D,IAAI,GAAGA,IAAI;IAChB3D,IAAI,CAAC2B,QAAQ,GAAGgC,IAAI;IACpB3D,IAAI,CAACrE,SAAS,GAAGgI,IAAI;IACrB3D,IAAI,CAACoL,SAAS,GAAG,IAAI;IACrB,OAAOpL,IAAI;EACZ,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCqL,qBAAqB,EAAE,SAAAA,CAAU1H,IAAI,EAAE;IACtC,IAAI,CAAC3J,CAAC,CAACsR,IAAI,CAAChQ,IAAI,CAACqI,IAAI,CAAC,EAAE;MACvB,MAAM,IAAI7J,YAAY,CAACA,YAAY,CAACyB,qBAAqB,EAAE,wBAAwB,GAAGoI,IAAI,GAAG,GAAG,CAAC;IAClG;IACA,IAAI,IAAI,CAACuE,IAAI,KAAK,MAAM,EAAE;MACzB,MAAM,IAAIpO,YAAY,CAAC,8BAA8B,EAAEC,gBAAgB,CAACwR,iBAAiB,CAAC;IAC3F;IAEA,IAAIvL,IAAI,GAAG,IAAIwL,eAAe,CAAC7R,GAAG,CAAC;IACnCqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAAC2B,QAAQ,GAAGgC,IAAI;IACpB,OAAO3D,IAAI;EACZ,CAAC;EACD;EACA;AACD;AACA;AACA;AACA;EACCqD,eAAe,EAAE,SAAAA,CAAUtB,YAAY,EAAE3G,aAAa,EAAE;IACvD,IAAIqQ,SAAS,GAAGjQ,kBAAkB,CAACuG,YAAY,EAAE3G,aAAa,CAAC;IAC/D,IAAI4E,IAAI,GAAG,IAAIuK,OAAO,CAAC5Q,GAAG,CAAC;IAC3B,IAAI6Q,KAAK,GAAIxK,IAAI,CAACsF,UAAU,GAAG,IAAI3E,YAAY,CAAC,CAAE;IAClDX,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAAC2B,QAAQ,GAAGvG,aAAa;IAC7B4E,IAAI,CAACsK,OAAO,GAAGlP,aAAa;IAC5B4E,IAAI,CAAC+B,YAAY,GAAG0J,SAAS,CAAC,CAAC,CAAC;IAChCzL,IAAI,CAACtE,MAAM,GAAG+P,SAAS,CAAC,CAAC,CAAC;IAC1BzL,IAAI,CAACrE,SAAS,GAAG8P,SAAS,CAAC,CAAC,CAAC;IAC7BjB,KAAK,CAAChJ,aAAa,GAAGxB,IAAI;IAC1B,OAAOA,IAAI;EACZ,CAAC;EACD;EACA;AACD;AACA;AACA;AACA;EACC0L,iBAAiB,EAAE,SAAAA,CAAU3J,YAAY,EAAE3G,aAAa,EAAE;IACzD,IAAIqQ,SAAS,GAAGjQ,kBAAkB,CAACuG,YAAY,EAAE3G,aAAa,CAAC;IAC/D,IAAI4E,IAAI,GAAG,IAAIqH,IAAI,CAAC1N,GAAG,CAAC;IACxBqG,IAAI,CAACO,aAAa,GAAG,IAAI;IACzBP,IAAI,CAACkD,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;IAChCmB,IAAI,CAAC2B,QAAQ,GAAGvG,aAAa;IAC7B4E,IAAI,CAAC2D,IAAI,GAAGvI,aAAa;IACzB4E,IAAI,CAACoL,SAAS,GAAG,IAAI;IACrBpL,IAAI,CAAC+B,YAAY,GAAG0J,SAAS,CAAC,CAAC,CAAC;IAChCzL,IAAI,CAACtE,MAAM,GAAG+P,SAAS,CAAC,CAAC,CAAC;IAC1BzL,IAAI,CAACrE,SAAS,GAAG8P,SAAS,CAAC,CAAC,CAAC;IAC7B,OAAOzL,IAAI;EACZ;AACD,CAAC;AACD5D,QAAQ,CAAC4G,QAAQ,EAAEmB,IAAI,CAAC;AAExB,SAASoG,OAAOA,CAACrQ,MAAM,EAAE;EACxBD,WAAW,CAACC,MAAM,CAAC;EAEnB,IAAI,CAAC2M,MAAM,GAAG/L,MAAM,CAAC6Q,MAAM,CAAC,IAAI,CAAC;AAClC;AACApB,OAAO,CAAC/N,SAAS,GAAG;EACnBkI,QAAQ,EAAE5H,YAAY;EACtB;AACD;AACA;AACA;AACA;EACCwI,UAAU,EAAE,IAAI;EAChBsG,gBAAgB,EAAE,SAAAA,CAAA,EAAY;IAC7B,OAAO,IAAI,CAAClQ,MAAM,GAAG,IAAI,CAACA,MAAM,GAAG,GAAG,GAAG,IAAI,CAACC,SAAS,GAAG,IAAI,CAACA,SAAS;EACzE,CAAC;EACD8F,6BAA6B,EAAE,SAAAA,CAAA,EAAY;IAC1C,OAAO,IAAI,CAAClB,aAAa,CAAC2H,IAAI,KAAK,MAAM,IAAI,IAAI,CAACnG,YAAY,KAAKrI,SAAS,CAACkJ,IAAI;EAClF,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;EACCiJ,aAAa,EAAE,SAAAA,CAAA,EAAY;IAC1B,OAAO,CAAC,EAAE,IAAI,CAACvG,UAAU,IAAI,IAAI,CAACA,UAAU,CAACjH,MAAM,CAAC;EACrD,CAAC;EACDyN,YAAY,EAAE,SAAAA,CAAUnI,IAAI,EAAE;IAC7B,OAAO,CAAC,CAAC,IAAI,CAACoI,gBAAgB,CAACpI,IAAI,CAAC;EACrC,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;EACC0G,YAAY,EAAE,SAAAA,CAAU1G,IAAI,EAAE;IAC7B,IAAItC,IAAI,GAAG,IAAI,CAAC0K,gBAAgB,CAACpI,IAAI,CAAC;IACtC,OAAOtC,IAAI,GAAGA,IAAI,CAACzB,KAAK,GAAG,IAAI;EAChC,CAAC;EACDmM,gBAAgB,EAAE,SAAAA,CAAUpI,IAAI,EAAE;IACjC,IAAI,IAAI,CAAClC,6BAA6B,CAAC,CAAC,EAAE;MACzCkC,IAAI,GAAGA,IAAI,CAACjC,WAAW,CAAC,CAAC;IAC1B;IACA,OAAO,IAAI,CAAC4D,UAAU,CAAC/D,YAAY,CAACoC,IAAI,CAAC;EAC1C,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;EACCqI,YAAY,EAAE,SAAAA,CAAUrI,IAAI,EAAE/D,KAAK,EAAE;IACpC,IAAI,IAAI,CAAC6B,6BAA6B,CAAC,CAAC,EAAE;MACzCkC,IAAI,GAAGA,IAAI,CAACjC,WAAW,CAAC,CAAC;IAC1B;IACA,IAAIL,IAAI,GAAG,IAAI,CAAC0K,gBAAgB,CAACpI,IAAI,CAAC;IACtC,IAAItC,IAAI,EAAE;MACTA,IAAI,CAACzB,KAAK,GAAGyB,IAAI,CAACsD,SAAS,GAAG,EAAE,GAAG/E,KAAK;IACzC,CAAC,MAAM;MACNyB,IAAI,GAAG,IAAI,CAACd,aAAa,CAAC4K,gBAAgB,CAACxH,IAAI,CAAC;MAChDtC,IAAI,CAACzB,KAAK,GAAGyB,IAAI,CAACsD,SAAS,GAAG,EAAE,GAAG/E,KAAK;MACxC,IAAI,CAACqM,gBAAgB,CAAC5K,IAAI,CAAC;IAC5B;EACD,CAAC;EACD6K,eAAe,EAAE,SAAAA,CAAUvI,IAAI,EAAE;IAChC,IAAItC,IAAI,GAAG,IAAI,CAAC0K,gBAAgB,CAACpI,IAAI,CAAC;IACtCtC,IAAI,IAAI,IAAI,CAAC8K,mBAAmB,CAAC9K,IAAI,CAAC;EACvC,CAAC;EACD4K,gBAAgB,EAAE,SAAAA,CAAUlL,OAAO,EAAE;IACpC,OAAO,IAAI,CAACuE,UAAU,CAAC1D,YAAY,CAACb,OAAO,CAAC;EAC7C,CAAC;EACDqL,kBAAkB,EAAE,SAAAA,CAAUrL,OAAO,EAAE;IACtC,OAAO,IAAI,CAACuE,UAAU,CAACtD,cAAc,CAACjB,OAAO,CAAC;EAC/C,CAAC;EACDoL,mBAAmB,EAAE,SAAAA,CAAUnL,OAAO,EAAE;IACvC;IACA,OAAO,IAAI,CAACsE,UAAU,CAACrD,eAAe,CAACjB,OAAO,CAACW,QAAQ,CAAC;EACzD,CAAC;EACD;EACA0K,iBAAiB,EAAE,SAAAA,CAAUtK,YAAY,EAAEpG,SAAS,EAAE;IACrD,IAAI2Q,GAAG,GAAG,IAAI,CAAC/G,kBAAkB,CAACxD,YAAY,EAAEpG,SAAS,CAAC;IAC1D2Q,GAAG,IAAI,IAAI,CAACH,mBAAmB,CAACG,GAAG,CAAC;EACrC,CAAC;EAEDC,cAAc,EAAE,SAAAA,CAAUxK,YAAY,EAAEpG,SAAS,EAAE;IAClD,OAAO,IAAI,CAAC4J,kBAAkB,CAACxD,YAAY,EAAEpG,SAAS,CAAC,IAAI,IAAI;EAChE,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC6Q,cAAc,EAAE,SAAAA,CAAUzK,YAAY,EAAEpG,SAAS,EAAE;IAClD,IAAI0F,IAAI,GAAG,IAAI,CAACkE,kBAAkB,CAACxD,YAAY,EAAEpG,SAAS,CAAC;IAC3D,OAAO0F,IAAI,GAAGA,IAAI,CAACzB,KAAK,GAAG,IAAI;EAChC,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC6M,cAAc,EAAE,SAAAA,CAAU1K,YAAY,EAAE3G,aAAa,EAAEwE,KAAK,EAAE;IAC7D,IAAI6L,SAAS,GAAGjQ,kBAAkB,CAACuG,YAAY,EAAE3G,aAAa,CAAC;IAC/D,IAAIO,SAAS,GAAG8P,SAAS,CAAC,CAAC,CAAC;IAC5B,IAAIpK,IAAI,GAAG,IAAI,CAACkE,kBAAkB,CAACxD,YAAY,EAAEpG,SAAS,CAAC;IAC3D,IAAI0F,IAAI,EAAE;MACTA,IAAI,CAACzB,KAAK,GAAGyB,IAAI,CAACsD,SAAS,GAAG,EAAE,GAAG/E,KAAK;IACzC,CAAC,MAAM;MACNyB,IAAI,GAAG,IAAI,CAACd,aAAa,CAACmL,iBAAiB,CAAC3J,YAAY,EAAE3G,aAAa,CAAC;MACxEiG,IAAI,CAACzB,KAAK,GAAGyB,IAAI,CAACsD,SAAS,GAAG,EAAE,GAAG/E,KAAK;MACxC,IAAI,CAACqM,gBAAgB,CAAC5K,IAAI,CAAC;IAC5B;EACD,CAAC;EACDkE,kBAAkB,EAAE,SAAAA,CAAUxD,YAAY,EAAEpG,SAAS,EAAE;IACtD,OAAO,IAAI,CAAC2J,UAAU,CAACxD,cAAc,CAACC,YAAY,EAAEpG,SAAS,CAAC;EAC/D,CAAC;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC+Q,sBAAsB,EAAE,SAAAA,CAAUC,UAAU,EAAE;IAC7C,IAAIC,aAAa,GAAGhS,YAAY,CAAC+R,UAAU,CAAC;IAC5C,OAAO,IAAI5M,YAAY,CAAC,IAAI,EAAE,UAAU8M,IAAI,EAAE;MAC7C,IAAIrM,EAAE,GAAG,EAAE;MACX,IAAIoM,aAAa,CAACvO,MAAM,GAAG,CAAC,EAAE;QAC7B0J,UAAU,CAAC8E,IAAI,EAAE,UAAU7M,IAAI,EAAE;UAChC,IAAIA,IAAI,KAAK6M,IAAI,IAAI7M,IAAI,CAAC0E,QAAQ,KAAK5H,YAAY,EAAE;YACpD,IAAIgQ,cAAc,GAAG9M,IAAI,CAACqK,YAAY,CAAC,OAAO,CAAC;YAC/C;YACA,IAAIyC,cAAc,EAAE;cACnB;cACA,IAAIC,OAAO,GAAGJ,UAAU,KAAKG,cAAc;cAC3C,IAAI,CAACC,OAAO,EAAE;gBACb,IAAIC,iBAAiB,GAAGpS,YAAY,CAACkS,cAAc,CAAC;gBACpDC,OAAO,GAAGH,aAAa,CAACK,KAAK,CAAChS,aAAa,CAAC+R,iBAAiB,CAAC,CAAC;cAChE;cACA,IAAID,OAAO,EAAE;gBACZvM,EAAE,CAACgH,IAAI,CAACxH,IAAI,CAAC;cACd;YACD;UACD;QACD,CAAC,CAAC;MACH;MACA,OAAOQ,EAAE;IACV,CAAC,CAAC;EACH,CAAC;EAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACC0M,oBAAoB,EAAE,SAAAA,CAAU9R,aAAa,EAAE;IAC9C,IAAI+R,cAAc,GAAG,CAAC,IAAI,CAACzI,QAAQ,KAAKpH,aAAa,GAAG,IAAI,GAAG,IAAI,CAACiD,aAAa,EAAE2H,IAAI,KAAK,MAAM;IAClG,IAAIkF,kBAAkB,GAAGhS,aAAa,CAACsG,WAAW,CAAC,CAAC;IACpD,OAAO,IAAI3B,YAAY,CAAC,IAAI,EAAE,UAAU8M,IAAI,EAAE;MAC7C,IAAIrM,EAAE,GAAG,EAAE;MACXuH,UAAU,CAAC8E,IAAI,EAAE,UAAU7M,IAAI,EAAE;QAChC,IAAIA,IAAI,KAAK6M,IAAI,IAAI7M,IAAI,CAAC0E,QAAQ,KAAK5H,YAAY,EAAE;UACpD;QACD;QACA,IAAI1B,aAAa,KAAK,GAAG,EAAE;UAC1BoF,EAAE,CAACgH,IAAI,CAACxH,IAAI,CAAC;QACd,CAAC,MAAM;UACN,IAAIqN,iBAAiB,GAAGrN,IAAI,CAAC4L,gBAAgB,CAAC,CAAC;UAC/C,IAAI0B,aAAa,GAAGH,cAAc,IAAInN,IAAI,CAAC+B,YAAY,KAAKrI,SAAS,CAACkJ,IAAI,GAAGwK,kBAAkB,GAAGhS,aAAa;UAC/G,IAAIiS,iBAAiB,KAAKC,aAAa,EAAE;YACxC9M,EAAE,CAACgH,IAAI,CAACxH,IAAI,CAAC;UACd;QACD;MACD,CAAC,CAAC;MACF,OAAOQ,EAAE;IACV,CAAC,CAAC;EACH,CAAC;EACD+M,sBAAsB,EAAE,SAAAA,CAAUxL,YAAY,EAAEpG,SAAS,EAAE;IAC1D,OAAO,IAAIoE,YAAY,CAAC,IAAI,EAAE,UAAU8M,IAAI,EAAE;MAC7C,IAAIrM,EAAE,GAAG,EAAE;MACXuH,UAAU,CAAC8E,IAAI,EAAE,UAAU7M,IAAI,EAAE;QAChC,IACCA,IAAI,KAAK6M,IAAI,IACb7M,IAAI,CAAC0E,QAAQ,KAAK5H,YAAY,KAC7BiF,YAAY,KAAK,GAAG,IAAI/B,IAAI,CAAC+B,YAAY,KAAKA,YAAY,CAAC,KAC3DpG,SAAS,KAAK,GAAG,IAAIqE,IAAI,CAACrE,SAAS,IAAIA,SAAS,CAAC,EACjD;UACD6E,EAAE,CAACgH,IAAI,CAACxH,IAAI,CAAC;QACd;MACD,CAAC,CAAC;MACF,OAAOQ,EAAE;IACV,CAAC,CAAC;EACH;AACD,CAAC;AACDwC,QAAQ,CAACxG,SAAS,CAACkQ,sBAAsB,GAAGnC,OAAO,CAAC/N,SAAS,CAACkQ,sBAAsB;AACpF1J,QAAQ,CAACxG,SAAS,CAAC0Q,oBAAoB,GAAG3C,OAAO,CAAC/N,SAAS,CAAC0Q,oBAAoB;AAChFlK,QAAQ,CAACxG,SAAS,CAAC+Q,sBAAsB,GAAGhD,OAAO,CAAC/N,SAAS,CAAC+Q,sBAAsB;AAEpFnR,QAAQ,CAACmO,OAAO,EAAEpG,IAAI,CAAC;AACvB,SAASkD,IAAIA,CAACnN,MAAM,EAAE;EACrBD,WAAW,CAACC,MAAM,CAAC;EAEnB,IAAI,CAAC6H,YAAY,GAAG,IAAI;EACxB,IAAI,CAACrG,MAAM,GAAG,IAAI;EAClB,IAAI,CAACuF,YAAY,GAAG,IAAI;AACzB;AACAoG,IAAI,CAAC7K,SAAS,CAACkI,QAAQ,GAAG3H,cAAc;AACxCX,QAAQ,CAACiL,IAAI,EAAElD,IAAI,CAAC;AAEpB,SAASqJ,aAAaA,CAACtT,MAAM,EAAE;EAC9BD,WAAW,CAACC,MAAM,CAAC;AACpB;AACAsT,aAAa,CAAChR,SAAS,GAAG;EACzBiJ,IAAI,EAAE,EAAE;EACRgI,aAAa,EAAE,SAAAA,CAAUC,MAAM,EAAEC,KAAK,EAAE;IACvC,OAAO,IAAI,CAAClI,IAAI,CAACmI,SAAS,CAACF,MAAM,EAAEA,MAAM,GAAGC,KAAK,CAAC;EACnD,CAAC;EACDlH,UAAU,EAAE,SAAAA,CAAUoH,IAAI,EAAE;IAC3BA,IAAI,GAAG,IAAI,CAACpI,IAAI,GAAGoI,IAAI;IACvB,IAAI,CAAClJ,SAAS,GAAG,IAAI,CAACc,IAAI,GAAGoI,IAAI;IACjC,IAAI,CAACxP,MAAM,GAAGwP,IAAI,CAACxP,MAAM;EAC1B,CAAC;EACDyP,UAAU,EAAE,SAAAA,CAAUJ,MAAM,EAAEG,IAAI,EAAE;IACnC,IAAI,CAACE,WAAW,CAACL,MAAM,EAAE,CAAC,EAAEG,IAAI,CAAC;EAClC,CAAC;EACDG,UAAU,EAAE,SAAAA,CAAUN,MAAM,EAAEC,KAAK,EAAE;IACpC,IAAI,CAACI,WAAW,CAACL,MAAM,EAAEC,KAAK,EAAE,EAAE,CAAC;EACpC,CAAC;EACDI,WAAW,EAAE,SAAAA,CAAUL,MAAM,EAAEC,KAAK,EAAEE,IAAI,EAAE;IAC3C,IAAII,KAAK,GAAG,IAAI,CAACxI,IAAI,CAACmI,SAAS,CAAC,CAAC,EAAEF,MAAM,CAAC;IAC1C,IAAIQ,GAAG,GAAG,IAAI,CAACzI,IAAI,CAACmI,SAAS,CAACF,MAAM,GAAGC,KAAK,CAAC;IAC7CE,IAAI,GAAGI,KAAK,GAAGJ,IAAI,GAAGK,GAAG;IACzB,IAAI,CAACvJ,SAAS,GAAG,IAAI,CAACc,IAAI,GAAGoI,IAAI;IACjC,IAAI,CAACxP,MAAM,GAAGwP,IAAI,CAACxP,MAAM;EAC1B;AACD,CAAC;AACDjC,QAAQ,CAACoR,aAAa,EAAErJ,IAAI,CAAC;AAC7B,SAASwG,IAAIA,CAACzQ,MAAM,EAAE;EACrBD,WAAW,CAACC,MAAM,CAAC;AACpB;AACAyQ,IAAI,CAACnO,SAAS,GAAG;EAChBmF,QAAQ,EAAE,OAAO;EACjB+C,QAAQ,EAAE1H,SAAS;EACnBmR,SAAS,EAAE,SAAAA,CAAUT,MAAM,EAAE;IAC5B,IAAIG,IAAI,GAAG,IAAI,CAACpI,IAAI;IACpB,IAAI2I,OAAO,GAAGP,IAAI,CAACD,SAAS,CAACF,MAAM,CAAC;IACpCG,IAAI,GAAGA,IAAI,CAACD,SAAS,CAAC,CAAC,EAAEF,MAAM,CAAC;IAChC,IAAI,CAACjI,IAAI,GAAG,IAAI,CAACd,SAAS,GAAGkJ,IAAI;IACjC,IAAI,CAACxP,MAAM,GAAGwP,IAAI,CAACxP,MAAM;IACzB,IAAIgQ,OAAO,GAAG,IAAI,CAAC9N,aAAa,CAAC2D,cAAc,CAACkK,OAAO,CAAC;IACxD,IAAI,IAAI,CAAC5J,UAAU,EAAE;MACpB,IAAI,CAACA,UAAU,CAACmB,YAAY,CAAC0I,OAAO,EAAE,IAAI,CAAC9J,WAAW,CAAC;IACxD;IACA,OAAO8J,OAAO;EACf;AACD,CAAC;AACDjS,QAAQ,CAACuO,IAAI,EAAE6C,aAAa,CAAC;AAC7B,SAAS3C,OAAOA,CAAC3Q,MAAM,EAAE;EACxBD,WAAW,CAACC,MAAM,CAAC;AACpB;AACA2Q,OAAO,CAACrO,SAAS,GAAG;EACnBmF,QAAQ,EAAE,UAAU;EACpB+C,QAAQ,EAAErH;AACX,CAAC;AACDjB,QAAQ,CAACyO,OAAO,EAAE2C,aAAa,CAAC;AAEhC,SAASzC,YAAYA,CAAC7Q,MAAM,EAAE;EAC7BD,WAAW,CAACC,MAAM,CAAC;AACpB;AACA6Q,YAAY,CAACvO,SAAS,GAAG;EACxBmF,QAAQ,EAAE,gBAAgB;EAC1B+C,QAAQ,EAAEzH;AACX,CAAC;AACDb,QAAQ,CAAC2O,YAAY,EAAEJ,IAAI,CAAC;AAE5B,SAASjH,YAAYA,CAACxJ,MAAM,EAAE;EAC7BD,WAAW,CAACC,MAAM,CAAC;AACpB;AACAwJ,YAAY,CAAClH,SAAS,CAACkI,QAAQ,GAAGnH,kBAAkB;AACpDnB,QAAQ,CAACsH,YAAY,EAAES,IAAI,CAAC;AAE5B,SAASmK,QAAQA,CAACpU,MAAM,EAAE;EACzBD,WAAW,CAACC,MAAM,CAAC;AACpB;AACAoU,QAAQ,CAAC9R,SAAS,CAACkI,QAAQ,GAAGjH,aAAa;AAC3CrB,QAAQ,CAACkS,QAAQ,EAAEnK,IAAI,CAAC;AAExB,SAASoK,MAAMA,CAACrU,MAAM,EAAE;EACvBD,WAAW,CAACC,MAAM,CAAC;AACpB;AACAqU,MAAM,CAAC/R,SAAS,CAACkI,QAAQ,GAAGvH,WAAW;AACvCf,QAAQ,CAACmS,MAAM,EAAEpK,IAAI,CAAC;AAEtB,SAASqH,eAAeA,CAACtR,MAAM,EAAE;EAChCD,WAAW,CAACC,MAAM,CAAC;AACpB;AACAsR,eAAe,CAAChP,SAAS,CAACkI,QAAQ,GAAGxH,qBAAqB;AAC1Dd,QAAQ,CAACoP,eAAe,EAAErH,IAAI,CAAC;AAE/B,SAASuG,gBAAgBA,CAACxQ,MAAM,EAAE;EACjCD,WAAW,CAACC,MAAM,CAAC;AACpB;AACAwQ,gBAAgB,CAAClO,SAAS,CAACmF,QAAQ,GAAG,oBAAoB;AAC1D+I,gBAAgB,CAAClO,SAAS,CAACkI,QAAQ,GAAGlH,sBAAsB;AAC5DpB,QAAQ,CAACsO,gBAAgB,EAAEvG,IAAI,CAAC;AAEhC,SAAS8G,qBAAqBA,CAAC/Q,MAAM,EAAE;EACtCD,WAAW,CAACC,MAAM,CAAC;AACpB;AACA+Q,qBAAqB,CAACzO,SAAS,CAACkI,QAAQ,GAAGtH,2BAA2B;AACtEhB,QAAQ,CAAC6O,qBAAqB,EAAEuC,aAAa,CAAC;AAC9C,SAASgB,aAAaA,CAAA,EAAG,CAAC;AAC1BA,aAAa,CAAChS,SAAS,CAAC4C,iBAAiB,GAAG,UAAUY,IAAI,EAAEf,UAAU,EAAE;EACvE,OAAOwP,qBAAqB,CAACjP,IAAI,CAACQ,IAAI,EAAEf,UAAU,CAAC;AACpD,CAAC;AACDkF,IAAI,CAAC3H,SAAS,CAACwC,QAAQ,GAAGyP,qBAAqB;AAC/C,SAASA,qBAAqBA,CAACxP,UAAU,EAAE;EAC1C,IAAIC,GAAG,GAAG,EAAE;EACZ,IAAIwP,OAAO,GAAI,IAAI,CAAChK,QAAQ,KAAKpH,aAAa,IAAI,IAAI,CAACwM,eAAe,IAAK,IAAI;EAC/E,IAAIpO,MAAM,GAAGgT,OAAO,CAAChT,MAAM;EAC3B,IAAIiT,GAAG,GAAGD,OAAO,CAAC3M,YAAY;EAE9B,IAAI4M,GAAG,IAAIjT,MAAM,IAAI,IAAI,EAAE;IAC1B,IAAIA,MAAM,GAAGgT,OAAO,CAAC/H,YAAY,CAACgI,GAAG,CAAC;IACtC,IAAIjT,MAAM,IAAI,IAAI,EAAE;MACnB,IAAIkT,iBAAiB,GAAG,CACvB;QAAEnT,SAAS,EAAEkT,GAAG;QAAEjT,MAAM,EAAE;MAAK;MAC/B;MAAA,CACA;IACF;EACD;EACA0D,iBAAiB,CAAC,IAAI,EAAEF,GAAG,EAAED,UAAU,EAAE2P,iBAAiB,CAAC;EAC3D,OAAO1P,GAAG,CAACG,IAAI,CAAC,EAAE,CAAC;AACpB;AAEA,SAASwP,mBAAmBA,CAAC7O,IAAI,EAAE8O,MAAM,EAAEF,iBAAiB,EAAE;EAC7D,IAAIlT,MAAM,GAAGsE,IAAI,CAACtE,MAAM,IAAI,EAAE;EAC9B,IAAIiT,GAAG,GAAG3O,IAAI,CAAC+B,YAAY;EAC3B;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,CAAC4M,GAAG,EAAE;IACT,OAAO,KAAK;EACb;EACA,IAAKjT,MAAM,KAAK,KAAK,IAAIiT,GAAG,KAAKjV,SAAS,CAACoC,GAAG,IAAK6S,GAAG,KAAKjV,SAAS,CAACqC,KAAK,EAAE;IAC3E,OAAO,KAAK;EACb;EAEA,IAAIoD,CAAC,GAAGyP,iBAAiB,CAACvQ,MAAM;EAChC,OAAOc,CAAC,EAAE,EAAE;IACX,IAAIgJ,EAAE,GAAGyG,iBAAiB,CAACzP,CAAC,CAAC;IAC7B;IACA,IAAIgJ,EAAE,CAACzM,MAAM,KAAKA,MAAM,EAAE;MACzB,OAAOyM,EAAE,CAAC1M,SAAS,KAAKkT,GAAG;IAC5B;EACD;EACA,OAAO,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,sBAAsBA,CAAC7P,GAAG,EAAE9D,aAAa,EAAEwE,KAAK,EAAE;EAC1DV,GAAG,CAACsI,IAAI,CAAC,GAAG,EAAEpM,aAAa,EAAE,IAAI,EAAEwE,KAAK,CAACoP,OAAO,CAAC,eAAe,EAAEnH,WAAW,CAAC,EAAE,GAAG,CAAC;AACrF;AAEA,SAASzI,iBAAiBA,CAACY,IAAI,EAAEd,GAAG,EAAED,UAAU,EAAE2P,iBAAiB,EAAE;EACpE,IAAI,CAACA,iBAAiB,EAAE;IACvBA,iBAAiB,GAAG,EAAE;EACvB;EACA,IAAInQ,GAAG,GAAGuB,IAAI,CAAC0E,QAAQ,KAAKpH,aAAa,GAAG0C,IAAI,GAAGA,IAAI,CAACO,aAAa;EACrE,IAAIuO,MAAM,GAAGrQ,GAAG,CAACyJ,IAAI,KAAK,MAAM;EAEhC,IAAIjJ,UAAU,EAAE;IACfe,IAAI,GAAGf,UAAU,CAACe,IAAI,CAAC;IACvB,IAAIA,IAAI,EAAE;MACT,IAAI,OAAOA,IAAI,IAAI,QAAQ,EAAE;QAC5Bd,GAAG,CAACsI,IAAI,CAACxH,IAAI,CAAC;QACd;MACD;IACD,CAAC,MAAM;MACN;IACD;IACA;EACD;EAEA,QAAQA,IAAI,CAAC0E,QAAQ;IACpB,KAAK5H,YAAY;MAChB,IAAI0N,KAAK,GAAGxK,IAAI,CAACsF,UAAU;MAC3B,IAAI2J,GAAG,GAAGzE,KAAK,CAACnM,MAAM;MACtB,IAAImI,KAAK,GAAGxG,IAAI,CAACoE,UAAU;MAC3B,IAAIzC,QAAQ,GAAG3B,IAAI,CAACsK,OAAO;MAE3B,IAAI4E,gBAAgB,GAAGvN,QAAQ;MAC/B,IAAI,CAACmN,MAAM,IAAI,CAAC9O,IAAI,CAACtE,MAAM,IAAIsE,IAAI,CAAC+B,YAAY,EAAE;QACjD,IAAIoN,SAAS;QACb;QACA,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG5E,KAAK,CAACnM,MAAM,EAAE+Q,EAAE,EAAE,EAAE;UACzC,IAAI5E,KAAK,CAAC1L,IAAI,CAACsQ,EAAE,CAAC,CAACzL,IAAI,KAAK,OAAO,EAAE;YACpCwL,SAAS,GAAG3E,KAAK,CAAC1L,IAAI,CAACsQ,EAAE,CAAC,CAACxP,KAAK;YAChC;UACD;QACD;QACA,IAAI,CAACuP,SAAS,EAAE;UACf;UACA,KAAK,IAAIE,GAAG,GAAGT,iBAAiB,CAACvQ,MAAM,GAAG,CAAC,EAAEgR,GAAG,IAAI,CAAC,EAAEA,GAAG,EAAE,EAAE;YAC7D,IAAI5T,SAAS,GAAGmT,iBAAiB,CAACS,GAAG,CAAC;YACtC,IAAI5T,SAAS,CAACC,MAAM,KAAK,EAAE,IAAID,SAAS,CAACA,SAAS,KAAKuE,IAAI,CAAC+B,YAAY,EAAE;cACzEoN,SAAS,GAAG1T,SAAS,CAACA,SAAS;cAC/B;YACD;UACD;QACD;QACA,IAAI0T,SAAS,KAAKnP,IAAI,CAAC+B,YAAY,EAAE;UACpC,KAAK,IAAIsN,GAAG,GAAGT,iBAAiB,CAACvQ,MAAM,GAAG,CAAC,EAAEgR,GAAG,IAAI,CAAC,EAAEA,GAAG,EAAE,EAAE;YAC7D,IAAI5T,SAAS,GAAGmT,iBAAiB,CAACS,GAAG,CAAC;YACtC,IAAI5T,SAAS,CAACA,SAAS,KAAKuE,IAAI,CAAC+B,YAAY,EAAE;cAC9C,IAAItG,SAAS,CAACC,MAAM,EAAE;gBACrBwT,gBAAgB,GAAGzT,SAAS,CAACC,MAAM,GAAG,GAAG,GAAGiG,QAAQ;cACrD;cACA;YACD;UACD;QACD;MACD;MAEAzC,GAAG,CAACsI,IAAI,CAAC,GAAG,EAAE0H,gBAAgB,CAAC;MAE/B,KAAK,IAAI/P,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8P,GAAG,EAAE9P,CAAC,EAAE,EAAE;QAC7B;QACA,IAAIkC,IAAI,GAAGmJ,KAAK,CAAC1L,IAAI,CAACK,CAAC,CAAC;QACxB,IAAIkC,IAAI,CAAC3F,MAAM,IAAI,OAAO,EAAE;UAC3BkT,iBAAiB,CAACpH,IAAI,CAAC;YACtB9L,MAAM,EAAE2F,IAAI,CAAC1F,SAAS;YACtBF,SAAS,EAAE4F,IAAI,CAACzB;UACjB,CAAC,CAAC;QACH,CAAC,MAAM,IAAIyB,IAAI,CAACM,QAAQ,IAAI,OAAO,EAAE;UACpCiN,iBAAiB,CAACpH,IAAI,CAAC;YAAE9L,MAAM,EAAE,EAAE;YAAED,SAAS,EAAE4F,IAAI,CAACzB;UAAM,CAAC,CAAC;QAC9D;MACD;MAEA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8P,GAAG,EAAE9P,CAAC,EAAE,EAAE;QAC7B,IAAIkC,IAAI,GAAGmJ,KAAK,CAAC1L,IAAI,CAACK,CAAC,CAAC;QACxB,IAAI0P,mBAAmB,CAACxN,IAAI,EAAEyN,MAAM,EAAEF,iBAAiB,CAAC,EAAE;UACzD,IAAIlT,MAAM,GAAG2F,IAAI,CAAC3F,MAAM,IAAI,EAAE;UAC9B,IAAIiT,GAAG,GAAGtN,IAAI,CAACU,YAAY;UAC3BgN,sBAAsB,CAAC7P,GAAG,EAAExD,MAAM,GAAG,QAAQ,GAAGA,MAAM,GAAG,OAAO,EAAEiT,GAAG,CAAC;UACtEC,iBAAiB,CAACpH,IAAI,CAAC;YAAE9L,MAAM,EAAEA,MAAM;YAAED,SAAS,EAAEkT;UAAI,CAAC,CAAC;QAC3D;QACAvP,iBAAiB,CAACiC,IAAI,EAAEnC,GAAG,EAAED,UAAU,EAAE2P,iBAAiB,CAAC;MAC5D;;MAEA;MACA,IAAIjN,QAAQ,KAAKuN,gBAAgB,IAAIL,mBAAmB,CAAC7O,IAAI,EAAE8O,MAAM,EAAEF,iBAAiB,CAAC,EAAE;QAC1F,IAAIlT,MAAM,GAAGsE,IAAI,CAACtE,MAAM,IAAI,EAAE;QAC9B,IAAIiT,GAAG,GAAG3O,IAAI,CAAC+B,YAAY;QAC3BgN,sBAAsB,CAAC7P,GAAG,EAAExD,MAAM,GAAG,QAAQ,GAAGA,MAAM,GAAG,OAAO,EAAEiT,GAAG,CAAC;QACtEC,iBAAiB,CAACpH,IAAI,CAAC;UAAE9L,MAAM,EAAEA,MAAM;UAAED,SAAS,EAAEkT;QAAI,CAAC,CAAC;MAC3D;MACA;MACA,IAAIW,WAAW,GAAG,CAAC9I,KAAK;MACxB,IAAI8I,WAAW,KAAKR,MAAM,IAAI9O,IAAI,CAAC+B,YAAY,KAAKrI,SAAS,CAACkJ,IAAI,CAAC,EAAE;QACpE;QACA0M,WAAW,GAAG9V,iBAAiB,CAACmI,QAAQ,CAAC;MAC1C;MACA,IAAI2N,WAAW,EAAE;QAChBpQ,GAAG,CAACsI,IAAI,CAAC,IAAI,CAAC;MACf,CAAC,MAAM;QACNtI,GAAG,CAACsI,IAAI,CAAC,GAAG,CAAC;QACb;QACA,IAAIsH,MAAM,IAAIvV,oBAAoB,CAACoI,QAAQ,CAAC,EAAE;UAC7C,OAAO6E,KAAK,EAAE;YACb,IAAIA,KAAK,CAACf,IAAI,EAAE;cACfvG,GAAG,CAACsI,IAAI,CAAChB,KAAK,CAACf,IAAI,CAAC;YACrB,CAAC,MAAM;cACNrG,iBAAiB,CAACoH,KAAK,EAAEtH,GAAG,EAAED,UAAU,EAAE2P,iBAAiB,CAACW,KAAK,CAAC,CAAC,CAAC;YACrE;YACA/I,KAAK,GAAGA,KAAK,CAACjC,WAAW;UAC1B;QACD,CAAC,MAAM;UACN,OAAOiC,KAAK,EAAE;YACbpH,iBAAiB,CAACoH,KAAK,EAAEtH,GAAG,EAAED,UAAU,EAAE2P,iBAAiB,CAACW,KAAK,CAAC,CAAC,CAAC;YACpE/I,KAAK,GAAGA,KAAK,CAACjC,WAAW;UAC1B;QACD;QACArF,GAAG,CAACsI,IAAI,CAAC,IAAI,EAAE0H,gBAAgB,EAAE,GAAG,CAAC;MACtC;MACA;MACA;MACA;IACD,KAAK5R,aAAa;IAClB,KAAKE,sBAAsB;MAC1B,IAAIgJ,KAAK,GAAGxG,IAAI,CAACoE,UAAU;MAC3B,OAAOoC,KAAK,EAAE;QACbpH,iBAAiB,CAACoH,KAAK,EAAEtH,GAAG,EAAED,UAAU,EAAE2P,iBAAiB,CAACW,KAAK,CAAC,CAAC,CAAC;QACpE/I,KAAK,GAAGA,KAAK,CAACjC,WAAW;MAC1B;MACA;IACD,KAAKxH,cAAc;MAClB,OAAOgS,sBAAsB,CAAC7P,GAAG,EAAEc,IAAI,CAAC2D,IAAI,EAAE3D,IAAI,CAACJ,KAAK,CAAC;IAC1D,KAAK5C,SAAS;MACb;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACG,OAAOkC,GAAG,CAACsI,IAAI,CAACxH,IAAI,CAACyF,IAAI,CAACuJ,OAAO,CAAC,QAAQ,EAAEnH,WAAW,CAAC,CAAC;IAC1D,KAAK5K,kBAAkB;MACtB,OAAOiC,GAAG,CAACsI,IAAI,CAACxN,CAAC,CAACwV,WAAW,EAAExP,IAAI,CAACyF,IAAI,EAAEzL,CAAC,CAACyV,SAAS,CAAC;IACvD,KAAKpS,YAAY;MAChB,OAAO6B,GAAG,CAACsI,IAAI,CAACxN,CAAC,CAAC0V,aAAa,EAAE1P,IAAI,CAACyF,IAAI,EAAEzL,CAAC,CAAC2V,WAAW,CAAC;IAC3D,KAAKpS,kBAAkB;MACtB,IAAIqS,KAAK,GAAG5P,IAAI,CAACuD,QAAQ;MACzB,IAAIsM,KAAK,GAAG7P,IAAI,CAACwD,QAAQ;MACzBtE,GAAG,CAACsI,IAAI,CAACxN,CAAC,CAAC8V,kBAAkB,EAAE,GAAG,EAAE9P,IAAI,CAAC2D,IAAI,CAAC;MAC9C,IAAIiM,KAAK,EAAE;QACV1Q,GAAG,CAACsI,IAAI,CAAC,GAAG,EAAExN,CAAC,CAAC+V,MAAM,EAAE,GAAG,EAAEH,KAAK,CAAC;QACnC,IAAIC,KAAK,IAAIA,KAAK,KAAK,GAAG,EAAE;UAC3B3Q,GAAG,CAACsI,IAAI,CAAC,GAAG,EAAEqI,KAAK,CAAC;QACrB;MACD,CAAC,MAAM,IAAIA,KAAK,IAAIA,KAAK,KAAK,GAAG,EAAE;QAClC3Q,GAAG,CAACsI,IAAI,CAAC,GAAG,EAAExN,CAAC,CAACgW,MAAM,EAAE,GAAG,EAAEH,KAAK,CAAC;MACpC;MACA,IAAI7P,IAAI,CAACyD,cAAc,EAAE;QACxBvE,GAAG,CAACsI,IAAI,CAAC,IAAI,EAAExH,IAAI,CAACyD,cAAc,EAAE,GAAG,CAAC;MACzC;MACAvE,GAAG,CAACsI,IAAI,CAAC,GAAG,CAAC;MACb;IACD,KAAKpK,2BAA2B;MAC/B,OAAO8B,GAAG,CAACsI,IAAI,CAAC,IAAI,EAAExH,IAAI,CAACwF,MAAM,EAAE,GAAG,EAAExF,IAAI,CAACyF,IAAI,EAAE,IAAI,CAAC;IACzD,KAAKvI,qBAAqB;MACzB,OAAOgC,GAAG,CAACsI,IAAI,CAAC,GAAG,EAAExH,IAAI,CAAC2B,QAAQ,EAAE,GAAG,CAAC;IACzC;IACA;IACA;MACCzC,GAAG,CAACsI,IAAI,CAAC,IAAI,EAAExH,IAAI,CAAC2B,QAAQ,CAAC;EAC/B;AACD;AACA,SAASqI,UAAUA,CAACvL,GAAG,EAAEuB,IAAI,EAAEsG,IAAI,EAAE;EACpC,IAAIY,KAAK;EACT,QAAQlH,IAAI,CAAC0E,QAAQ;IACpB,KAAK5H,YAAY;MAChBoK,KAAK,GAAGlH,IAAI,CAACqG,SAAS,CAAC,KAAK,CAAC;MAC7Ba,KAAK,CAAC3G,aAAa,GAAG9B,GAAG;IAC1B;IACA;IACA;IACA;IACA;IACA,KAAKjB,sBAAsB;MAC1B;IACD,KAAKT,cAAc;MAClBuJ,IAAI,GAAG,IAAI;MACX;IACD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EACD;EACA,IAAI,CAACY,KAAK,EAAE;IACXA,KAAK,GAAGlH,IAAI,CAACqG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;EAChC;EACAa,KAAK,CAAC3G,aAAa,GAAG9B,GAAG;EACzByI,KAAK,CAAC1C,UAAU,GAAG,IAAI;EACvB,IAAI8B,IAAI,EAAE;IACT,IAAIE,KAAK,GAAGxG,IAAI,CAACoE,UAAU;IAC3B,OAAOoC,KAAK,EAAE;MACbU,KAAK,CAAC/D,WAAW,CAAC6G,UAAU,CAACvL,GAAG,EAAE+H,KAAK,EAAEF,IAAI,CAAC,CAAC;MAC/CE,KAAK,GAAGA,KAAK,CAACjC,WAAW;IAC1B;EACD;EACA,OAAO2C,KAAK;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,SAASA,CAAC5H,GAAG,EAAEuB,IAAI,EAAEsG,IAAI,EAAE;EACnC,IAAIY,KAAK,GAAG,IAAIlH,IAAI,CAACtD,WAAW,CAAC/C,GAAG,CAAC;EACrC,KAAK,IAAI4E,CAAC,IAAIyB,IAAI,EAAE;IACnB,IAAI3G,MAAM,CAAC2G,IAAI,EAAEzB,CAAC,CAAC,EAAE;MACpB,IAAI0R,CAAC,GAAGjQ,IAAI,CAACzB,CAAC,CAAC;MACf,IAAI,OAAO0R,CAAC,IAAI,QAAQ,EAAE;QACzB,IAAIA,CAAC,IAAI/I,KAAK,CAAC3I,CAAC,CAAC,EAAE;UAClB2I,KAAK,CAAC3I,CAAC,CAAC,GAAG0R,CAAC;QACb;MACD;IACD;EACD;EACA,IAAIjQ,IAAI,CAACkD,UAAU,EAAE;IACpBgE,KAAK,CAAChE,UAAU,GAAG,IAAIrE,QAAQ,CAAC,CAAC;EAClC;EACAqI,KAAK,CAAC3G,aAAa,GAAG9B,GAAG;EACzB,QAAQyI,KAAK,CAACxC,QAAQ;IACrB,KAAK5H,YAAY;MAChB,IAAI0N,KAAK,GAAGxK,IAAI,CAACsF,UAAU;MAC3B,IAAI4K,MAAM,GAAIhJ,KAAK,CAAC5B,UAAU,GAAG,IAAI3E,YAAY,CAAC,CAAE;MACpD,IAAIsO,GAAG,GAAGzE,KAAK,CAACnM,MAAM;MACtB6R,MAAM,CAAC1O,aAAa,GAAG0F,KAAK;MAC5B,KAAK,IAAI/H,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8P,GAAG,EAAE9P,CAAC,EAAE,EAAE;QAC7B+H,KAAK,CAAC+E,gBAAgB,CAAC5F,SAAS,CAAC5H,GAAG,EAAE+L,KAAK,CAAC1L,IAAI,CAACK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;MAC5D;MACA;IACD,KAAKpC,cAAc;MAClBuJ,IAAI,GAAG,IAAI;EACb;EACA,IAAIA,IAAI,EAAE;IACT,IAAIE,KAAK,GAAGxG,IAAI,CAACoE,UAAU;IAC3B,OAAOoC,KAAK,EAAE;MACbU,KAAK,CAAC/D,WAAW,CAACkD,SAAS,CAAC5H,GAAG,EAAE+H,KAAK,EAAEF,IAAI,CAAC,CAAC;MAC9CE,KAAK,GAAGA,KAAK,CAACjC,WAAW;IAC1B;EACD;EACA,OAAO2C,KAAK;AACb;AAEA,SAASzG,OAAOA,CAAC0P,MAAM,EAAEC,GAAG,EAAExQ,KAAK,EAAE;EACpCuQ,MAAM,CAACC,GAAG,CAAC,GAAGxQ,KAAK;AACpB;AACA;AACA,IAAI;EACH,IAAI9E,MAAM,CAACuV,cAAc,EAAE;IAC1BvV,MAAM,CAACuV,cAAc,CAACtQ,YAAY,CAACvD,SAAS,EAAE,QAAQ,EAAE;MACvD8T,GAAG,EAAE,SAAAA,CAAA,EAAY;QAChBlQ,eAAe,CAAC,IAAI,CAAC;QACrB,OAAO,IAAI,CAACM,QAAQ;MACrB;IACD,CAAC,CAAC;IAEF5F,MAAM,CAACuV,cAAc,CAAClM,IAAI,CAAC3H,SAAS,EAAE,aAAa,EAAE;MACpD8T,GAAG,EAAE,SAAAA,CAAA,EAAY;QAChB,OAAOC,cAAc,CAAC,IAAI,CAAC;MAC5B,CAAC;MAEDC,GAAG,EAAE,SAAAA,CAAU/K,IAAI,EAAE;QACpB,QAAQ,IAAI,CAACf,QAAQ;UACpB,KAAK5H,YAAY;UACjB,KAAKU,sBAAsB;YAC1B,OAAO,IAAI,CAAC4G,UAAU,EAAE;cACvB,IAAI,CAAC8B,WAAW,CAAC,IAAI,CAAC9B,UAAU,CAAC;YAClC;YACA,IAAIqB,IAAI,IAAIgL,MAAM,CAAChL,IAAI,CAAC,EAAE;cACzB,IAAI,CAACtC,WAAW,CAAC,IAAI,CAAC5C,aAAa,CAAC2D,cAAc,CAACuB,IAAI,CAAC,CAAC;YAC1D;YACA;UAED;YACC,IAAI,CAACA,IAAI,GAAGA,IAAI;YAChB,IAAI,CAAC7F,KAAK,GAAG6F,IAAI;YACjB,IAAI,CAACd,SAAS,GAAGc,IAAI;QACvB;MACD;IACD,CAAC,CAAC;IAEF,SAAS8K,cAAcA,CAACvQ,IAAI,EAAE;MAC7B,QAAQA,IAAI,CAAC0E,QAAQ;QACpB,KAAK5H,YAAY;QACjB,KAAKU,sBAAsB;UAC1B,IAAI0B,GAAG,GAAG,EAAE;UACZc,IAAI,GAAGA,IAAI,CAACoE,UAAU;UACtB,OAAOpE,IAAI,EAAE;YACZ,IAAIA,IAAI,CAAC0E,QAAQ,KAAK,CAAC,IAAI1E,IAAI,CAAC0E,QAAQ,KAAK,CAAC,EAAE;cAC/CxF,GAAG,CAACsI,IAAI,CAAC+I,cAAc,CAACvQ,IAAI,CAAC,CAAC;YAC/B;YACAA,IAAI,GAAGA,IAAI,CAACuE,WAAW;UACxB;UACA,OAAOrF,GAAG,CAACG,IAAI,CAAC,EAAE,CAAC;QACpB;UACC,OAAOW,IAAI,CAAC2E,SAAS;MACvB;IACD;IAEAlE,OAAO,GAAG,SAAAA,CAAU0P,MAAM,EAAEC,GAAG,EAAExQ,KAAK,EAAE;MACvC;MACAuQ,MAAM,CAAC,IAAI,GAAGC,GAAG,CAAC,GAAGxQ,KAAK;IAC3B,CAAC;EACF;AACD,CAAC,CAAC,OAAO8Q,CAAC,EAAE;EACX;AAAA;AAGDC,OAAO,CAACvQ,eAAe,GAAGA,eAAe;AACzCuQ,OAAO,CAACtJ,IAAI,GAAGA,IAAI;AACnBsJ,OAAO,CAAC5F,YAAY,GAAGA,YAAY;AACnC4F,OAAO,CAACnD,aAAa,GAAGA,aAAa;AACrCmD,OAAO,CAAC9F,OAAO,GAAGA,OAAO;AACzB8F,OAAO,CAAC3N,QAAQ,GAAGA,QAAQ;AAC3B2N,OAAO,CAACjG,gBAAgB,GAAGA,gBAAgB;AAC3CiG,OAAO,CAACjN,YAAY,GAAGA,YAAY;AACnCiN,OAAO,CAACvO,iBAAiB,GAAGA,iBAAiB;AAC7CuO,OAAO,CAACpG,OAAO,GAAGA,OAAO;AACzBoG,OAAO,CAACpC,MAAM,GAAGA,MAAM;AACvBoC,OAAO,CAACnF,eAAe,GAAGA,eAAe;AACzCmF,OAAO,CAAC5Q,YAAY,GAAGA,YAAY;AACnC4Q,OAAO,CAAChQ,YAAY,GAAGA,YAAY;AACnCgQ,OAAO,CAACxM,IAAI,GAAGA,IAAI;AACnBwM,OAAO,CAAC9R,QAAQ,GAAGA,QAAQ;AAC3B8R,OAAO,CAACrC,QAAQ,GAAGA,QAAQ;AAC3BqC,OAAO,CAAChG,IAAI,GAAGA,IAAI;AACnBgG,OAAO,CAAC1F,qBAAqB,GAAGA,qBAAqB;AACrD0F,OAAO,CAACnC,aAAa,GAAGA,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}